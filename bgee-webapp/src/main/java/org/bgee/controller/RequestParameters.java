package org.bgee.controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.exception.RequestParametersNotFoundException;
import org.bgee.controller.exception.RequestParametersNotStorableException;
import org.bgee.controller.servletutils.BgeeHttpServletRequest;
import org.bgee.utils.BgeeStringUtils;

/**
 * This class is intended to hold parameters of a query to the server, 
 * and also to generate URLs based on these parameters. 
 * <p>
 * This class can analyze a <code>HttpServletRequest</code> to extract 
 * and secure relevant parameters of a query to the server. 
 * It is also able to generate URLs based on these parameters, 
 * so that all links generated by the View are constructed by this class.
 * <p>
 * The parameters are represented by the class {@link URLParameter} and accessible through the class
 * {@link URLParameters} that provides individual access to each {@code URLParameter} or an
 * {@code ArrayList} that contains all existing {@code URLParameter}. These parameters are used by
 * this class as key to store their values in a {@code HashMap}
 * <p>
 * When parameters are too long to be passed through URLs (because exceeding <code>URLMAXLENGTH</code>), 
 * the query string is saved on disk for a later use. This mechanism is used, rather than 
 * just putting parameters in session, so that parameters are indefinitely stored, 
 * and can be retrieved through an ID at any time.
 * <p>
 * The idea is: if, through a form, a user submit parameters that can be put in URL, 
 * then so be it. But if the user submit, for instance, a list of thousands of Ensembl gene IDs, 
 * that cannot be passed through URLs because of URLs length limitation, 
 * these parameters will be stored on disk: 
 * the query string will be stored in a file, 
 * an ID will be generated to be used as an index to retrieve the file, 
 * and this ID will be passed in URL, 
 * so that the parameters can be retrieved indefinitely. 
 * <p>
 * There are two "big" categories of parameters: "storable" parameters, 
 * that are potentially linked to large data submission, 
 * and "non-storable" parameters, that should never be responsible of large data submission, 
 * and that are meaningful in the URL.
 * Only storable parameters are used to generate IDs, to be stored, and to be retrieved 
 * using the ID provided in the URL. 
 * The properties {@link URLParameter#isStorable} tells whether the parameter is storable or not.
 * 
 * 
 * @author Mathieu Seppey
 * @author Frederic Bastian
 * @version Bgee 13, Jul 2014
 * @since Bgee 1
 */

public class RequestParameters {

	private final static Logger log = LogManager.getLogger(RequestParameters.class.getName());

	/**
	 * Define max length of URLs. Typically, if the URL exceeds the max length, 
	 * a key is generated to store and retrieve a query string, 
	 * holding the "storable" parameters. The "storable" parameters are removed from the URL, 
	 * and replaced by the generated key.
	 * <p>
	 * The max length of URL is currently 2,083 characters, 
	 * because of limitations of IE9. Just to be sure, 
	 * because of potential server limitations, the limit should be 1,500 characters.
	 * <p>
	 * Anyway, we use a much lower limitation, as we do not want too long URL.
	 * 
	 * @see #isUrlTooLong(String)
	 */
	private static final int URLMAXLENGTH = 80;

	/**
	 * A {@code LinkedHashMap<URLParameter<?>, Object} that store the values of parameters as an
	 * {@code Object} using a {URLParameter<T>} instance as key
	 */	
	private LinkedHashMap<URLParameter<?>, Object> values = 
			new LinkedHashMap<URLParameter<?>,Object>();

	/**
	 * This <code>String</code> is a key to retrieve from a file a query string 
	 * holding storable parameters, 
	 * to retrieve parameters that were too large to be passed through URL.
	 * <parameter>
	 * This key can be either retrieved from the current request, or generated 
	 * when this class is asked to generate an URL, and that URL would be too long, 
	 * if the parameters were not stored and replaced by a key.
	 * @see #generateKey()
	 * @see #loadStorableParametersFromKey()
	 * @see #store()
	 */
	private String generatedKey;

	/**
	 * A <code>boolean</code> defining whether parameters should be url encoded 
	 * by the <code>encodeUrl</code> method.
	 * If <code>false</code>, then the <code>encodeUrl</code> method returns 
	 * Strings with no modifications, otherwise, they are url encoded if needed 
	 * (it does not necessarily mean they will. For index, if there are no 
	 * special chars to encode in the submitted String).
	 * <parameter>
	 * Default value is <code>true</code>.
	 * 
	 * @see #urlEncode(String)
	 */
	private boolean encodeUrl = true;

	/**
	 * A {@code String} that defines the character used to separate parameters in the URL
	 */
	private String parametersSeparator = "&";

	/**
	 * A {@code String} that contains the URL corresponding to the present state of the request
	 * It is re-generated every time a parameter is modified
	 */
	private String parametersQuery ;

	/**
	 * <code>ConcurrentMap</code> used to manage concurrent access to 
	 * the read/write locks that are used to manage concurrent reading and writing 
	 * of the files storing query strings holding storable parameters. 
	 * The generated key of the <code>RequestParameters</code> object to be loaded or stored 
	 * is associated to the lock in this <code>Map</code>.
	 * 
	 * @see 	#generatedKey
	 * @see 	#store()
	 * @see 	#loadStorableParametersFromKey()
	 */
	private static ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks= 
			new ConcurrentHashMap<String, ReentrantReadWriteLock>();

	/**
	 * Default constructor. 
	 * @throws 	RequestParametersNotFoundException		if a <code>generatedKey</code> is set in the URL, 
	 * 								meaning that a stored query string should be retrieved using this key, 
	 * 								to populate the storable parameters of this <code>RequestParameters</code> object, 
	 * 								but these parameters could not be found using this key. 
	 * 								See <code>loadStorableParameters(HttpServletRequest)</code> and 
	 * 								<code>generatedKey</code> for more details.
	 * @throws RequestParametersNotStorableException 	if an error occur while trying to use the key 
	 * 													or to write the query string in a file
	 */
	public RequestParameters() throws RequestParametersNotFoundException, 
	RequestParametersNotStorableException{
		// call the constructor with an empty request
		this(new BgeeHttpServletRequest());
	}

	/**
	 * Constructor building a <code>RequestParameters</code> object from a 
	 * <code>HttpServletRequest</code> object.
	 * <parameter>
	 * It means that the parameters are recovered from the query string or posted data.
	 * 
	 * @param 	request 			The HttpServletRequest object corresponding to the current 
	 * 								request to the server.
	 * @throws 	RequestParametersNotFoundException		if a <code>generatedKey</code> is set in the URL, 
	 * 								meaning that a stored query string should be retrieved using this key, 
	 * 								to populate the storable parameters of this <code>RequestParameters</code> object, 
	 * 								but these parameters could not be found using this key. 
	 * 								See <code>loadStorableParameters(HttpServletRequest)</code> and 
	 * 								<code>generatedKey</code> for more details.
	 *@throws RequestParametersNotStorableException 	if an error occur while trying to use the key 
	 * 													or to write the query string in a file
	 */
	public RequestParameters(HttpServletRequest request) throws RequestParametersNotFoundException, 
	RequestParametersNotStorableException
	{
		log.entry(request);

		// Load the parameters
		this.loadParameters(request);

		// Generate the value of the URL for the present state of the request parameters
		this.generateParametersQuery();

		log.exit();

	}

	/**
	 * Load all the parameters related to the request, based on 
	 * the <code>HttpServletRequest</code> object. 
	 * It uses the parameters present in the request or load them from a file.
	 * If the current request includes a key to retrieve a stored query string, 
	 * the corresponding query string is retrieved from a file named as the key, 
	 * If no key is provided, the storable parameters are simply retrieved from the current request.
	 * 
	 * @param 	request 	the <code>HttpServletRequest</code> object 
	 * 						representing the current request to the server.
	 * 
	 * @see 	#loadParametersFromRequest
	 * @see		#loadStorableParametersFromKey
	 */
	private void loadParameters(HttpServletRequest request) throws RequestParametersNotFoundException
	{

		log.entry(request);

		//get the key, if set in the current URL
		this.setGeneratedKey(BgeeStringUtils.secureString(request.getParameter(
				RequestParameters.getGeneratedKeyParameterName())));

		if (BgeeStringUtils.isBlank(this.getGeneratedKey())) {
			log.debug("The key is blank, load params from request");
			//no key set, get the parameters from the URL
			this.loadParametersFromRequest(request,true);
		} else {
			//a key is set, get the storable parameters from a file
			log.debug("The key is set, load params from the file");

			//we need to store the key, 
			//because setting storable parameters reset the generatedKey
			String key = this.getGeneratedKey();
			try {
				this.loadStorableParametersFromKey();
			} catch (IOException e) {
				throw new RequestParametersNotFoundException(e);
			}
			//we need to set again the key, 
			//because setting storable parameters reset the key
			this.setGeneratedKey(key);

			// load the non storable params
			this.loadParametersFromRequest(request,false);
		}

		log.exit();

	}

	/**
	 * Load the parameters from the <code>HttpServletRequest</code> object 
	 * 
	 * @param 	request							the <code>HttpServletRequest</code> object 
	 * 											representing the current request to the server.
	 * 
	 * @param	loadStorable					a {@Code boolean} that indicates whether the storable 
	 * 											parameters have to be loaded from the request. 
	 * 											For example, if the storable parameters were
	 * 											loaded from the key, this method will be called to load
	 * 											the non-storable parameter only.
	 * @see #loadStorableParametersFromKey
	 * @see #loadParameters
	 */
	private void loadParametersFromRequest(HttpServletRequest request, boolean loadStorable) {

		log.entry(request,loadStorable);

		// Browse all available parameters
		for (URLParameter<?> parameter : URLParameters.getList()){

			// If it is a param that has the desired isStorable status, proceed...
			if(loadStorable || parameter.isStorable() == false){

				// Fetch the string values from the URL
				String[] valuesFromUrl = request.getParameterValues(parameter.getName());

				// If the param is set, initialize an ArrayList to receive the values 
				// and browse them
				if(valuesFromUrl != null){

					ArrayList<Object> parameterValues = new ArrayList<Object>();

					for(String valueFromUrl : valuesFromUrl){

						try{
							// Convert the string values into the appropriate type and add it to
							// the list
							if(parameter.getType() == String.class){

								// In the case of a String, secure it before storing it.
								parameterValues.add(BgeeStringUtils.secureString(valueFromUrl,
										parameter.getMaxSize(),parameter.getFormat()));

							} else if(parameter.getType() == Integer.class){

								parameterValues.add(Integer.valueOf(valueFromUrl));

							} else if(parameter.getType() == Boolean.class){

								parameterValues.add(Boolean.valueOf(valueFromUrl));

							}

						} catch(IllegalArgumentException e){

							log.error("Illegal value or character for the parameter {} : {}",
									parameter.getName(),valueFromUrl);

							// If something bad happened with the value, just return null
							parameterValues = null;

						}

						// If the param does not allow multiple value, force the exit from the loop
						// Additional values will be skipped without any warning to the user
						if(parameter.allowsMultipleValues() == false){
							break;
						}

					}

					// store the list of values in the HashMap using the parameter itself as a key
					log.debug("Set {} as values for the param {}",parameterValues,parameter);
					this.values.put(parameter,parameterValues);

				}	

			}

		}

		log.exit();

	}

	/**
	 * Load the storable parameters from the file corresponding to the provided key.
	 * <parameter>
	 * If a key is provided, but no stored query string is found corresponding to this key, 
	 * a RequestParametersNotFoundException is thrown.
	 *
	 * @throw 	IOException
	 * 
	 * @see #loadParameters
	 * @see #loadParametersFromRequest
	 */
	private void loadStorableParametersFromKey() throws IOException 
	{

		log.entry();

		final String key = this.getGeneratedKey();

		ReentrantReadWriteLock lock = this.getReadWriteLock(key);
		try {
			lock.readLock().lock();

			while (readWriteLocks.get(key) == null ||  
					!readWriteLocks.get(key).equals(lock)) {

				lock = this.getReadWriteLock(key);
				lock.readLock().lock();
			}

			BufferedReader br = new BufferedReader(new FileReader(
					BgeeProperties.getRequestParametersStorageDirectory() + key));

			String retrievedQueryString;
			//just one line in the file, a query string including storable parameters, 
			//that will be used to recover storable parameters
			if ((retrievedQueryString = br.readLine()) != null) {


				//here we create a fake HttpServletRequest using the query string we retrieved.
				//this way we do not duplicate code to load parameters into this RequestParameters object.

				BgeeHttpServletRequest request = new BgeeHttpServletRequest(retrievedQueryString);
				this.loadParametersFromRequest(request,true);
			}
			br.close();

		} finally {
			lock.readLock().unlock();
			this.removeLockIfPossible(key);
		}

		log.exit();

	}

	/**
	 * Store the part of the query string holding storable parameters into a file: 
	 * get the part of the query string containing "storable" parameters 
	 * (by calling <code>getCompleteStorableParametersQueryString()</code>), 
	 * generate a key based on that string, and store the string in a file named as the key.
	 * <parameter>
	 * This allows to store parameters too lengthy to be put in URL, to replace these parameters 
	 * by the <code>generatedKey</code>, and to store these parameters to retrieve them at later pages 
	 * using that key.
	 * 
	 * @throws RequestParametersNotStorableException 	if an error occur while trying to use the key 
	 * 													or to write the query string in a file
	 * @see #generateParametersQuery()
	 * @see #generatedKey
	 */
	private void store() throws RequestParametersNotStorableException
	{

		log.entry();

		if (BgeeStringUtils.isBlank(this.getGeneratedKey())) {
			throw new RequestParametersNotStorableException("No key generated before storing a "
					+ "RequestParameters object");
		}

		//first check whether these parameters have already been serialized
		File storageFile = new File(BgeeProperties.getRequestParametersStorageDirectory() 
				+ this.getGeneratedKey());
		if (storageFile.exists()) {
			//file already exists, no need to continue
			return;
		}

		ReentrantReadWriteLock lock = this.getReadWriteLock(this.getGeneratedKey());
		BufferedWriter bufferedWriter = null;
		try {


			lock.writeLock().lock();

			while (readWriteLocks.get(this.getGeneratedKey()) == null ||  
					!readWriteLocks.get(this.getGeneratedKey()).equals(lock)) {

				lock = this.getReadWriteLock(this.getGeneratedKey());
				lock.writeLock().lock();
			}

			bufferedWriter = new BufferedWriter(
					new FileWriter(BgeeProperties.getRequestParametersStorageDirectory() 
							+ this.getGeneratedKey()));

			boolean encodeUrlValue = this.encodeUrl;
			this.encodeUrl = false;
			bufferedWriter.write(generateParametersQuery(true,false,false));
			this.encodeUrl = encodeUrlValue;


			bufferedWriter.close();
		} catch (IOException e) {
			//delete the file if something went wrong
			storageFile = new File(BgeeProperties.getRequestParametersStorageDirectory() 
					+ this.getGeneratedKey());
			if (storageFile.exists()) {
				storageFile.delete();
			}
			throw new RequestParametersNotStorableException(e.getMessage(), e);
		} finally {
			lock.writeLock().unlock();
			this.removeLockIfPossible(this.getGeneratedKey());
		}

		log.exit();
	}

	/**
	 * Try to remove the <code>ReentrantReadWriteLock</code> corresponding to the param <code>key</code>, 
	 * from the <code>ConcurrentHashMap</code> <code>readWriteLocks</code>.
	 * The lock will be removed from the map only if there are no read or write locks, 
	 * and no ongoing request for a read or write lock.
	 * <p>
	 * Note: there might be here a race, where another thread acquired the lock and 
	 * actually locked it, i) just after this method tests the presence of read or write locks 
	 * and ongoing requests for a read or write lock, 
	 * and ii) just before removing it from the map.
	 * To solve this issue, methods acquiring a lock must check after locking it 
	 * whether it is still in the readWriteLocks map, 
	 * or whether the element present in the map for the key is equal to the acquired lock. 
	 * If it is not, they must generate a new lock to be used.
	 * 
	 * @param key 	a <code>String</code> corresponding to the key to retrieve the lock from 
	 * 				<code>readWriteLocks</code>, 
	 * 				to remove it. This key is generated by the method <code>generateKey</code>
	 * @see 		#generateKey()
	 * @see 		#readWriteLocks
	 */
	private void removeLockIfPossible(String key)
	{

		log.entry(key);

		//check if there is already a lock stored for this key
		ReentrantReadWriteLock lock = readWriteLocks.get(key);

		//there is a lock to remove
		if (lock != null) {
			//there is no thread with write lock, or read lock, or waiting to acquire a lock
			if (!lock.isWriteLocked() && lock.getReadLockCount() == 0 && !lock.hasQueuedThreads()) {
				readWriteLocks.remove(key);
			}
		}

		log.exit();
	}

	/**
	 * Obtain a <code>ReentrantReadWriteLock</code>, for the param <code>key</code>.
	 * 
	 * This method tries to obtain <code>ReentrantReadWriteLock</code> corresponding to the key, 
	 * from the <code>ConcurrentHashMap</code> <code>readWriteLocks</code>. 
	 * If the lock is not already stored, 
	 * create a new one, and put it in <code>readWriteLocks</code>, to be used by other threads.
	 * 
	 * @param key 				a <code>String</code> corresponding to the key to retrieve the lock from 
	 * 							<code>readWriteLocks</code>.
	 * 							This key is generated by the method <code>generateKey</code>
	 * @return 					a <code>ReentrantReadWriteLock</code> corresponding to the key.
	 * @see 					#generateKey()
	 * @see 					#readWriteLocks
	 */
	private ReentrantReadWriteLock getReadWriteLock(String key)
	{

		log.entry(key);

		//check if there is already a lock stored for this key
		ReentrantReadWriteLock readWritelock = readWriteLocks.get(key);

		//no lock already stored
		if (readWritelock == null) {
			ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(true);
			//try to put the new lock in the ConcurrentHashMap
			readWritelock = readWriteLocks.putIfAbsent(key, newReadWriteLock);
			//if readWritelock is null, the newLock has been successfully put in the map, and we use it.
			//otherwise, it means that another thread has inserted a new lock for this key in the mean time.
			//readWritelock then corresponds to this value, that we should use.
			if (readWritelock == null) {
				readWritelock = newReadWriteLock;
			}
		}

		return log.exit(readWritelock);
	}

	/**
	 * Generate the query from the current state of the parameters 
	 * @throws RequestParametersNotStorableException if an error occur while trying to use the key 
	 * 													or to write the query string in a file
	 */
	private void generateParametersQuery() throws RequestParametersNotStorableException{

		log.entry();

		if(BgeeStringUtils.isNotBlank(this.getGeneratedKey())){
			this.generateKey(this.generateParametersQuery(true,false,false));
			this.parametersQuery = generateParametersQuery(false,true,true);
		}
		else{
			this.parametersQuery = generateParametersQuery(true,true,false);
			if(this.isUrlTooLong()){
				this.generateKey(this.generateParametersQuery(true,false,false));
				if(BgeeStringUtils.isNotBlank(this.getGeneratedKey())){
					this.store();
					this.generateParametersQuery();
				}
			}	
		}

		log.exit();
	}

	/**
	 * Generate the query from the current state of the parameters and can include or not some 
	 * elements depending on the given params.
	 * @param includeStorable	A {@code boolean} to indicate whether to include the storable parameters
	 * @param includeNonStorable 	A {@code boolean} to indicate whether to include the non-storable 
	 * 								parameters
	 * @param includeKey		A {@code boolean} to indicate whether to include the key
	 * @return
	 */
	private String generateParametersQuery(boolean includeStorable, boolean includeNonStorable, 
			boolean includeKey){

		log.entry(includeStorable,includeNonStorable,includeKey);

		String urlFragment = "";

		// Browse all available parameters
		for (URLParameter<?> parameter : URLParameters.getList()){

			// If it is one of the param to include, proceed...
			if((includeStorable && parameter.isStorable()) || (includeNonStorable 
					&& parameter.isStorable() == false)){

				// Fetch the values of this param and generate a query with all values
				ArrayList<?> parameterValues = this.getValues(parameter);

				if(parameterValues != null && parameterValues.isEmpty() == false){
					for(Object parameterValue : parameterValues){
						if(parameterValue != null && BgeeStringUtils.isNotBlank(
								parameterValue.toString())){
							urlFragment += parameter.getName()+ "=";
							urlFragment += this.urlEncode(parameterValue.toString() 
									+ this.parametersSeparator);
						}
					}
				}
			}

		}

		// If the key has to be included as well and exists, add it
		if(includeKey && BgeeStringUtils.isNotBlank(this.generatedKey)){
			urlFragment += RequestParameters.getGeneratedKeyParameterName() + 
					"=" + this.getGeneratedKey() + this.parametersSeparator;
		}

		// Remove the extra separator at the end 
		if(BgeeStringUtils.isNotBlank(urlFragment)){
			urlFragment = urlFragment.substring(0, urlFragment.length()-1);
		}

		return log.exit(urlFragment) ;

	}

	/** 
	 * Determine whether the submitted <code>String</code>, representing an URL, 
	 * exceeds the URL length restriction. 
	 * See <code>URLMAXLENGTH</code> for more details.
	 * 
	 * @return 		<code>true</code> if the <code>String</code>, representing an URL, 
	 * 				exceeds the max allowed URL length.
	 * 				<code>false</code> otherwise.
	 * @see   		#URLMAXLENGTH
	 */
	private boolean isUrlTooLong()
	{

		log.entry();

		if (this.parametersQuery.length() > URLMAXLENGTH) {
			log.debug("Checking URL length, is too long: {}", this.parametersQuery);
			return log.exit(true);
		}
		log.debug("Checking URL length, is not too long: {}", this.parametersQuery);
		return log.exit(false);
	}

	/**
	 * Generate a key to set the <code>generatedKey</code> attribute, 
	 * based on the param <code>urlFragment</code>, 
	 * in order to store this <code>RequestParameters</code> object.
	 * 
	 * This key is a hash of an URL fragment generated from the storable attributes of this object, 
	 * without any length restriction (all the storable attributes are then represented). 
	 * It will be used as an index to store and retrieve this <code>RequestParameters</code> object.
	 * <parameter>
	 * The key is reset as soon as a storable parameter is modified. A new call to this method will then 
	 * trigger the computation of a new key.
	 * 
	 * @param 	urlFragment 	The fragment of URL based on the storable parameters
	 * @see 	#generatedKey
	 * @see 	#getRequestParametersFromKey()
	 * @see 	#store()
	 */
	private void generateKey(String urlFragment) 
	{

		log.entry(urlFragment);

		log.info("Trying to generate a key based on urlFragment: {}", 
				urlFragment);

		if (BgeeStringUtils.isNotBlank(urlFragment)) {
			this.setGeneratedKey(DigestUtils.sha1Hex(urlFragment.toLowerCase(Locale.ENGLISH)));
		}

		log.info("Key generated: {}", this.getGeneratedKey());

		log.exit();
	}

	/**
	 * Encode String to be used in URLs. 
	 * <parameter>
	 * This method is different from the <code>encodeURL</code> method 
	 * of <code>HttpServletResponse</code>, as it does not incude a logic 
	 * for session tracking. It just converts special chars to be used in URL.
	 * <parameter>
	 * The encoding can be desactivated by setting the <code>encodeUrl</code> attribute to <code>false</code>.
	 * 
	 * @param string 	the <code>String</code> to be encoded.
	 * @return 			a <code>String</code> encoded, if needed (meaning, if including special chars), 
	 * 					and if the <code>encodeUrl</code> attribute is <code>true</code>
	 * 
	 * @see #encodeUrl
	 */
	private String urlEncode(String url){

		log.entry(url);

		if(this.encodeUrl){
			return BgeeStringUtils.urlEncode(url);
		}
		return log.exit(url);
	}

	/**
	 * Performs security checks before assigning the <code>String</code>.
	 * 
	 * @param 	generatedKey the generatedKey to set
	 * @see 	#generatedKey
	 * @see 	#secureString(String)
	 */
	private void setGeneratedKey(String generatedKey) {
		this.generatedKey = BgeeStringUtils.secureString(generatedKey);
	}

	/**
	 * @return 	the generatedKey
	 * @see 	#generatedKey
	 */
	private String getGeneratedKey() {
		return this.generatedKey;
	}

	/**
	 * Get the name of the parameter used in the query string of URLs, 
	 * corresponding to the <code>generatedKey</code> attribute. 
	 * (for index, ?data=blablabla)
	 * 
	 * @return 	a <code>String</code> corresponding to the name of the parameter 
	 * 			for the <code>generatedKey</code> attribute.
	 * @see 	#generatedKey
	 */
	private static String getGeneratedKeyParameterName()
	{
		return "data";
	}

	/**
	 * @return A String that contains the URL corresponding to the present state of the request. 
	 * It is re-generated every time a parameter is modified and has to be got again.
	 */
	public String getParametersQuery(){
		return this.parametersQuery;
	}

	/**
	 * Return all the values for the given {@code URLParameter<T>} in an {@code ArrayList<T>}
	 * @param parameter the {@code URLParameter<T>} that corresponds to the values to be returned
	 * @return an {@code ArrayList<T>} of values
	 */
	@SuppressWarnings("unchecked") // Because the data type of URLParameter is always checked 
	// when the value is stored, it should be safe.
	public <T> ArrayList<T> getValues(URLParameter<T> parameter){
		return (ArrayList<T>) this.values.get(parameter);
	}

	/**
	 * Return the first value of the given {@code URLParameter<T>}
	 * @param parameter the {@code URLParameter<T>} that corresponds to the value to be returned
	 * @return a {@code T}, the value
	 */
	public <T> T getValue(URLParameter<T> parameter){
		return (T) this.getValue(parameter,0);
	}	

	/**
	 * Return the value of the given {@code URLParameter<T>} for the given index
	 * If the index is wrong, will return the first entry
	 * @param parameter the {@code URLParameter<T>} that corresponds to the value to be returned
	 * @param index an {@code int} that is the index of the desired value
	 * @return a {@code T}, the value
	 */
	@SuppressWarnings("unchecked")	// Because the data type of URLParameter is always checked 
	// when the value is stored, it should be safe.
	public <T> T getValue(URLParameter<T> parameter,int index){

		log.entry(parameter,index);

		try{
			return log.exit(((ArrayList<T>) this.values.get(parameter)).get(index));
		}
		catch(IndexOutOfBoundsException e){
			return log.exit(((ArrayList<T>) this.values.get(parameter)).get(0));			

		}
		catch(NullPointerException e){
			return log.exit(null);			
		}



	}

	/**
	 * Set the value for the given {@code URLParameter<T>}
	 * It will replace any first entry for this parameter
	 * @param parameter The {@code URLParameter<T>} to set the value for
	 * @param value	A {@code T}, the value to set
	 * @throws RequestParametersNotStorableException 
	 */
	public <T> void setValue(URLParameter<T> parameter,T value) throws RequestParametersNotStorableException{
		this.setValue(parameter, value, 0);
	}

	/**
	 * Set the value for the given {@code URLParameter<T>} at the given index
	 * It will replace any entry for this parameter at this position. If the parameter does not
	 * allow multiple values, the first entry will be replaced.
	 * @param parameter The {@code URLParameter<T>} to set the value for
	 * @param value	A {@code T}, the value to set
	 * @param index An {@code int} that tells which entry of the param has to be set, i.e 
	 * 0 for the first values, 1 for the second, etc.
	 * @throws RequestParametersNotStorableException 
	 */	
	@SuppressWarnings("unchecked") // Because the data type of the value has to match <T>, thus the
	// data type declared for the URLParameter<T>, it is (should be)
	// in fact safe.
	public <T> void setValue(URLParameter<T> parameter,T value, int index) throws 
	RequestParametersNotStorableException{

		log.entry(parameter,value,index);

		// if the param does not allow multiple values, use the index 0
		if(parameter.allowsMultipleValues() == false ){
			index = 0;
		}

		// Secure the String, if it is a String
		if(parameter.getType() == String.class){
			value = (T) BgeeStringUtils.secureString(
					value.toString(), parameter.getMaxSize(), parameter.getFormat());
		}

		// fetch the existing values for the given parameter and try to set it
		ArrayList<T> parameterValues = (ArrayList<T>) this.values.get(parameter);

		try{
			parameterValues.set(index, value);
		}
		// If nullpointer, it means that there were no previous values at all, create the list
		catch(NullPointerException e){
			parameterValues = new ArrayList<T>();
			parameterValues.add(value);
			this.values.put(parameter,parameterValues);
		}
		// If indexoutofbouf, means that the position does exist, just add the value at the end
		catch(IndexOutOfBoundsException e){
			parameterValues.add(value);
		}


		// regenerate the value of the param url
		this.generateParametersQuery();

		log.exit();

	}

	/**
	 * Add a value for the given {@code URLParameter<T>} 
	 * If the parameter does not allow multiple values and has already a value, 
	 * the entry will be replaced.
	 * @param parameter The {@code URLParameter<T>} to set the value for
	 * @param value	A {@code T}, the value to set
	 * @throws RequestParametersNotStorableException 
	 */	
	@SuppressWarnings("unchecked")
	public <T> void addValue(URLParameter<T> parameter,T value) throws RequestParametersNotStorableException{
		this.setValue(parameter,value,((ArrayList<T>) this.values.get(parameter)).size());
	}

	/**
	 * Reset the value for the given {@code URLParameter<T>} 
	 * @param parameter The {@code URLParameter<T>} to reset
	 * @throws RequestParametersNotStorableException 
	 */
	public <T>  void resetValues(URLParameter<T> parameter) throws RequestParametersNotStorableException{
		log.entry(parameter);
		this.values.put(parameter, null);
		this.generateParametersQuery();
		log.exit();
	}

	/**
	 * Clone this <code>RequestParameters</code> object and return a new one, 
	 * with all parameters copied. 
	 * 
	 * @return 	a new <code>RequestParameters</code> object, 
	 * 			with all parameter copied.
	 * @throws RequestParametersNotStorableException 
	 * @throws RequestParametersNotFoundException 
	 */
	public RequestParameters cloneWithAllParameters() throws RequestParametersNotFoundException, 
	RequestParametersNotStorableException
	{
		
		log.entry();
		
		//to avoid duplicating methods, 
		//we we simulate a HttpServletRequest with parameters corresponding by a query string we provide 
		//holding storable parameters of this object
		String queryString = this.getParametersQuery();
		BgeeHttpServletRequest request = new BgeeHttpServletRequest(queryString);
		RequestParameters clonedRequestParameters = new RequestParameters();

		clonedRequestParameters = new RequestParameters(request);

		//server parameters
		// TODO manage server parameters
		// clonedRequestParameters.loadServerParameters(this);
		//Note: we do not clone httpMethod

		clonedRequestParameters.setGeneratedKey(this.getGeneratedKey());

		return log.exit(clonedRequestParameters);
	}

	/**
	 * Clone this <code>RequestParameters</code> object and return a new one, 
	 * but only with the "storable" parameters and server parameters copied. 
	 * 
	 * @return 	a new <code>RequestParameters</code> object, 
	 * 			with the same this.values for "storable" and server parameters as this one, 
	 * 			but with "non-storable" parameters simply initialized.
	 * @throws RequestParametersNotStorableException 
	 * @throws RequestParametersNotFoundException 
	 */
	public RequestParameters cloneWithStorableParameters() throws RequestParametersNotFoundException, 
	RequestParametersNotStorableException
	{
		
		log.entry();
		
		//to avoid duplicating methods, 
		//we we simulate a HttpServletRequest with parameters corresponding by a query string we provide 
		//holding storable parameters of this object
		String queryString = this.generateParametersQuery(true, false, false);
		BgeeHttpServletRequest request = new BgeeHttpServletRequest(queryString);

		RequestParameters clonedRequestParameters = new RequestParameters();
		//the BgeeHttpServletRequest holds no non-storable parameters 
		//(the query string used to instantiate it contains no non-storable parameters)
		//so calling loadNonStorableParameters here just initialize the non-storable parameters

		clonedRequestParameters = new RequestParameters(request);


		//server parameters
		// TODO manage server parameters
		// clonedRequestParameters.loadServerParameters(this);
		//Note: we do not clone httpMethod

		clonedRequestParameters.setGeneratedKey(this.getGeneratedKey());

		return log.exit(clonedRequestParameters);
	}

}


