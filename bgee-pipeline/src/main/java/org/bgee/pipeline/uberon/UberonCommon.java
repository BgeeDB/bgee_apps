package org.bgee.pipeline.uberon;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.pipeline.ontologycommon.OntologyUtils;
import org.obolibrary.oboformat.parser.OBOFormatConstants.OboFormatTag;
import org.obolibrary.oboformat.parser.OBOFormatParserException;
import org.semanticweb.owlapi.model.OWLAnnotationAssertionAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;
import org.semanticweb.owlapi.model.OWLObject;
import org.semanticweb.owlapi.model.OWLObjectProperty;
import org.semanticweb.owlapi.model.OWLObjectPropertyExpression;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.model.OWLSubClassOfAxiom;
import org.semanticweb.owlapi.util.OWLEntityRemover;

import owltools.graph.OWLGraphEdge;
import owltools.graph.OWLGraphWrapper;

/**
 * Class holding attributes and methods common to {@link Uberon} and {@link UberonDevStage}.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
public abstract class UberonCommon {
    /**
     * {@code Logger} of the class.
     */
    private final static Logger log = LogManager.getLogger(UberonCommon.class.getName());
    
    /**
     * A {@code String} that is the OBO-like ID of the root of the NCBI taxonomy ontology.
     */
    public final static String TAXONOMY_ROOT_ID = "NCBITaxon:1";
    
    /**
     * A {@code String} that is the name of the column containing the anatomical entity IDs 
     * (for instance, "UBERON:0001905") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String UBERON_ENTITY_ID_COL = "Uberon ID";
    /**
     * A {@code String} that is the name of the column containing the anatomical entity names 
     * (for instance, "pineal body") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String ANAT_ENTITY_NAME_COL = "Uberon name";
    /**
     * A {@code String} that is the name of the column containing the is_a/part_of relations 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String RELATIONS_COL = "is_a/part_of relations";
    /**
     * A {@code String} that is the name of the column containing the reason for the removal 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String REASON_FOR_REMOVAL = "Reason for removal";
    /**
     * A {@code String} that is the name of the column containing the IDs of the XRefs 
     * we want a mapping from, to Uberon IDs, in the file generated by 
     * {@link #saveXRefMappingsToFile(String, String)}.
     * 
     * @see #saveXRefMappingsToFile(String, String)
     */
    public static final String XREF_ID_COL = "XRef ID";
    
    /**
     * A {@code String} that is the path to the file storing the Uberon ontology 
     * (recommended version is OWL, but OBO versions can be used as well).
     */
    private String pathToUberonOnt;
    /**
     * A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     * in files (suffixes ".obo" and ".owl" will be automatically added).
     */
    private String modifiedOntPath;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs of {@code OWLClass}es 
     * to remove from the ontology, and to propagate their incoming edges 
     * to their outgoing edges. Argument when calling 
     * {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     */
    private Collection<String> classIdsToRemove;
    /**
     * A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     * Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     * to remove, the associated value being a {@code Set} of {@code String}s 
     * that are the OBO-like ID of the targets of the relations to remove.
     * {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     * for each key with each entry in the associated {@code Set}.
     */
    private Map<String, Set<String>> relsBetweenToRemove;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     * of relations to be filtered and mapped to parent relations. Argument when calling 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     * with second argument {@code true}.
     */
    private Collection<String> relIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs 
     * to be removed from the ontology. Classes part both of a subgraph to remove 
     * and a subgraph not to be removed will be kept. 
     * Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toRemoveSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     * in the ontology. Their ancestors will be kept as well. Argument when calling 
     * {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toFilterSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of subgraphs to ignore. 
     * This is useful for instance for OBO GCI relations: they make use of taxon classes, 
     * so that it is not possible to remove the taxonomy from the ontology; yet, 
     * when inserting anatomy or developmental stages, we do not want to consider them; 
     * the root of the taxonomy would then define a subgraph to ignore.
     */
    private Collection<String> toIgnoreSubgraphRootIds;
    /**
     * A {@code String} that is the path to the file that will store information about 
     * the {@code OWLClass}es that were removed as a result of simplification.
     */
    private String classesRemovedFilePath;
    /**
     * A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     * and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     * in which the {@code OWLClass} exists. 
     */
    private Map<String, Set<Integer>> taxonConstraints;
    /**
     * A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     * of {@code OWLClass}es removed as a result of the simplification process, 
     * the associated values being {@code String}s representing the reason 
     * for the class removal.
     * <p>
     * Note: this could be represented in a better object-oriented way, but we just go 
     * fast and dirty for the pipeline.
     */
    private final Map<String, String> classesRemoved;
    
    /**
     * The {@code OntologyUtils} used to perform operations, wrapping the Uberon ontology 
     * that will be used. 
     */
    private final OntologyUtils ontUtils;
    
    /**
     * Constructor providing the path to the Uberon ontology to used to perforn operations.
     * 
     * @param pathToUberon  A {@code String} that is the path to the Uberon ontology. 
     * @throws OWLOntologyCreationException If an error occurred while loading the ontology.
     * @throws OBOFormatParserException     If the ontology is malformed.
     * @throws IOException                  If the file could not be read. 
     */
    public UberonCommon(String pathToUberon) throws OWLOntologyCreationException, 
    OBOFormatParserException, IOException {
        this(new OntologyUtils(pathToUberon));
    }
    /**
     * Constructor providing the {@code OntologyUtils} used to perform operations, 
     * wrapping the Uberon ontology that will be used, and the {@code MySQLDAOManager} 
     * to interract with the data source. 
     * 
     * @param ontUtils  the {@code OntologyUtils} that will be used. 
     * @throws OWLOntologyCreationException If an error occurred while merging 
     *                                      the import closure of the ontology.
     */
    public UberonCommon(OntologyUtils ontUtils) throws OWLOntologyCreationException {
        this.ontUtils = ontUtils;
        this.ontUtils.getWrapper().mergeImportClosure();
        this.setPathToUberonOnt(ontUtils.getPathToOntology());
        this.classesRemoved = new HashMap<String, String>();
        this.setTaxonConstraints(null);
    }

    
    /**
     * Delegates to {@link #getOWLClasses(String, boolean)} with the {@code boolean} 
     * argument set to {@code true}, and returns either the {@code OWLClass} contained 
     * in the returned {@code Set}, or {@code null} if it is empty. 
     * 
     * @param id    See same name argument in {@link #getOWLClasses(String, boolean)}
     * @return      The {@code OWLClass} retrieved based on {@code id}, or {@code null} 
     *              if none were retrieved.
     * @see #getOWLClasses(String, boolean)
     */
    public OWLClass getOWLClass(String id) {
        log.entry(id);
        
        Set<OWLClass> potentialClasses = this.getOWLClasses(id, true);
        if (potentialClasses.size() == 1) {
            return log.exit(potentialClasses.iterator().next());
        } 
        return log.exit(null);
    }
    
    /**
     * Obtains from the ontology wrapped in this object the {@code OWLClass}es corresponding to 
     * {@code id}. The {@code OWLClass}es will be tried to be identified: first by assuming 
     * {@code id} is an OBO-like ID (using 
     * {@code OWLGraphWrapperExtended.getOWLClassByIdentifier(String)}); then, if not identified, 
     * by assuming it is the {@code String} representation of an {@code IRI} (using 
     * {@code OWLGraphWrapperExtended.getOWLClass(String)}); at this point, if a class 
     * was retrieved, it will be checked whether it is a taxon equivalence to an Uberon class 
     * (using ECAs between the retrieved class and 
     * IntersectionOf(Uberon_class part_of some taxon_class)), in which case 
     * the Uberon class will be returned; then, if the class was not identified, it will 
     * be assumed that {@code id} is an xref (in that case, xref mappings are retrieved calling 
     * {@link #getXRefMappings()}; then, if not identified, by checking whether {@code id} 
     * maps to an obsolete {@code OWLClass}, in which case the "replaced_by" mappings 
     * will be returned (replaced_by mappings are retrieved by calling 
     * {@link #getReplacedByMappings()}). If {@code isStrict} is {@code true}, 
     * then only an {@code OWLClass} uniquely corresponding to an Uberon term or an xref or 
     * a replaced_by annotation will be considered, and if it maps to several 
     * {@code OWLClass}es, they will be discarded. If {@code isStrict} 
     * is {@code false}, then ambiguously mapped {@code OWLClass}es will all be returned. 
     * <p>
     * If an {@code OWLClass} is retrieved by its OBO-like ID or its IRI, then 
     * the returned {@code Set} will contain only one {@code OWLClass}. If {@code isStrict} 
     * is {@code true}, the returned {@code Set} will always contain 
     * either 0 or 1 {@code OWLClass} (this is similar to calling 
     * {@link #getOWLClass(String)}). If {@code isStrict} is {@code false}, 
     * the returned {@code Set} can contain any number of elements. 
     * 
     * @param id    A {@code String} that can be either the OBO-like ID or the {@code IRI} 
     *              of an {@code OWLClass}, or an XRef mapped to some {@code OWLClass}es, 
     *              or the OBO-like ID or {@code IRI} of an obsolete {@code OWLClass}, 
     *              for which to retrieve the {@code OWLClass}es to use as replacement.
     * @param isStrict  A {@code boolean} defining whether only unambiguous xref 
     *                  or replaced_by mappings should be considered. In that case, 
     *                  the returned {@code Set} will contain at most 1 element.
     * @return          A {@code Set} of {@code OWLClass}es that were retrieved 
     *                  from {@code id}.
     * @see #getOWLClass(String)
     */
    public Set<OWLClass> getOWLClasses(String id, boolean isStrict) {
        return this.getOWLClasses(id, isStrict, null);
    }
    
    /**
     * Same as {@link #getOWLClasses(String, boolean)}, with an additional argument 
     * {@code visitedIds}, to protect against infinite cycles when calling this method 
     * recursively. 
     * 
     * @param id            See {@link #getOWLClasses(String, boolean)}
     * @param isStrict      See {@link #getOWLClasses(String, boolean)}
     * @param visitedIds    A {@code Set} of {@code String}s storing IDs already visited 
     *                      when calling this method recursively.
     * @return              See {@link #getOWLClasses(String, boolean)}
     */
    private Set<OWLClass> getOWLClasses(String id, boolean isStrict, Set<String> visitedIds) {
        log.entry(id, isStrict, visitedIds);

        Set<OWLClass> potentialClasses = new HashSet<OWLClass>();
        
        if (visitedIds == null) {
            visitedIds = new HashSet<String>();
        }
        if (visitedIds.contains(id)) {
            return potentialClasses;
        }
        visitedIds.add(id);
        
        OWLGraphWrapper wrapper = this.getOntologyUtils().getWrapper();
        OWLClass cls = wrapper.getOWLClassByIdentifier(id, true);
        //if id was not an OBO-like ID, but an IRI
        if (cls == null) {
            cls = wrapper.getOWLClass(id);
        }
        
        
        if (cls != null) {
            //check that this class is not actually equivalent to the intersection 
            //of an Uberon class in a given taxon, in which case we would return 
            //the Uberon equivalent class
            OWLObjectProperty partOf = wrapper.getOWLObjectPropertyByIdentifier(
                    OntologyUtils.PART_OF_ID);
            OWLClass taxonomyRoot = wrapper.getOWLClassByIdentifier(TAXONOMY_ROOT_ID, true);
            Set<OWLClass> classesMapped = 
                    this.getOntologyUtils().getECAIntersectionOfTargets(cls, partOf, taxonomyRoot);
            if (classesMapped.size() == 1 || !isStrict) {
                potentialClasses.addAll(classesMapped);
            } 
            //if no equivalent class, just consider cls
            if (classesMapped.isEmpty()) {
                potentialClasses.add(cls);
            }
        } else {
            //in case the id provided was actually an xref
            Set<String> classIdsMapped = this.getOntologyUtils().getXRefMappings().get(id);
            if (classIdsMapped != null) {
                Set<OWLClass> classesMapped = new HashSet<OWLClass>();
                for (String idMapped: classIdsMapped) {
                    //recursivity to get the class corresponding to the xref
                    classesMapped.addAll(this.getOWLClasses(idMapped, isStrict, visitedIds));
                }
                if (classesMapped.size() == 1 || !isStrict) {
                    potentialClasses.addAll(classesMapped);
                }
            }
        }
        
        //iterate a copy of potentialClasses to be able to modify it.
        //here, we check for obsolete classes replaced by another class
        for (OWLClass potentialClass: new HashSet<OWLClass>(potentialClasses)) {
            //if the class is obsolete, search for replaced_by annotations
            if (wrapper.isObsolete(potentialClass) || 
                    wrapper.getIsObsolete(potentialClass)) {
                
                potentialClasses.remove(potentialClass);

                //otherwise, we need to use the replaced_by annotations
                Set<String> replacedByIds = this.getOntologyUtils().getReplacedByMappings().get(
                        wrapper.getIdentifier(potentialClass));
                if (replacedByIds != null) {
                    Set<OWLClass> classesMapped = new HashSet<OWLClass>();
                    //we iterate all IDs even if isStrict is true: maybe several replaced_by 
                    //annotations will end up pointing to the same OWLClass
                    for (String idMapped: replacedByIds) {
                        //use recursivity in case the replaced_by annotation is itself pointing 
                        //to an obsolete class or an xref
                        Set<OWLClass> tempClassesMapped = this.getOWLClasses(idMapped, isStrict, 
                                visitedIds);
                        if (tempClassesMapped.isEmpty()) {
                            log.warn("A replaced_by annotation from OWLClass {} did not allow to retrieve an OWLClass: {}", 
                                    id, idMapped);
                        }
                        classesMapped.addAll(tempClassesMapped);
                    }
                    if (classesMapped.size() == 1 || !isStrict) {
                        potentialClasses.addAll(classesMapped);
                    }
                }
            }
        } 
        
        return log.exit(potentialClasses);
    }
    
    /**
     * Convert taxonomy Equivalent Classes Axioms into Xrefs and remove the targeted classes. 
     * Such axioms are {@code OWLEquivalentClassesAxiom}s that define an equivalence 
     * between a taxon-specific {@code OWLClass}, and a generic {@code OWLClass} 
     * in a specified taxon. The are of the form: 
     * {@code EHDAA2:xxx EquivalentTo(UBERON:xxx and part_of some NCBITaxon:xxx)}, 
     * where {@code EHDAA2:xxx} is a taxon-specific class, {@code UBERON:xxx} 
     * is the generic class, and {@code NCBITaxon:xxx} is the specified taxon.
     * <p>
     * Operations performed are: i) a Xref pointing to the taxon-specific {@code OWLClass} 
     * is added to the generic {@code OWLClass}; ii) Edges incoming to and outgoing from 
     * the taxon-specific {@code OWLClass}, only by {@code OWLSubClassOfAxiom}s,
     * are transformed into incoming and outgoing edges applied to the generic {@code OWLClass}, 
     * as GCI relations, to restrict the relations to the specified taxon (except for edges 
     * that were already a GCI, in which case the original taxon is conserved); 
     * iii) the taxon-specific class is removed from the ontologies.
     */
    void convertTaxonECAs() {
        log.entry();
        log.info("Converting taxonomy Equivalent Classes Axioms...");
        
        OWLGraphWrapper wrapper = this.getOntologyUtils().getWrapper();
        OWLObjectProperty partOf = wrapper.getOWLObjectPropertyByIdentifier(
                OntologyUtils.PART_OF_ID);
        OWLClass taxonomyRoot = wrapper.getOWLClassByIdentifier(TAXONOMY_ROOT_ID, true);
        int ecaRemoved = 0;
        
        for (OWLOntology ont: this.getOntologyUtils().getWrapper().getAllOntologies()) {
            OWLDataFactory fac = ont.getOWLOntologyManager().getOWLDataFactory();
            for (OWLClass cls: ont.getClassesInSignature()) {
                log.trace("Examining class {} in ontology {}", cls, ont);
                //if there are taxonomy ECA for this cls, it will be removed
                boolean clsToRemove = false;
                //in that case, we will propagate its incoming edges to the eq. class. 
                //We store the new edges in this Set.
                Set<OWLGraphEdge> newEdges = new HashSet<OWLGraphEdge>();
                //now we retrieve the taxonomy ECAs
                for (OWLEquivalentClassesAxiom eca: 
                    this.getOntologyUtils().getECAIntersectionOf(cls, partOf, taxonomyRoot)) {
                    log.trace("Taxonomy ECA found: {}", eca);
                    clsToRemove = true;
                    ecaRemoved++;
                    //convert the eca into an edge, this is more convenient
                    OWLGraphEdge ecaEdge = 
                            this.getOntologyUtils().convertECAIntersectionOfToEdge(eca, ont);
                    
                    //create the xref 
                    OWLAnnotationAssertionAxiom ax = fac.getOWLAnnotationAssertionAxiom(
                            wrapper.getAnnotationProperty(OboFormatTag.TAG_XREF.getTag()), 
                            ((OWLClass) ecaEdge.getTarget()).getIRI(),  
                            fac.getOWLLiteral(wrapper.getIdentifier(cls)));
                    log.trace("Trying to add Xref: {}", ax);
                    if (!ont.containsAxiomIgnoreAnnotations(ax)) {
                        ont.getOWLOntologyManager().addAxiom(ont, ax);
                        log.trace("Xref added");
                    } else {
                        log.trace("Xref already exists and was not added");
                    }
                    
                    //propagate incoming edges of cls to the equivalent class. 
                    //incoming edges are retrieved from all ontologies at once 
                    //but it does not really matter
                    for (OWLGraphEdge incomingEdge: wrapper.getIncomingEdgesWithGCI(cls)) {
                        OWLGraphEdge newEdge = this.transformEdgeForTaxonEquivalentClass(
                                incomingEdge, incomingEdge.getSource(), ecaEdge.getTarget(), 
                                ecaEdge.getGCIFiller(), ecaEdge.getGCIRelation());
                        if (newEdge != null) {
                            log.trace("Transforming incoming edge {} into new edge {}", 
                                    incomingEdge, newEdge);
                            newEdges.add(newEdge);
                        }
                    }
                    //same thing with outgoing edges, we switch the sources
                    for (OWLGraphEdge outgoingEdge: wrapper.getOutgoingEdgesWithGCI(cls)) {
                        OWLGraphEdge newEdge = this.transformEdgeForTaxonEquivalentClass(
                                outgoingEdge, ecaEdge.getTarget(), outgoingEdge.getTarget(), 
                                ecaEdge.getGCIFiller(), ecaEdge.getGCIRelation());
                        if (newEdge != null) {
                            log.trace("Transforming outgoing edge {} into new edge {}", 
                                    outgoingEdge, newEdge);
                            newEdges.add(newEdge);
                        }
                    }
                }
                //now add the new edges and remove the class 
                if (clsToRemove) {
                    //in order not to try to add several times a similar axiom 
                    Set<OWLSubClassOfAxiom> axiomsAdded = new HashSet<OWLSubClassOfAxiom>();
                    for (OWLGraphEdge newEdge: newEdges) {
                        OWLSubClassOfAxiom newAxiom = 
                                newEdge.getOntology().getOWLOntologyManager().
                                getOWLDataFactory().getOWLSubClassOfAxiom(
                                    (OWLClassExpression) wrapper.edgeToSourceExpression(newEdge), 
                                    (OWLClassExpression) wrapper.edgeToTargetExpression(newEdge));
                        if (!axiomsAdded.contains(newAxiom)) {
                            axiomsAdded.add(newAxiom);
                            //in order to check that the non-GCI equivalent of the edge 
                            //does not already exists
                            OWLGraphEdge nonGCIEdge = new OWLGraphEdge(newEdge.getSource(), 
                                    newEdge.getTarget(), 
                                    newEdge.getQuantifiedPropertyList(), 
                                    newEdge.getOntology(), null, null, null);
                            OWLSubClassOfAxiom nonGCIAxion = 
                                    nonGCIEdge.getOntology().getOWLOntologyManager().
                                    getOWLDataFactory().getOWLSubClassOfAxiom(
                                        (OWLClassExpression) wrapper.edgeToSourceExpression(nonGCIEdge), 
                                        (OWLClassExpression) wrapper.edgeToTargetExpression(nonGCIEdge));
                            if (!newEdge.getOntology().containsAxiomIgnoreAnnotations(newAxiom) && 
                                    !newEdge.getOntology().containsAxiomIgnoreAnnotations(nonGCIAxion)) {
                                log.trace("Adding axiom: {}", newAxiom);
                                newEdge.getOntology().getOWLOntologyManager().addAxiom(
                                        newEdge.getOntology(), newAxiom);
                            }
                        }
                    }
                    //remove class
                    OWLOntologyManager manager = ont.getOWLOntologyManager();
                    OWLEntityRemover remover = new OWLEntityRemover(manager, 
                            wrapper.getAllOntologies());
                    cls.accept(remover);
                    manager.applyChanges(remover.getChanges());
                    log.trace("Class {} removed.", cls);
                    
                    wrapper.clearCachedEdges();
                }
            }
        }

        log.info("Done converting taxonomy Equivalent Classes Axioms, {} ECAs removed.", 
                ecaRemoved);
        log.exit();
    }
    
    /**
     * Transform {@code existingEdge} into a new {@code OWLGraphEdge}. Source and target 
     * of the new edge will respectively be {@code newSource} and {@code newTarget}. 
     * If the method {@code OWLGraphEdge#isGCI()} return {@code false} for {@code existingEdge}, 
     * then {@code equivFiller} and {@code equivProp} will be used to create the new edge, 
     * otherwise, the values returned by the methods {@code OWLGraphEdge#getGCIFiller()} 
     * and {@code OWLGraphEdge#getGCIRelation()} called on {@code existingEdge} will be used. 
     * 
     * @param existingEdge  An {@code OWLGraphEdge} to be used to produce a new one.
     * @param newSource     An {@code OWLObject} that is the source of the new edge.
     * @param newTarget     An {@code OWLObject} that is the target of the new edge.
     * @param equivFiller   An {@code OWLClass} that will be the GCI filler of the new edge 
     *                      if {@code existingEdge} does not represent a GCI relation.
     * @param equivProp     An {@code OWLClass} that will be the GCI property of the new edge 
     *                      if {@code existingEdge} does not represent a GCI relation.
     * @return              An {@code OWLGraphEdge} newly created from {@code existingEdge}.
     */
    private OWLGraphEdge transformEdgeForTaxonEquivalentClass(OWLGraphEdge existingEdge, 
            OWLObject newSource, OWLObject newTarget, 
            OWLClass equivFiller, OWLObjectPropertyExpression equivProp) {
        log.entry(existingEdge, newSource, newTarget, equivFiller, equivProp);
        
        //treat only SubClassOfAxioms
        if (existingEdge.getSubClassOfAxioms().isEmpty()) {
            return log.exit(null);
        }
        //avoid creating a cycle
        if (existingEdge.getTarget().equals(newSource) || 
                existingEdge.getSource().equals(newTarget)) {
            return log.exit(null);
        }
        OWLClass filler = existingEdge.getGCIFiller();
        OWLObjectPropertyExpression prop = existingEdge.getGCIRelation();
        //if the edge is a GCI, we keep its GCI filler and prop.
        //otherwise, we transform the edge into a GCI based on the taxon 
        //in the ECA
        if (!existingEdge.isGCI()) {
            filler = equivFiller;
            prop = equivProp;
        }
        //change the source an target, filler and prop
        return log.exit(new OWLGraphEdge(newSource, newTarget, 
                existingEdge.getQuantifiedPropertyList(), 
                existingEdge.getOntology(), null, 
                filler, prop));
    }
    
    protected void improveGCIRelations() {
        log.entry();
        
        
        
        log.exit();
    }


    /**
     * Determines in which taxa {@code cls} belongs to among the taxa with ID 
     * in {@code taxonIds}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * this method will always return a {@code Set} containing all elements 
     * from {@code taxonIds}. If some taxon constraints have been provided, this method 
     * will return a {@code Set} containing only the IDs of taxa in which {@code cls} 
     * exists, among the IDs in {@code taxonIds}.
     * 
     * @param cls           An {@code OWLClass} for which we want to determine  
     *                      the taxon IDs which it exists in.
     * @param taxonIds      A {@code Collection} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxa for which we want to know if {@code cls} belongs to.
     * @return              A {@code Set} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxa which {@code cls} exists in, among the IDs provided 
     *                      through {@code taxonIds}
     * @see #existsInAtLeastOneSpecies(OWLClass, Collection)
     * @see #existsInAllSpecies(OWLClass, Collection)
     * @see #existsInSpecies(OWLClass, int)
     */
    public Set<Integer> existsInSpecies(OWLClass cls, Collection<Integer> taxonIds) {
        log.entry(cls, taxonIds);
        
        Set<Integer> copiedTaxonIds = new HashSet<Integer>(taxonIds);
        if (this.getTaxonConstraints() == null) {
            return log.exit(copiedTaxonIds);
        }
        
        Set<Integer> validSpecies = this.getTaxonConstraints().get(
                this.getOntologyUtils().getWrapper().getIdentifier(cls));
        if (validSpecies == null || validSpecies.isEmpty()) {
            //exists in no species, return an empty set
            copiedTaxonIds.clear();
        } else {
            copiedTaxonIds.retainAll(validSpecies);
        }
        //A value of 0 means: any species. So we always consider it.
        if (taxonIds.contains(0)) {
            copiedTaxonIds.add(0);
        }
        
        return log.exit(copiedTaxonIds);
    }

    /**
     * Determines whether {@code cls} belongs to the taxon with ID {@code taxonId}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * or {@code taxonId} is equal to 0, this method will always return {@code true}. 
     * If some taxon constraints have been provided, and if {@code taxonId} is different from 0, 
     * then this method will return {@code true} if {@code cls} belongs to the taxon, 
     * {@code false} otherwise (if the taxon does not belong to the set of taxon IDs 
     * associated to the class). 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to the taxon with ID {@code taxonId}.
     * @param taxonId       An {@code int} that is the NCBI ID of the taxon for which 
     *                      we want to know if {@code cls} belongs to.
     * @return              {@code false} if it is shown that {@code cls} doesa not belong to 
     *                      taxon with ID {@code taxonId}, {@code false} otherwise. 
     * @see #existsInAtLeastOneSpecies(OWLClass, Collection)
     * @see #existsInAllSpecies(OWLClass, Collection)
     * @see #existsInSpecies(OWLClass, Collection)
     */
    public boolean existsInSpecies(OWLClass cls, int taxonId) {
        log.entry(cls, taxonId);
        return log.exit(this.existsInSpecies(cls, Arrays.asList(taxonId)).contains(taxonId));
    }
    /**
     * Determines whether {@code cls} belongs to at least one taxon with ID in {@code taxonIds}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * or if {@code taxonIds} contains 0, this method will always return {@code true}. 
     * If some taxon constraints have been provided, and if {@code taxonIds} does not contain 0, 
     * then this method will return {@code true} if {@code cls} belongs to one of the taxa, 
     * {@code false} otherwise. 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to one of the taxa with ID in {@code taxonIds}.
     * @param taxonId       A {@code Collection} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxon for which we want to know if {@code cls} belongs to any.
     * @return              {@code false} if it is shown that {@code cls} does not belong to 
     *                      any taxon with ID in {@code taxonIds}, {@code false} otherwise. 
     * @throw IllegalArgumentException  If {@code taxonIds} is empty, as this method would then 
     *                                  only return {@code false}.
     * @see #existsInSpecies(OWLClass, int)
     * @see #existsInAllSpecies(OWLClass, Collection)
     * @see #existsInSpecies(OWLClass, Collection)
     */
    public boolean existsInAtLeastOneSpecies(OWLClass cls, Collection<Integer> taxonIds) {
        log.entry(cls, taxonIds);
        if (taxonIds.isEmpty()) {
            throw log.throwing(new IllegalArgumentException("The provided Collection of taxon IDs " + 
                               "is empty, this method will always return false"));
        }
        
        //if there is an intersection => valid cls
        return log.exit(!this.existsInSpecies(cls, taxonIds).isEmpty());
    }
    
    /**
     * Determines whether {@code cls} belongs to all taxa with IDs in {@code taxonIds}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * this method will always return {@code true}. 
     * If some taxon constraints have been provided, 
     * then this method will return {@code true} if {@code cls} belongs to all of the taxa, 
     * {@code false} otherwise. 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to all of the taxa with ID in {@code taxonIds}.
     * @param taxonId       A {@code Collection} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxon for which we want to know if {@code cls} belongs to.
     * @return              {@code false} if it is shown that {@code cls} does not belong to 
     *                      all taxa with ID in {@code taxonIds}, {@code false} otherwise. 
     * @throw IllegalArgumentException  If {@code taxonIds} is empty, as this method would then 
     *                                  only return {@code true}.
     * @see #existsInSpecies(OWLClass, int)
     * @see #existsInAtLeastOneSpecies(OWLClass, Collection)
     * @see #existsInSpecies(OWLClass, Collection)
     */
    public boolean existsInAllSpecies(OWLClass cls, Collection<Integer> taxonIds) {
        log.entry(cls, taxonIds);
        if (taxonIds.isEmpty()) {
            throw log.throwing(new IllegalArgumentException("The provided Collection of taxon IDs " + 
                               "is empty, this method will always return true"));
        }
        return log.exit(this.existsInSpecies(cls, taxonIds).equals(
                new HashSet<Integer>(taxonIds)));//make a new HashSet for the equals method
    }

    /**
     * @return  A {@code String} that is the path to the file storing the Uberon ontology 
     *          (recommended version is OWL, but OBO versions can be used as well).
     * @see #setPathToUberonOnt(String)
     */
    public String getPathToUberonOnt() {
        return pathToUberonOnt;
    }
    /**
     * Sets the parameter returned by {@link #getPathToUberonOnt()}.
     * 
     * @param pathToUberonOnt   See {@link #getPathToUberonOnt()}.
     * @see #getPathToUberonOnt()
     */
    public void setPathToUberonOnt(String pathToUberonOnt) {
        this.pathToUberonOnt = pathToUberonOnt;
    }

    /**
     * @return  A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     *          in files (suffixes ".obo" and ".owl" will be automatically added).
     * @see #setModifiedOntPath(String)
     */
    public String getModifiedOntPath() {
        return modifiedOntPath;
    }
    /**
     * Sets the parameter returned by {@link #getModifiedOntPath()}.
     * 
     * @param modifiedOntPath   See {@link #getModifiedOntPath()}.
     * @see #getModifiedOntPath()
     */
    public void setModifiedOntPath(String modifiedOntPath) {
        this.modifiedOntPath = modifiedOntPath;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es to remove from the ontology, and to propagate 
     *          their incoming edges to their outgoing edges. Argument when calling 
     *          {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     * @see #setClassIdsToRemove(Collection)
     */
    public Collection<String> getClassIdsToRemove() {
        return classIdsToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getClassIdsToRemove()}.
     * 
     * @param classIdsToRemove  See {@link #getClassIdsToRemove()}.
     * @see #getClassIdsToRemove()
     */
    public void setClassIdsToRemove(Collection<String> classIdsToRemove) {
        this.classIdsToRemove = classIdsToRemove;
    }

    /**
     * @return  A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     *          Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     *          to remove, the associated value being a {@code Set} of {@code String}s 
     *          that are the OBO-like ID of the targets of the relations to remove.
     *          {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     *          for each key with each entry in the associated {@code Set}.
     * @see #setRelsBetweenToRemove(Map)
     */
    public Map<String, Set<String>> getRelsBetweenToRemove() {
        return relsBetweenToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getRelsBetweenToRemove()}.
     * 
     * @param relsBetweenToRemove   See {@link #getRelsBetweenToRemove()}.
     * @see #getRelsBetweenToRemove()
     */
    public void setRelsBetweenToRemove(Map<String, Set<String>> relsBetweenToRemove) {
        this.relsBetweenToRemove = relsBetweenToRemove;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     *          of relations to be filtered and mapped to parent relations. Argument when calling 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     *          with second argument {@code true}.
     * @see #setRelIds(Collection)
     */
    public Collection<String> getRelIds() {
        return relIds;
    }
    /**
     * Sets the parameter returned by {@link #getRelIds()}.
     * 
     * @param relIds    See {@link #getRelIds()}.
     * @see #getRelIds()
     */
    public void setRelIds(Collection<String> relIds) {
        this.relIds = relIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs 
     *          to be removed from the ontology. Classes part both of a subgraph to remove 
     *          and a subgraph not to be removed will be kept. 
     *          Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToRemoveSubgraphRootIds(Collection)
     */
    public Collection<String> getToRemoveSubgraphRootIds() {
        return toRemoveSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToRemoveSubgraphRootIds()}.
     * 
     * @param toRemoveSubgraphRootIds   See {@link #getToRemoveSubgraphRootIds()}.
     * @see #getToRemoveSubgraphRootIds()
     */
    public void setToRemoveSubgraphRootIds(
            Collection<String> toRemoveSubgraphRootIds) {
        this.toRemoveSubgraphRootIds = toRemoveSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     *          in the ontology. Their ancestors will be kept as well. Argument when calling 
     *          {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToFilterSubgraphRootIds(Collection)
     */
    public Collection<String> getToFilterSubgraphRootIds() {
        return toFilterSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToFilterSubgraphRootIds()}.
     * 
     * @param toFilterSubgraphRootIds   See {@link #getToFilterSubgraphRootIds()}.
     * @see #getToFilterSubgraphRootIds()
     */
    public void setToFilterSubgraphRootIds(
            Collection<String> toFilterSubgraphRootIds) {
        this.toFilterSubgraphRootIds = toFilterSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of subgraphs to ignore. 
     *          This is useful for instance for OBO GCI relations: they make use of taxon classes, 
     *          so that it is not possible to remove the taxonomy from the ontology; yet, 
     *          when inserting anatomy or developmental stages, we do not want to consider them; 
     *          the root of the taxonomy would then define a subgraph to ignore.
     * @see #setToIgnoreSubgraphRootIds(Collection)
     */
    public Collection<String> getToIgnoreSubgraphRootIds() {
        return toIgnoreSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToIgnoreSubgraphRootIds()}.
     * 
     * @param toIgnoreSubgraphRootIds   See {@link #getToIgnoreSubgraphRootIds()}.
     * @see #getToIgnoreSubgraphRootIds()
     */
    public void setToIgnoreSubgraphRootIds( Collection<String> toIgnoreSubgraphRootIds) {
        this.toIgnoreSubgraphRootIds = toIgnoreSubgraphRootIds;
    }
    
    /**
     * @return  A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     *          and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     *          in which the {@code OWLClass} exists. 
     */
    public Map<String, Set<Integer>> getTaxonConstraints() {
        return taxonConstraints;
    }
    /**
     * Set taxon constraints.
     * 
     * @param taxonConstraints  A {@code Map} where keys are OBO-like IDs of the Uberon 
     *                          {@code OWLClass}es, and values are {@code Set}s of 
     *                          {@code Integer}s containing the IDs of taxa 
     *                          in which the {@code OWLClass} exists. 
     */
    public void setTaxonConstraints(Map<String, Set<Integer>> taxonConstraints) {
        this.taxonConstraints = taxonConstraints;
    }
    
    /**
     * @return  A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es removed as a result of the simplification process, 
     *          the associated values being {@code String}s representing the reason 
     *          for the class removal.
     */
    public Map<String, String> getClassesRemoved() {
        return this.classesRemoved;
    }
    /**
     * @return  A {@code String} that is the path to the file that will store information about 
     *          the {@code OWLClass}es that were removed as a result of simplification.
     * @see #setClassesRemovedFilePath(String)
     */
    public String getClassesRemovedFilePath() {
        return classesRemovedFilePath;
    }
    /**
     * Sets the parameter returned by {@link #getClassesRemovedFilePath()}.
     * 
     * @param classesRemovedFilePath    See {@link #getClassesRemovedFilePath()}.
     * @see #getClassesRemovedFilePath()
     */
    public void setClassesRemovedFilePath(String classesRemovedFilePath) {
        this.classesRemovedFilePath = classesRemovedFilePath;
    }
    
    /**
     * @return  The {@code OntologyUtils} used by this object. 
     */
    public OntologyUtils getOntologyUtils() {
        return this.ontUtils;
    }
}
