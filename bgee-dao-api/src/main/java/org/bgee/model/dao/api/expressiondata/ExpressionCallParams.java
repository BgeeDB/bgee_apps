package org.bgee.model.dao.api.expressiondata;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.model.dao.api.expressiondata.CallTO.DataState;

/**
 * This class allows to provide the parameters specific to expression calls, 
 * when using a {@link DAO}, to params the expression calls used during queries. 
 * It allows to define conditions on the data types and data qualities of 
 * the expression calls to use, and to define whether they should have been 
 * generated by taking into account anatomical entities/developmental stages, 
 * and all of their descendants by <em>is_a</em> and <em>part_of</em> relations 
 * (expression taking into account substructures/sub-stages), or without taking 
 * into account substructures/sub-stages.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
public class ExpressionCallParams extends CallParams {
    /**
     * {@code Logger} of the class. 
     */
    private final static Logger log = 
            LogManager.getLogger(ExpressionCallParams.class.getName());
    
    /**
     * Default constructor.
     */
    public ExpressionCallParams() {
        super(new ExpressionCallTO());
    }
    
    @Override
    protected ExpressionCallTO getReferenceCallTO() {
        return (ExpressionCallTO) super.getReferenceCallTO();
    }
    
    //****************************************
    // MERGE METHODS
    //****************************************
    
    /**
     * @see #canMerge(CallParams, boolean)
     */
    @Override
    public ExpressionCallParams merge(CallParams paramsToMerge) {
        log.entry(paramsToMerge);
        //first, determine whether we can merge the CallParams
        if (!this.canMerge(paramsToMerge)) {
            return log.exit(null);
        }

        //OK, let's proceed to the merging
        //we blindly perform the merging here, even if if meaningless, it is the 
        //responsibility of the method canMerge to determine whether it is appropriate.
        ExpressionCallParams otherParams = (ExpressionCallParams) paramsToMerge;
        ExpressionCallParams mergedParams = new ExpressionCallParams();
        //of note, data types and qualities are merged by super.merge method
        super.merge(otherParams, mergedParams);
        //here, we take care of the merging of the attributes specific to 
        //ExpressionCallParams (except the data types and qualities, managed by 
        //the parent class)
        mergedParams.setIncludeSubstructures(
                (this.isIncludeSubstructures() || otherParams.isIncludeSubstructures()));
        mergedParams.setIncludeSubStages(
                (this.isIncludeSubStages() || otherParams.isIncludeSubStages()));

        return log.exit(mergedParams);
    }

    /**
     * Determines whether this {@code ExpressionCallParams} and 
     * {@code paramsToMerge} can be merged. 
     * 
     * @param paramsToMerge A {@code CallParams} that is tried to be merged 
     *                      with this {@code ExpressionCallParams}.
     * @return              {@code true} if they could be merged. 
     */
    @Override
    protected boolean canMerge(CallParams paramsToMerge) {
        log.entry(paramsToMerge);
        
        if (!(paramsToMerge instanceof ExpressionCallParams)) {
            return log.exit(false);
        }
        ExpressionCallParams otherParams = (ExpressionCallParams) paramsToMerge;
        
        //ExpressionCallParams with different expression propagation rules 
        //are not merged, because expression calls using propagation would use 
        //the best data qualities over all sub-structures/sub-stages. As a result, 
        //it would not be possible to retrieve data qualities when no propagation is used, 
        //and so, not possible to check for the data quality conditions held 
        //by an ExpressionCallParams not using propagation.
        //An exception is that, if an ExpressionCallParams not using propagation 
        //was not requesting any specific quality, it could be merged with 
        //an ExpressionCallParams using propagation. But it would be a nightmare to deal 
        //with all these specific cases in other parts of the code, as these calls 
        //would not be flagged "not taking into account substructures" anymore...
        //So, we simply do not merge in that case.
        if (this.isIncludeSubstructures() != otherParams.isIncludeSubstructures() || 
                this.isIncludeSubStages() != otherParams.isIncludeSubStages()) {
            return log.exit(false);
        }
        
        //of note, this method also takes care of the check for data types 
        //and qualities
        if (!super.canMerge(otherParams)) {
            return log.exit(false);
        }
        
        return log.exit(true);
    }

    
    //***********************************************
    // GETTERS/SETTERS DELEGATED TO referenceCallTO
    //***********************************************
    /**
     * Returns the {@code boolean} defining whether the expression calls 
     * used should be based on calls generated using data from anatomical 
     * entities, and all of their descendants by <em>is_a</em> and <em>part_of</em> 
     * relations (expression taking into account substructures), or without taking 
     * into account substructures. 
     * <p>
     * If {@code true}, all the descendants will be considered. Default is {@code false}.
     * 
     * @return  A {@code boolean} defining whether expression in substructures 
     *          of an anatomical entity should be considered.
     */
    public boolean isIncludeSubstructures() {
        return this.getReferenceCallTO().isIncludeSubstructures();
    }
    /**
     * Sets the {@code boolean} defining whether the expression calls 
     * used should be based on calls generated using data from anatomical 
     * entities, and all of their descendants by <em>is_a</em> and <em>part_of</em> 
     * relations (expression taking into account substructures), or without taking 
     * into account substructures. 
     * <p>
     * If {@code true}, all the descendants will be considered. Default is {@code false}.
     * 
     * @param include   A {@code boolean} defining whether expression 
     *                  in substructures of an anatomical entity should be considered.
     */
    public void setIncludeSubstructures(boolean include) {
        this.getReferenceCallTO().setIncludeSubstructures(include);
    }

    /**
     * Returns the {@code boolean} defining whether the expression calls 
     * used should be based on calls generated using data from developmental 
     * stages, and all of their descendants by <em>is_a</em> and <em>part_of</em> 
     * relations (expression taking into account sub-stages), or without taking 
     * into account sub-stages. 
     * <p>
     * If {@code true}, all the sub-stage will be considered. Default is {@code false}.
     * 
     * @return  A {@code boolean} defining whether expression in sub-stages 
     *          of a developmental stage should be considered.
     */
    public boolean isIncludeSubStages() {
        return this.getReferenceCallTO().isIncludeSubStages();
    }
    /**
     * Sets the {@code boolean} defining whether the expression calls 
     * used should be based on calls generated using data from developmental 
     * stages, and all of their descendants by <em>is_a</em> and <em>part_of</em> 
     * relations (expression taking into account sub-stages), or without taking 
     * into account sub-stages. 
     * <p>
     * If {@code true}, all the sub-stage will be considered. Default is {@code false}.
     * 
     * @param include   A {@code boolean} defining whether expression 
     *                  in sub-stages of a developmental stage should be considered.
     */
    public void setIncludeSubStages(boolean include) {
        this.getReferenceCallTO().setIncludeSubStages(include);
    }

    /**
     * @return  the {@code DataState} defining the requested minimum contribution 
     *          of Affymetrix data to the generation of the calls 
     *          to be used.
     */
    public DataState getAffymetrixData() {
        return this.getReferenceCallTO().getAffymetrixData();
    }
    /**
     * @param minContribution   the {@code DataState} defining the requested minimum 
     *                          contribution of Affymetrix data to the generation 
     *                          of the calls to be used.
     */
    public void setAffymetrixData(DataState minContribution) {
        this.getReferenceCallTO().setAffymetrixData(minContribution);
    }

    /**
     * @return  the {@code DataState} defining the requested minimum contribution 
     *          of Affymetrix data to the generation of the calls 
     *          to be used.
     */
    public DataState getESTData() {
        return this.getReferenceCallTO().getESTData();
    }
    /**
     * @param minContribution   the {@code DataState} defining the requested minimum 
     *                          contribution of EST data to the generation 
     *                          of the calls to be used.
     */
    public void setESTData(DataState minContribution) {
        this.getReferenceCallTO().setESTData(minContribution);
    }

    /**
     * @return  the {@code DataState} defining the requested minimum contribution 
     *          of <em>in situ</em> data to the generation of the calls 
     *          to be used.
     */
    public DataState getInSituData() {
        return this.getReferenceCallTO().getInSituData();
    }
    /**
     * @param minContribution   the {@code DataState} defining the requested minimum 
     *                          contribution of <em>in situ</em> data to the generation 
     *                          of the calls to be used.
     */
    public void setInSituData(DataState minContribution) {
        this.getReferenceCallTO().setInSituData(minContribution);
    }

    /**
     * @return  the {@code DataState} defining the requested minimum contribution 
     *          of RNA-Seq data to the generation of the calls 
     *          to be used.
     */
    public DataState getRNASeqData() {
        return this.getReferenceCallTO().getRNASeqData();
    }
    /**
     * @param minContribution   the {@code DataState} defining the requested minimum 
     *                          contribution of RNA-Seq data to the generation 
     *                          of the calls to be used.
     */
    public void setRNASeqData(DataState minContribution) {
        this.getReferenceCallTO().setRNASeqData(minContribution);
    }
}
