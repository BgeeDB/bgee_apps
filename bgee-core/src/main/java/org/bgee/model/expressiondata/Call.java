package org.bgee.model.expressiondata;

import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.model.expressiondata.DataParameters.CallType;
import org.bgee.model.expressiondata.DataParameters.DataQuality;
import org.bgee.model.expressiondata.DataParameters.DataType;
import org.bgee.model.expressiondata.rawdata.GlobalRawDataHolder;

/**
 * Represent an expression, or no expression, or differential expression call, 
 * being an overall data summary generated by Bgee (for instance, the expression state 
 * of a gene summarized over all Affymetrix chips studying a given organ).
 * <p>
 * A <code>Call</code> can hold the raw data, or count of raw data, used to generate it, 
 * this is why it implements the <code>GlobalRawDataHolder</code> interface. 
 * Internally, it uses a {@link org.bgee.model.expressiondata.rawdata.AnyRawDataHolder 
 * AnyRawDataHolder}, and delegates method calls to it. But it also checks that 
 * the requested raw data are compatible with its <code>CallType</code>, an returns 
 * <code>null</code> if they does not. It is the pattern "use composition over inheritance".
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
public class Call implements GlobalRawDataHolder {
	/**
	 * Log4j2 <code>Logger</code> of the class. 
	 */
	private final static Logger log = LogManager.getLogger(Call.class.getName());
	/**
	 * A <code>CallType</code> defining the type of this <code>Call</code> 
	 * (expression, no expression, ...)
	 */
	private final CallType callType;
	/**
	 * An <code>EnumMap</code> with <code>DataType</code>s as key, 
	 * defining the data types that allowed to generate this <code>Call</code>, 
	 * the associated value being a <code>DataQuality</code>, defining the confidence 
	 * which this <code>Call</code> was generated with, by this data type.
	 */
	private final EnumMap<DataType, DataQuality> dataTypes;
	
	//TODO
	rawdataholder
	
	/**
	 * Default constructor not public. At least a <code>CallType</code> 
	 * should be provided, see {@link #Call(CallType)}.
	 */
	//Default constructor not public on purpose, suppress warning
	@SuppressWarnings("unused")
	private Call() {
		this(CallType.EXPRESSION);
	}

	/**
	 * Instantiate a <code>Call</code> for a type of call 
	 * corresponding to <code>callType</code>.
	 * 
	 * @param callType	The <code>CallType</code> representing the type  
	 * 					of this <code>Call</code>.
	 */
	public Call(CallType callType) {
		log.entry(callType);
		
		this.callType = callType;
		this.dataTypes = new EnumMap<DataType, DataQuality>(DataType.class);

		log.exit();
	}
	
	/**
	 * Get the <code>CallType</code> defining the type of this <code>Call</code>.
	 * 
	 * @return the <code>CallType</code> defining the type of this <code>Call</code>.
	 */
	public CallType getCallType() {
		return this.callType;
	}
	
	/**
	 * Return the data types and qualities use to generate this <code>Call</code>, 
	 * as an unmodifiable <code>Map</code>. Keys are <code>DataType</code>s, 
	 * defining the data types that allowed to generate this <code>Call</code>, 
	 * the associated value being a <code>DataQuality</code>, defining the confidence 
	 * which this <code>Call</code> was generated with, by this data type.
	 * 
	 * @return 	The <code>Map</code> of <code>DataType</code>s associated to 
	 * 			a <code>DataQuality</code>, that allowed to generate this <code>Call</code>.
	 * @see #getDataTypes()
	 */
	public Map<DataType, DataQuality> getDataTypesQualities() {
		return Collections.unmodifiableMap(this.dataTypes);
	}
	/**
	 * Return an unmodifiable <code>set</code> of <code>DataType</code>s, being 
	 * defining the data types that allowed to generate this <code>Call</code>. 
	 * The <code>DataType</code>s are returned without their associated 
	 * <code>DataQuality</code>, see {@link #getDataTypesWithQualities()} to get them. 
	 * 
	 * @return 	A <code>Set</code> containing the <code>DataType</code>s 
	 * 			that allowed to generate this <code>Call</code>.
	 * @see #getDataTypesWithQualities()
	 */
	public Set<DataType> getDataTypes() {
		return Collections.unmodifiableSet(this.getDataTypesQualities().keySet());
	}
	/**
	 * Add <code>dataType</code> to the list of data types that allowed to generate  
	 * this <code>Call</code>, associated to <code>dataQuality</code>, defining 
	 * the confidence which this <code>Call</code> was generated with, by this data type.
	 * <p>
	 * If this <code>DataType</code> was already set, replace the previous 
	 * <code>DataQuality</code> value set.
	 * 
	 * @param dataType 		A <code>DataType</code> that allowed to generate  
	 * 						this <code>Call</code>.
	 * @param dataQuality	A <code>dataQuality</code>, defining the confidence 
	 * 						which this <code>Call</code> was generated with.
	 * @throws IllegalArgumentException If the <code>CallType</code> of this <code>Call</code> 
	 * 									(returned by {@link #getCallType()}), 
	 * 									and the <code>DataType</code> added are not compatible, 
	 * 									see {@link DataParameters#checkCallTypeDataType(
	 * 									CallType, DataType)}
	 * @see #addDataTypes(Collection, DataQuality)
	 */
	public void addDataType(DataType dataType, DataQuality dataQuality) 
	    throws IllegalArgumentException
	{
		log.entry(dataType, dataQuality);
		DataParameters.checkCallTypeDataType(this.getCallType(), dataType);
		this.dataTypes.put(dataType, dataQuality);
		log.exit();
	}
	/**
	 * Add <code>dataTypes</code> to the list of data types that allowed to generate  
	 * this <code>Call</code>, associated to <code>dataQuality</code>, defining 
	 * the confidence which this <code>Call</code> was generated with, by these data types.
	 * <p>
	 * If one of these <code>DataType</code>s was already set, replace the previous 
	 * <code>DataQuality</code> value set.
	 * 
	 * @param dataTypes 	A <code>Collection</code> of <code>DataType</code>s that allowed 
	 * 						to generate  this <code>Call</code>.
	 * @param dataQuality	A <code>DataQuality</code>, defining the confidence 
	 * 						which this <code>Call</code> was generated with.
	 * @throws IllegalArgumentException If the <code>CallType</code> of this <code>Call</code> 
	 * 									(returned by {@link #getCallType()}), 
	 * 									and the <code>DataType</code> added are not compatible, 
	 * 									see {@link DataParameters#checkCallTypeDataType(
	 * 									CallType, DataType)}
	 * @see #addDataType(DataType, DataQuality)
	 */
	public void addDataTypes(Collection<DataType> dataTypes, DataQuality dataQuality) 
		    throws IllegalArgumentException
	{
		log.entry(dataTypes, dataQuality);
		for (DataType dataType: dataTypes) {
			this.addDataType(dataType, dataQuality);
		}
		log.exit();
	}
}
