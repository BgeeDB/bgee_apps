package org.bgee.controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.URLParameters.Parameter;
import org.bgee.controller.exception.MultipleValuesNotAllowedException;
import org.bgee.controller.exception.RequestParametersNotFoundException;
import org.bgee.controller.exception.RequestParametersNotStorableException;
import org.bgee.controller.exception.WrongFormatException;
import org.bgee.controller.servletutils.BgeeHttpServletRequest;

/**
 * This class is intended to hold parameters of a query to the server, 
 * and also to generate URLs based on these parameters. 
 * <p>
 * This class can analyze a {@code HttpServletRequest} to extract 
 * and secure relevant parameters of a query to the server. 
 * It is also able to generate URLs based on these parameters, 
 * so that all links generated by the View are constructed by this class.
 * <p>
 * The parameters are represented by the class {@link URLParameters.Parameter}
 * and accessible through the class
 * {@link URLParameters} that provides individual access to each
 * {@code URLParameters.Parameter} or a
 * {@code List} that contains all existing {@code URLParameters.Parameter}.
 * These parameters are used by the present class as key to store their values in a 
 * {@code HashMap} 
 * <p>
 * When parameters are too long to be passed through URLs (because exceeding 
 * {@link BgeeProperties#getUrlMaxLength}, 
 * the query string is saved on disk for a later use. This mechanism is used,
 * rather than just putting parameters in session, so that parameters are 
 * indefinitely stored, and can be retrieved through an ID at any time.
 * <p>
 * The idea is: if, through a form, a user submit parameters that can be put in URL, 
 * then so be it. But if the user submit, for instance, a list of thousands of 
 * Ensembl gene IDs, that cannot be passed through URLs because of URLs length
 * limitation, these parameters will be stored on disk: 
 * the query string will be stored in a file, 
 * an ID will be generated to be used as an index to retrieve the file, 
 * and this ID will be passed in URL, 
 * so that the parameters can be retrieved indefinitely. 
 * <p>
 * There are two "big" categories of parameters: "storable" parameters, 
 * that are potentially linked to large data submission, 
 * and "non-storable" parameters, that should never be responsible of large data 
 * submission, and that are meaningful in the URL.
 * Only storable parameters are used to generate IDs, to be stored, and to be 
 * retrieved using the ID provided in the URL. 
 * The properties {@link URLParameters.Parameter#isStorable} tells whether 
 * the parameter is storable or not.
 * 
 * This class has a js counterpart called {@code requestparameters.js} that should be kept 
 * consistent as much as possible if the class evolves.
 * 
 * @author Mathieu Seppey
 * @author Frederic Bastian
 * @author Valentine Rech de Laval
 * @version Bgee 13, Nov 2014
 * @since Bgee 1
 */
public class RequestParameters {

    private final static Logger log = LogManager.getLogger(RequestParameters.class.getName());

    /**
     * {@code ConcurrentMap} used to manage concurrent access to 
     * the read/write locks that are used to manage concurrent reading and writing 
     * of the files storing query strings holding storable parameters. 
     * The generated key of the {@code RequestParameters} object to be 
     * loaded or stored is associated to the lock in this {@code Map}.
     * 
     * @see #store()
     * @see #loadStorableParametersFromKey(String)
     */
    private static final ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks= 
            new ConcurrentHashMap<String, ReentrantReadWriteLock>();
    
    public static final String CHAR_ENCODING = "UTF-8";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOWNLOAD = "download";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOCUMENTATION = "doc";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_ABOUT = "about";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to topAnat is requested.
     */
    public static final String PAGE_TOP_ANAT = "top_anat";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_CALL_FILES = "expr_calls";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_PROC_VALUE_FILES = "proc_values";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_CALL_DOWLOAD_FILES = "call_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_PROC_EXPR_VALUE_DOWLOAD_FILES = "proc_value_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a gene list validation is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_GENE_VALIDATION = "gene_validation";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a species list data is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_SPECIES_DATA = "species_data";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a new job is submitted.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_NEW_JOB = "new_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a tracking job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_TRACKING_JOB = "tracking_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when results of a completed job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_COMPLETED_JOB = "completed_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when from parameters are requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_FORM_DATA = "form_data";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE = "single";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI = "multi";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the OMA HOG part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_OMA = "oma_hog";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR = "single_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_SIMPLE = "single_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species complete expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_COMPLETE = "single_expr_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR = "multi_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_SIMPLE = "multi_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_COMPLETE = "multi_expr_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF = "single_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_SIMPLE = "single_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_COMPLETE = "single_diff_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF = "multi_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_SIMPLE = "multi_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_COMPLETE = "multi_diff_complete";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about how to access to
     * Bgee data is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_HOW_TO_ACCESS = "access";
    
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a XML view.
     */
    public static final String DISPLAY_TYPE_XML = "xml";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a CSV view.
     */
    public static final String DISPLAY_TYPE_CSV = "csv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a TSV view.
     */
    public static final String DISPLAY_TYPE_TSV = "tsv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a JSON view.
     */
    public static final String DISPLAY_TYPE_JSON = "json";
    
    /**
     * A {@code String} that is the separator to use between the search part and hash part 
     * of URLs generated by the method {@link #getRequestURL(String, Collection, boolean)}. 
     * This is used only for pages where the hash is used to read/write parameters 
     * from URL in javascript.
     * <p>
     * This attribute is useful if you wanted, for instance, to have such pages 
     * indexed by google (it should then be changed to '#!').
     * <p>
     * Note that this attribute is not use as hash separator when the hash is actually used 
     * to link to an element with corresponding ID on the page (see {@link setURLHash(String)}).
     */
    public static final String JS_HASH_SEPARATOR = "#";
    
    /**
     * A {@code BgeeProperties} instance to provide all the properties values
     */
    private final BgeeProperties prop ;

    /**
     * A {@code HashMap<URLParameters.Parameter<?>, Object} that store the
     * values of parameters as an {@code Object} using a 
     * {URLParameters.Parameter<T>} instance as key
     */    
    private final HashMap<URLParameters.Parameter<?>, Object> values = 
            new HashMap<URLParameters.Parameter<?>, Object>();
    
    /**
     * A {@code String} that is the 'hash' part of the URL to add 
     * when methods {@code getRequestURL} are called. This is used to actually link 
     * to an element with this ID (the 'classical' use of hash), this must not be used 
     * to store parameter values (the javascript use, allowing js to change an URL 
     * with no redirection). For this latter use, see {@link #getRequestURL(Collection, boolean)} 
     * and {@link #getRequestURL(String, Collection, boolean)}.
     * <p>
     * Of course, the hash is never retrieved from a {@code HttpServletRequest}, 
     * this is not meant to be used by the server. 
     */
    private String urlHash;

    /**
     * A {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * If {@code false}, then the {@code encodeUrl} method returns 
     * Strings with no modifications, otherwise, they are url encoded if needed 
     * (it does not necessarily mean they will. For index, if there are no 
     * special chars to encode in the submitted String).
     * <parameter>
     * 
     * @see #urlEncode(String)
     */
    private boolean encodeUrl ;

    /**
     * A {@code String} defining the character(s) that are used as parameters separator in the
     * URL 
     */
    private String parametersSeparator;

    /**
     * A {@code String} that contains the URL corresponding to the current state
     * of the request parameters
     */
    private String parametersQuery;

    /**
     * An instance of {@code URLParameters} that provides all the
     * {@code URLParameters.Parameter} that can be present in the request. This follows the pattern 
     * of dependency injection.
     * 
     * @see URLParameters
     */
    private final URLParameters urlParametersInstance;

    /**
     * Name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    private final String httpMethod;

    /**
     * 0-arg constructor defining default implementations and values to use to call 
     * {@link #RequestParameters(URLParameters, BgeeProperties, boolean, String)}. It uses 
     * the {@code BgeeProperties} returned by {@link BgeeProperties#getBgeeProperties()}, 
     * the default implementation of {@code URLParameters}, value {@code true} for 
     * {@code encodeUrl}, value "&" for {@code parametersSeparator}.
     */
    public RequestParameters() {
        this(new URLParameters(), BgeeProperties.getBgeeProperties(), true, "&");
    }
    /**
     * Default constructor. 
     * 
     * @param urlParametersInstance     A instance of {@code URLParameters} that 
     *                                  is injected to provide the available parameters
     *                                  list. 
     *                                  
     * @param prop                      An instance of {@code BgeeProperties}  that is injected
     *                                  to provide the all the properties values
     *                                  
     * @param encodeUrl                 A {@code boolean} defining whether parameters should be
     *                                  url encoded.
     * 
     * @param parametersSeparator       A {@code String} defining the character(s) that are
     *                                  used as parameters separator in the URL 
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator)  {
        log.entry(urlParametersInstance,prop,encodeUrl, parametersSeparator);

        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        //to avoid duplicating methods, 
        //here we simulate a HttpServletRequest with an empty query string, 
        //so that all parameters will be initialized empty
        HttpServletRequest request = new BgeeHttpServletRequest();
        this.httpMethod = request.getMethod();
        try {
            this.constructor(request);
        } catch (RequestParametersNotFoundException | MultipleValuesNotAllowedException | 
                WrongFormatException e) {
            //here we do nothing, 
            //because we provide a "blank" HttpServletRequest, so none of the declared exception
            //is expected
            assert false: "Unreachable code reached in default constructor";
        }

        log.exit();
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <parameter>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * 
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     *                              
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values
     *                                                          
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * 
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL                              
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator)
                    throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(request, urlParametersInstance, prop, encodeUrl, parametersSeparator);
        
        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        this.httpMethod = request.getMethod();
        this.urlHash = null;
        this.constructor(request);

        log.exit();
    }

    /**
     * Method that is called by the constructors to allow different handling of exceptions but
     * avoid the duplication of the code within constructors.
     * 
     * @param request   The HttpServletRequest object corresponding to the current 
     *                  request to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     *                                                  
     * @see #RequestParameters(URLParameters, BgeeProperties, boolean, String)
     * @see #RequestParameters(HttpServletRequest, URLParameters, BgeeProperties, boolean, String)
     */
    private void constructor(HttpServletRequest request) throws RequestParametersNotFoundException,
    MultipleValuesNotAllowedException, WrongFormatException{
        log.entry(request);

        this.loadParameters(request);

        log.exit();
    }

    /**
     * Load all the parameters related to the request, based on 
     * the {@code HttpServletRequest} object. 
     * It uses the parameters present in the request or load them from a file.
     * If the current request includes a key to retrieve a stored query string, 
     * the corresponding query string is retrieved from a file named as the key, 
     * If no key is provided, the storable parameters are simply retrieved from
     * the current request.
     * 
     * @param request   the {@code HttpServletRequest} object representing the current request
     *                  to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParametersFromRequest
     * @see #loadStorableParametersFromKey
     */
    private void loadParameters(HttpServletRequest request) 
            throws RequestParametersNotFoundException, 
            MultipleValuesNotAllowedException, WrongFormatException{
        log.entry(request);

        //Get the key
        String key = request.getParameter(this.getKeyParam().getName());
        if (StringUtils.isBlank(key)) {
            log.trace("The key is blank, load params from request");
            //no key set, get the parameters from the URL
            this.loadParametersFromRequest(request, true);
        } else {
            //a key is set, get the storable parameters from a file
            log.trace("The key is set, load params from the file");
            try {
                this.loadStorableParametersFromKey(key);
            } catch (IOException e) {
                // Re throw a custom exception instead
                throw new RequestParametersNotFoundException(e);
            }
            // Store the key as param
            this.addValue(this.getKeyParam(), key);
            // load the non storable params
            this.loadParametersFromRequest(request, false);
        }

        log.exit();
    }

    /**
     * Load the parameters from the {@code HttpServletRequest} object
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param request          the {@code HttpServletRequest} object representing 
     *                         the current request to the server.
     * 
     * @param loadStorable     a {@code boolean} that indicates whether the storable 
     *                         parameters have to be loaded from the request. 
     *                         For example, if the storable parameters were already
     *                         loaded from the key, this method will be called to load
     *                         the non-storable parameter only, i.e. with loadStorable 
     *                         set at {@code false}
     *                         
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadStorableParametersFromKey
     * @see #loadParameters
     */
    private void loadParametersFromRequest(HttpServletRequest request, boolean loadStorable) 
            throws MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(request, loadStorable);

        // Browse all available parameters
        for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){    
            // If it is a param that has the desired isStorable status, proceed...
            if (loadStorable || !parameter.isStorable()){
                // Fetch the string values from the URL
                String[] valuesFromUrl = request.getParameterValues(parameter.getName());
                // If the param is set, initialize an List to receive the values 
                // and browse them
                if(valuesFromUrl != null){
                    if(!parameter.allowsMultipleValues() && !parameter.allowsSeparatedValues()
                            && valuesFromUrl.length > 1){
                        throw(new MultipleValuesNotAllowedException(parameter.getName()));
                    }
                    List<Object> parameterValues = new ArrayList<Object>();
                    for (String valueFromUrl : valuesFromUrl){
                        // Convert the string values into the appropriate type and add it to
                        // the list
                        // First secure the string
                        try {
                            valueFromUrl = this.secureString(valueFromUrl, parameter);
                            List<String> values = new ArrayList<>();
                            if (!parameter.allowsSeparatedValues()) {
                                values.add(valueFromUrl);
                            } else {
                                String splitPattern = "";
                                for (String separator: URLParameters.DEFAULT_SEPARATORS) {
                                    if (!splitPattern.equals("")) {
                                        splitPattern += "|";
                                    }
                                    splitPattern += Pattern.quote(separator);
                                }
                                values.addAll(Arrays.asList(valueFromUrl.split(splitPattern)));
                            }
                            for (String value: values) {
                                if (StringUtils.isBlank(value)) {
                                    continue;
                                }
                                if(parameter.getType().equals(String.class)){
                                    parameterValues.add(value);
                                } else if(parameter.getType().equals(Integer.class)){
                                    parameterValues.add(castToInt(value));
                                } else if(parameter.getType().equals(Boolean.class)){
                                    parameterValues.add(castToBoolean(value));
                                }
                            }
                        } catch (WrongFormatException e) {
                            throw log.throwing(new WrongFormatException(parameter.getName(), e));
                        }
                    }
                    // store the list of values in the HashMap using
                    // the parameter itself as a key
                    log.debug("Set {} as values for the param {}", parameterValues, parameter);
                    //TODO: why doesn't this use addValue method?
                    this.values.put(parameter, parameterValues);
                }
            }
        }

        log.exit();
    }

    /**
     * Load the storable parameters from the file corresponding to the provided key.
     * If a key is provided, but no stored query string is found corresponding to this key, 
     * a IOException is thrown.
     * 
     * @throws IOException                              thrown if a error occurs while trying 
     *                                                  to read the file associated to the key,
     *                                                  containing the query string to be used.
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParameters
     * @see #loadParametersFromRequest
     * 
     */
    private void loadStorableParametersFromKey(String key) throws IOException, 
    MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(key);

        ReentrantReadWriteLock lock = this.getReadWriteLock(key);
        try {
            lock.readLock().lock();

            while (readWriteLocks.get(key) == null ||  
                    !readWriteLocks.get(key).equals(lock)) {
                lock = this.getReadWriteLock(key);
                lock.readLock().lock();
            }
            try (BufferedReader br = new BufferedReader(new FileReader(
                    prop.getRequestParametersStorageDirectory() + key))) {
                String retrievedQueryString;
                //just one line in the file, a query string including storable parameters, 
                //that will be used to recover storable parameters
                if ((retrievedQueryString = br.readLine()) != null) {
                    //here we create a fake HttpServletRequest using the query 
                    // string we retrieved.
                    //this way we do not duplicate code to load parameters into 
                    // this RequestParameters object.
                    HttpServletRequest request = new BgeeHttpServletRequest(
                            retrievedQueryString, CHAR_ENCODING);
                    this.loadParametersFromRequest(request, true);
                }
            }

        } finally {
            lock.readLock().unlock();
            this.removeLockIfPossible(key);
        }

        log.exit();

    }

    /**
     * Store the part of the query string holding storable parameters into a file: 
     * get the part of the query string containing "storable" parameters 
     * generate a key based on that string, and store the string in a file named as the key.
     * This allows to store parameters too lengthy to be put in URL, to replace these parameters 
     * by the key, which is stored in the {@code URLParameters.Parameter} DATA 
     * and to store these parameters to retrieve them at later pages 
     * using that key.
     * 
     * @throws RequestParametersNotStorableException    if an error occur while trying to use
     *                                                  the key or to write the query string in
     *                                                  a file
     * @see #generateParametersQuery(String)
     * @see URLParameters#getParamData
     */
    private void store() throws RequestParametersNotStorableException {
        log.entry();

        if (StringUtils.isBlank(this.getFirstValue(
                this.getKeyParam()))) {
            throw new RequestParametersNotStorableException("No key generated before storing a "
                    + "RequestParameters object");
        }
        //first check whether these parameters have already been serialized
        File storageFile = new File(prop.getRequestParametersStorageDirectory() 
                + this.getFirstValue(this.getKeyParam()));
        if (storageFile.exists()) {
            //file already exists, no need to continue
            return;
        }
        ReentrantReadWriteLock lock = this.getReadWriteLock(this.getFirstValue(
                this.getKeyParam()));
        try {
            lock.writeLock().lock();
            while (readWriteLocks.get(this.getDataKey()) == null ||  
                    !readWriteLocks.get(this.getDataKey()).equals(lock)) {
                lock = this.getReadWriteLock(this.getDataKey());
                lock.writeLock().lock();
            }
            try (BufferedWriter bufferedWriter = new BufferedWriter(
                    new FileWriter(prop.getRequestParametersStorageDirectory() 
                            + this.getFirstValue(this.getKeyParam())))) {
                // we cannot store an URL-decoded query string to store encoding independent values, 
                // for cases where, e.g., a parameter value include a character such as '&': 
                // we couldn't distinguish it anymore from real parameter separators.
                bufferedWriter.write(generateParametersQuery(null, true, false, "&", null, false));
            }
        } catch (IOException e) {
            //delete the file if something went wrong
            storageFile = new File(prop.getRequestParametersStorageDirectory() 
                    + this.getFirstValue(this.getKeyParam()));
            if (storageFile.exists()) {
                storageFile.delete();
            }
            throw new RequestParametersNotStorableException(e.getMessage(), e);
        } finally {
            lock.writeLock().unlock();
            this.removeLockIfPossible(this.getFirstValue(
                    this.getKeyParam()));
        }

        log.exit();
    }

    /**
     * Try to remove the {@code ReentrantReadWriteLock} corresponding to 
     * the argument {@code key}, from the {@code ConcurrentHashMap} 
     * {@link #readWriteLocks}.
     * The lock will be removed from the map only if there are no read or write locks, 
     * and no ongoing request for a read or write lock.
     * <p>
     * Note: there might be here a race, where another thread acquired the lock and 
     * actually locked it, i) just after this method tests the presence of read or write locks 
     * and ongoing requests for a read or write lock, 
     * and ii) just before removing it from the map.
     * To solve this issue, methods acquiring a lock must check after locking it 
     * whether it is still in the readWriteLocks map, 
     * or whether the element present in the map for the key is equal to the acquired lock. 
     * If it is not, they must generate a new lock to be used.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}, to remove it. This key is generated by the method
     *              {@code generateKey}
     * @see         #generateKey(String)
     * @see         #readWriteLocks
     */
    private void removeLockIfPossible(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock lock = readWriteLocks.get(key);
        //there is a lock to remove
        if (lock != null) {
            //there is no thread with write lock, or read lock, or waiting to acquire a lock
            if (!lock.isWriteLocked() && lock.getReadLockCount() == 0 && !lock.hasQueuedThreads()) {
                readWriteLocks.remove(key);
            }
        }

        log.exit();
    }

    /**
     * Obtain a {@code ReentrantReadWriteLock}, for the param {@code key}.
     * 
     * This method tries to obtain {@code ReentrantReadWriteLock} corresponding to the key, 
     * from the {@code ConcurrentHashMap} {@code readWriteLocks}. 
     * If the lock is not already stored, 
     * create a new one, and put it in {@code readWriteLocks}, to be used by other threads.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}. This key is generated by the method {@code generateKey}
     * @return  a {@code ReentrantReadWriteLock} corresponding to the key.
     * @see #generateKey(String)
     * @see #readWriteLocks
     */
    private ReentrantReadWriteLock getReadWriteLock(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock readWritelock = readWriteLocks.get(key);

        //no lock already stored
        if (readWritelock == null) {
            ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(true);
            //try to put the new lock in the ConcurrentHashMap
            readWritelock = readWriteLocks.putIfAbsent(key, newReadWriteLock);
            //if readWritelock is null, the newLock has been successfully put in the map, and we use it.
            //otherwise, it means that another thread has inserted a new lock for this key in the mean time.
            //readWritelock then corresponds to this value, that we should use.
            if (readWritelock == null) {
                readWritelock = newReadWriteLock;
            }
        }

        return log.exit(readWritelock);
    }

    /**
     * Generate the search and hash parts of URLs. This method takes care 
     * of checking whether the generated URL is too long, and if it is, 
     * of launching the generation of the key needed to store the storable parameters, 
     * the storage on server, and to re-generate the query URL accordingly.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL. 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     */
    private void generateParametersQuery(String parametersSeparator,
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams) 
                    throws RequestParametersNotStorableException {
        log.entry(parametersSeparator, searchOrHashParams, areSearchParams);

        // If there is a key already present, continue to work with a key
        if(StringUtils.isNotBlank(this.getDataKey())){
            // Regenerate the key in case a storable param has changed
            // Always use & as separator to generate the key, so the key is the same for 
            // the same parameters, no matter the separator provided.
            // Also, never use searchOrHashParams provided, so that all the parameters are always 
            // in the search part of the URL to generate the key.
            this.generateKey(this.generateParametersQuery(null, true, false,"&", null, false));
            // Regenerate the parameters query, with the non storable that include
            // the key parameter
            this.parametersQuery = generateParametersQuery(null, false, true,parametersSeparator, 
                    searchOrHashParams, areSearchParams);
        } else{
            // No key for the moment, generate the query and then evaluate if its
            // length is still under the threshold at which the key is used
            this.parametersQuery = generateParametersQuery(null, true, true,parametersSeparator, 
                    searchOrHashParams, areSearchParams);
            if(this.isUrlTooLong()){
                // Generate the key, store the values and regenerate the query
                // Always use & as separator to generate the key, so the key is the same for 
                // the same parameters, no matter the separator provided. 
                // Also, never use searchOrHashParams provided, so that all the parameters 
                // are always in the search part of the URL to generate the key.
                this.generateKey(this.generateParametersQuery(null, true, false,"&", null, false));
                if(StringUtils.isNotBlank(this.getDataKey())){
                    this.store();
                    this.generateParametersQuery(parametersSeparator, 
                            searchOrHashParams, areSearchParams);
                }
            }    
        }

        log.exit();
    }

    /**
     * Generate the query from the current state of the parameters, providing the separator 
     * to use between parameters, and {@code boolean}s defining whether storable and/or 
     * non-storable parameters should be included. This method does not take care 
     * of generating a key if the URL is too long, to store the parameters on server 
     * if needed, etc. This is responsibility of the method 
     * {@link #generateParametersQuery(String, Set, boolean)}. This method simply generates 
     * the URL from the parameters. 
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * <p>
     * This method has a js counterpart in {@code requestparameters.js}, called getRequestURL(),
     * that should be kept consistent as much as possible if the method evolves.
     * 
     * @param targetedParams        A {@code Set} of {@code Parameter}s, allowing which parameters 
     *                              to use to produce the query string. If {@code null} or empty, 
     *                              then all parameters are used. 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL.
     * @param includeStorable       A {@code boolean} to indicate whether to include
     *                              the storable parameters.
     * @param includeNonStorable    A {@code boolean} to indicate whether to include
     *                              the non-storable parameters.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that is the generated query
     */
    private String generateParametersQuery(Set<URLParameters.Parameter<?>> targetedParams, 
            boolean includeStorable, boolean includeNonStorable, String parametersSeparator, 
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams){

        log.entry(targetedParams, includeStorable, includeNonStorable, parametersSeparator, 
                searchOrHashParams, areSearchParams);

        String urlFragment = "";

        // Browse all available parameters. 
        // We will potentially do it twice, to store the parameters either in the search part, 
        //or the hash part of the URL, depending on searchOrHashParams and areSearchParams.
        boolean hashDone = false;
        boolean searchDone = false;
        while (!searchDone || !hashDone) {
            log.trace("Adding parameters for the part: search part ({})/hash part ({})", 
                    !searchDone, searchDone && !hashDone);
            if (searchOrHashParams == null) {
                //no need for a second pass if no param needed in hash
                log.trace("Storing all parameters in search part.");
                hashDone = true;
            }
            boolean paramAdded = false;
            boolean firstParam = true;
            for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){
                if (targetedParams != null && !targetedParams.isEmpty() && !targetedParams.contains(parameter)) {
                    log.trace("Skipping parameter because not targeted: {}", parameter);
                    continue;
                }
                //if a split between parameters in search and hash parts has been requested 
                if (searchOrHashParams != null) {
                    //first pass, store parameters in the search part of the URL
                    if (!searchDone) {
                        if (areSearchParams && !searchOrHashParams.contains(parameter) || 
                            !areSearchParams && searchOrHashParams.contains(parameter)) {
                            //parameter requested in hash, skip
                            continue;
                        }
                        log.trace("Parameter added to search part: {}", parameter);
                    } else {
                        //second pass, store parameters in the hash part of the URL
                        assert searchDone && !hashDone;
                        if (areSearchParams && searchOrHashParams.contains(parameter) || 
                            !areSearchParams && !searchOrHashParams.contains(parameter)) {
                            //parameter requested in search part, skip
                            continue;
                        }
                        log.trace("Parameter added to hash part: {}", parameter);
                        //if this is the first parameter stored in the hash, 
                        // we add the hash separator.
                        if (firstParam) {
                            urlFragment += JS_HASH_SEPARATOR;
                        }
                        firstParam = false;
                    }
                }
                // If it is one of the param to include, proceed...
                if((includeStorable && parameter.isStorable()) || (includeNonStorable 
                        && !parameter.isStorable())){
                    // Fetch the values of this param and generate a query with all
                    // its values
                    List<?> parameterValues = this.getValues(parameter);
                    if(parameterValues != null && !parameterValues.isEmpty()){
                        log.trace("Retrieving values for Parameter {}: {}", parameter, parameterValues);
                        List<?> valuesToUse = parameterValues;
                        
                        //If the parameter can hold several values provided as a single String 
                        //(e.g., list of IDs separated by a line return in a textarea), 
                        //we need to regenerate a single String from the multiple values
                        if (parameter.allowsSeparatedValues()) {
                            String separatedValues = parameterValues.stream()
                                    .filter(v -> StringUtils.isNotBlank(v.toString()))
                                    .map(Object::toString)
                                    .collect(Collectors.joining(parameter.getSeparators().get(0)));
                            valuesToUse = Arrays.asList(separatedValues);
                        } 
                        
                        for(Object parameterValue : valuesToUse){
                            log.trace("Trying to add to URL value {}", parameterValue);
                            if(parameterValue != null && StringUtils.isNotBlank(parameterValue.toString())) {
                                log.trace("Value added");
                                urlFragment += parameter.getName()+ "=";
                                urlFragment += this.urlEncode(parameterValue.toString());
                                urlFragment += parametersSeparator;
                                paramAdded = true;
                            }
                        }
                    }
                }
            }

            // Remove the extra separator at the end 
            if(paramAdded){
                int paramSeparatorLength = parametersSeparator.length();
                urlFragment = urlFragment.substring(0, urlFragment.length()-paramSeparatorLength);
            }
            
            //if searchDone is true, the first pass was already done, 
            //this was the end of the second pass.
            if (searchDone) {
                hashDone = true;
            }
            //will be set to true at the end of the first pass.
            searchDone = true;
            log.trace("URL fragment at the end of the pass: {}", urlFragment);
        }

        return log.exit(urlFragment);
    }

    /** 
     * Determine whether the submitted {@code String}, representing an URL, 
     * exceeds the URL length restriction. 
     * See {@code BgeeProperties#getUrlMaxLength} for more details.
     * 
     * @return  {@code true} if the {@code String}, representing an URL, exceeds the max allowed
     *          URL length. {@code false} otherwise.
     *          
     * @see BgeeProperties#getUrlMaxLength
     */
    private boolean isUrlTooLong() {

        log.entry();
        if (log.isTraceEnabled()) {
            log.trace("length of query: {} - max URL length: {}", 
                    this.parametersQuery.length(), prop.getUrlMaxLength());
        }
        if (this.parametersQuery.length() > prop.getUrlMaxLength()) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Generate a key to set the parameter {@code URLParameters.getParamData}, 
     * based on {@code urlFragment}, 
     * in order to keep the storable parameters of this  {@code RequestParameters} object
     * on the disk
     * 
     * This key is a hash of an URL fragment generated from the storable attributes
     * of this object, without any length restriction (all the storable attributes are then
     * represented). 
     * It will be used as an index to store and retrieve the storable part of this
     * {@code RequestParameters} object.
     * <p>
     * A new call to this method will then trigger the computation of a new key.
     * 
     * @param urlFragment   The fragment of URL based on the storable parameters
     *                                                  
     * @see #store()
     */
    private void generateKey(String urlFragment) {
        log.entry(urlFragment);

        log.info("Trying to generate a key based on urlFragment: {}", urlFragment);

        if (StringUtils.isNotBlank(urlFragment)) {
            // Reset the present key and add the new one
            this.resetValues(this.getKeyParam());
            try {
                this.addValue(this.getKeyParam(), 
                        DigestUtils.sha1Hex(urlFragment.toLowerCase(Locale.ENGLISH)));
            } catch (MultipleValuesNotAllowedException | WrongFormatException e) {
                // In this particular case, should never be thrown.
                assert false: "Unreachable code reached in generateKey";
            }
        }

        log.info("Key generated: {}", this.getFirstValue(
                this.getKeyParam()));

        log.exit();
    }

    /**
     * Encode String to be used in URLs. 
     * This method is different from the {@code encodeURL} method 
     * of {@code HttpServletResponse}, as it does not include a logic 
     * for session tracking. It just converts special chars to be used in URL.
     * The encoding can be desactivated by setting the {@code encodeUrl} attribute to
     * {@code false}.
     *  
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param url   the {@code String} to be encoded.
     * @return  a {@code String} encoded, if needed (meaning, if including special chars), 
     *          and if the {@code encodeUrl} attribute is {@code true}
     * 
     * @see #encodeUrl
     */
    private String urlEncode(String url){

        log.entry(url);

        String encodeString = url;

        if (!this.encodeUrl) {
            return encodeString;
        }
        try {
            // warning, you need to add an attribut to the connector in server.xml  
            // in order to get the utf-8 encoding working : URIEncoding="UTF-8"
            // See https://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q8
            encodeString = java.net.URLEncoder.encode(url, CHAR_ENCODING);
        } catch (Exception e) {
            log.error("Error while URLencoding", e);
        }
        return log.exit(encodeString);
    }

    /**
     * Decode String that was received through the URL.
     * 
     * @param url   the {@code String} to be decoded.
     * @return  a {@code String} decoded
     * 
     * @see #encodeUrl
     */
    private String urlDecode(String url){

        log.entry(url);
        String decodeString = url;

        try {
            decodeString = java.net.URLDecoder.decode(url, CHAR_ENCODING);
        } catch (Exception e) {
            log.error("Error while URLdecoding", e);
        }
        return log.exit(decodeString);
    }

    /**
     * @return The Parameter<String> that contains the key used to store the storable parameters
     */
    private Parameter<String> getKeyParam(){
        log.entry();
        return log.exit(this.urlParametersInstance.getParamData());
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    public String getRequestURL() throws RequestParametersNotStorableException {
        log.entry();
        return log.exit(this.getRequestURL(this.parametersSeparator));
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator}.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    //TODO : is this method still useful now if we can set the parameter separator ?
    public String getRequestURL(String parametersSeparator) 
            throws RequestParametersNotStorableException {
        log.entry(parametersSeparator);
        return log.exit(this.getRequestURL(parametersSeparator, null, false));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    public String getRequestURL(Collection<URLParameters.Parameter<?>> searchOrHashParams, 
            boolean areSearchParams) throws RequestParametersNotStorableException, 
            IllegalStateException {
        log.entry(searchOrHashParams, areSearchParams);
        return log.exit(this.getRequestURL(this.parametersSeparator, 
                searchOrHashParams, areSearchParams));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator(String)}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    //XXX: This method has a js counterpart in {@code requestparameters.js} that should be kept 
    //consistent as much as possible if the method evolves.
    public String getRequestURL(String parametersSeparator, 
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams) 
            throws RequestParametersNotStorableException, IllegalStateException {
        log.entry(parametersSeparator, searchOrHashParams, areSearchParams);
        this.generateParametersQuery(parametersSeparator, searchOrHashParams, areSearchParams);
        
        String url = "";
        if (StringUtils.isNotBlank(this.prop.getBgeeRootDirectory())) {
            url += this.prop.getBgeeRootDirectory();
        } else {
            log.warn("No root folder for URL set, using '/'");
            url += "/";
        }
        
        if (StringUtils.isNotBlank(this.parametersQuery)) {
            //if the query stores the parameters only in the hash part of the URL, 
            //we do not prepend '?', it will start with the hash separator
            if (!this.parametersQuery.startsWith(JS_HASH_SEPARATOR)) {
                url += "?";
            }
            url += this.parametersQuery;
        }
        //if hash needs to be added (to really link to an element with corresponding ID 
        //on a page, not to provide parameters readable/writable with javascript),
        if (StringUtils.isNotBlank(this.getURLHash())) {
            //check whether the hash is already used to store data parameters. 
            //It is not possible to simply test whether searchOrHashParams is not null, 
            //because it is still possible to store all parameters in search part of URLs 
            //even if searchOrHashParams is not null. So we look for the hash separator 
            //when used for storing data parameters.
            if (this.parametersQuery.contains(JS_HASH_SEPARATOR)) {
                throw log.throwing(new IllegalStateException("It is not possible "
                        + "to store data parameters in the hash part of URLs "
                        + "while also trying to use a classical anchor (you previously called "
                        + "the method setURLHash on this object)."));
            }
            url += "#" + this.getURLHash();
        }
        return log.exit(url);
    }

    /**
     * Return all the values for the given {@code URLParameters.Parameter<T>} 
     * in a {@code List<T>} or null if it is empty.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} that corresponds 
     *                  to the values to be returned
     *                  
     * @return  an {@code List<T>} of values
     */
    public <T> List<T> getValues(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        // Because the data type of URLParameters.Parameter is always checked 
        // when the value is stored, it is safe to not check.
        @SuppressWarnings("unchecked")
        ArrayList<T> values = (ArrayList<T>) this.values.get(parameter);

        try{
            // Return a copy of the list and not the original list
            // As the values contained are only immutable object, such as String
            // Integer, Boolean, Long, there is no need to clone the content
            return log.exit(new ArrayList<T>(values));

        } catch(NullPointerException e){
            return log.exit(null);
        }
    }

    /**
     * Return the first value of the given {@code URLParameters.Parameter<T>} 
     * or null if it is empty
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter the {@code URLParameters.Parameter<T>} 
     *                  that corresponds to the value to be returned
     *                  
     * @return  a {@code T}, the value
     */
    @SuppressWarnings("unchecked")    // Because the data type of URLParameters.Parameter
    // is always checked when the value is stored, it should be safe.
    public <T> T getFirstValue(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        try{
            return log.exit(((List<T>) this.values.get(parameter)).get(0));

        } catch(IndexOutOfBoundsException | NullPointerException e){
            return log.exit(null);            
        }
    }

    /**
     * Add a value to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * 
     * @param value     A {@code T}, the value to set
     * 
     * 
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */    
    @SuppressWarnings("unchecked")
    protected <T> void addValue(URLParameters.Parameter<T> parameter, T value) 
            throws MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(parameter,value);

        if(value == null){
            log.exit(); return;
        }

        // fetch the existing values for the given parameter and try to add the value
        List<T> parameterValues = (List<T>) this.values.get(parameter);
        // Throw an exception if the param does not allow 
        // multiple values and has already one
        if (parameterValues != null && 
                !parameter.allowsMultipleValues() && !parameter.allowsSeparatedValues() && 
                !parameterValues.isEmpty()){
            throw(new MultipleValuesNotAllowedException(parameter.getName()));
        }
        //OK, add value
        if (parameterValues == null) {
            parameterValues = new ArrayList<>();
            this.values.put(parameter, parameterValues);
        }
        parameterValues.add(value);
        
        //now, check that the resulting String to generate the query string still respects 
        //the validation format, max length, etc. We generate the resulting query string 
        //for this parameter only, we pass it to a BgeeHttpServletRequest, to be able 
        //to retrieve solely the value of the parameter through the method getParameterValues
        Arrays.stream(
                new BgeeHttpServletRequest(this.generateParametersQuery(
                        new HashSet<>(Arrays.asList(parameter)), true, true, "&", null, true), 
                        CHAR_ENCODING)
                .getParameterValues(parameter.getName()))
            .forEach(paramValue -> this.secureString(paramValue, parameter));
        
        log.exit();
    }

    /**
     * Add values to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * @param values    A {@code List} of {@code T}s, the values to set
     * @throws MultipleValuesNotAllowedException    If more than one value is present in the
     *                                              {@code request} for a
     *                                              {@link URLParameters.Parameter} that
     *                                              does not allow multiple values.
     * @throws WrongFormatException                 A value in the {@code request} does not
     *                                              fit the format requirement for related
     *                                              {@link URLParameters.Parameter}
     */
    protected <T> void addValues(URLParameters.Parameter<T> parameter, List<T> values)
            throws MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(parameter,values);

        for (T value: values) {
            this.addValue(parameter, value);
        }

        log.exit();
    }

    /**
     * Reset the value for the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to reset
     */
    protected <T>  void resetValues(URLParameters.Parameter<T> parameter) 
    {
        log.entry(parameter);
        this.values.put(parameter, null);
        log.exit();
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * with all parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with all parameter copied.
     *             
     */
    public RequestParameters cloneWithAllParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(true));
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * but only with the "storable" parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with the same values for "storable" as this one, 
     *             but with "non-storable" parameters simply initialized.
     */
    public RequestParameters cloneWithStorableParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(false));
    }

    /**
     * Method that actually proceed to the cloning and is called by 
     * {@link #cloneWithAllParameters()} and {@link #cloneWithStorableParameters()}
     * @param includeNonStorable    A boolean to tell whether to keep the non storable parameters
     * @return     a new {@code RequestParameters} object, with or without the non storable 
     *             parameters depending on {@code includeNonStorable}
     */
    private RequestParameters cloneRequestParameter(boolean includeNonStorable){
        log.entry(includeNonStorable);
        //to avoid duplicating methods, 
        //we we simulate a HttpServletRequest with a query string 
        //we provide holding storable parameters of this object
        String queryString = this.generateParametersQuery(null, true, includeNonStorable, "&", 
                null, false);
        BgeeHttpServletRequest request = new BgeeHttpServletRequest(queryString, CHAR_ENCODING);
        RequestParameters clonedRequestParameters = null;
        try {
            clonedRequestParameters = new RequestParameters(request, 
                    this.urlParametersInstance.getClass().newInstance(),this.prop,
                    this.encodeUrl, this.parametersSeparator);
            if(!includeNonStorable){
                // Add the key which is not a storable parameters and was not included
                clonedRequestParameters.addValue(this.getKeyParam(), 
                        this.getFirstValue(this.getKeyParam()));
            }
            log.trace("Cloned RequestParameters generated: {}", clonedRequestParameters);
        } catch ( RequestParametersNotFoundException
                | MultipleValuesNotAllowedException | WrongFormatException e) {
            // In this particular case, should never be thrown.
            throw log.throwing(new IllegalStateException("Code supposed to be unreachable", e));
        } catch (InstantiationException | IllegalAccessException e) {
            throw log.throwing(new IllegalStateException(e));
        }
        return log.exit(clonedRequestParameters);
    }

    /**
     * @return  An instance of {@code URLParameters} that provides all the
     *          {@code URLParameters.Parameter} that can be present in the request
     */
    public URLParameters getUrlParametersInstance() {
        return urlParametersInstance;
    }

    /**
     * @return  A {@code String } that is the name of the HTTP method with which this request
     *          was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    public String getHttpMethod() {
        return this.httpMethod;
    }

    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code page} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getPage() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPage());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #addValue(Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code page} URL parameter 
     *                  to set.
     */
    public void setPage(String page) {
        this.resetValues(this.getUrlParametersInstance().getParamPage());
        this.addValue(this.getUrlParametersInstance().getParamPage(), page);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code action} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getAction() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamAction());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #addValue(Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code action} URL parameter 
     *                  to set.
     */
    public void setAction(String action) {
        this.resetValues(this.getUrlParametersInstance().getParamAction());
        this.addValue(this.getUrlParametersInstance().getParamAction(), action);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamData()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getDataKey() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamData());
    }
    
    /**
     * @return A {@code String} that will be used as the hash part of URLs returned by 
     *         the  {@code getRequestURL} methods. See {@link #setURLHash(String)} 
     *         for more details.
     * @see #setURLHash(String)
     */
    public String getURLHash() {
        return urlHash;
    }
    /**
     * Set the 'hash' to be added at the end of the URLs generated by the {@code getRequestURL} 
     * methods. This method should be used only to actually link to an element 
     * with the corresponding ID in a page. It should not be used to use the hash 
     * to store data parameters (for instance, to link to pages where the hash part 
     * is used by javascript to read/write data parameters). For this latter use, 
     * see {@link #getRequestURL(Set, boolean)} and {@link #getRequestURL(String, Set, boolean)}.
     * <p>
     * Note that {@code urlHash} must not include the hash separator ('#').
     * 
     * @param urlHash   A {@code String} that will be used as the hash part of URLs returned by 
     *                  the  {@code getRequestURL} methods.
     */
    public void setURLHash(String urlHash) {
        this.urlHash = urlHash;
    }

    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamDisplayType()}. Equivalent to calling 
     * {@link #addValue(Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code display_type} URL parameter 
     *                  to set.
     */
    public void setDisplayType(String displayType) {
        this.resetValues(this.getUrlParametersInstance().getParamDisplayType());
        this.addValue(this.getUrlParametersInstance().getParamDisplayType(), displayType);
    }
    
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamSpeciesList()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code species_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getSpeciesList(){
        return this.getValues(this.getUrlParametersInstance().getParamSpeciesList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamForegroundList()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code fg_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getForegroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamForegroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamForegroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code fg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getForegroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamForegroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundList()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code bg_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getBackgroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamBackgroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code bg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getBackgroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamBackgroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamExprType()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code expr_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getExprType() {
        return this.getValues(this.getUrlParametersInstance().getParamExprType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataQuality()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data_qual} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDataQuality() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDataQuality());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataType()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code data_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getDataType() {
        return this.getValues(this.getUrlParametersInstance().getParamDataType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDevStage()}. Equivalent to calling 
     * {@link #getValues(Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code dev_stage} URL parameter. Can be {@code null}. 
     */
    public List<String> getDevStage() {
        return this.getValues(this.getUrlParametersInstance().getParamDevStage());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamDecorrelationType()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code decorr_type} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDecorrelationType() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDecorrelationType());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNodeSize()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code node_size} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNodeSize() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNodeSize());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNbNode()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code nb_node} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNbNode() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNbNode());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamFdrThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  An {@code Float} that is the value of the {@code fdr_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Float getFdrThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamFdrThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPValueThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  An {@code Float} that is the value of the {@code pvalue_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Float getPValueThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPValueThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamJobId()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code job_id} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getJobId() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamJobId());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamFormData()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code form_data} URL parameter.
     *          Can be {@code null}. 
     */
    public String getFormData() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamFormData());
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Xml or not
     */
    public boolean isXmlDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_XML)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Csv or not
     */
    public boolean isCsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_CSV)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Tsv or not
     */
    public boolean isTsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_TSV)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is JSON or not
     */
    public boolean isJsonDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_JSON)){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Allow to know if this request has been performed through AJAX. 
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if this request was performed through AJAX
     */
    public boolean isAnAjaxRequest() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamAjax()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamAjax())) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the page corresponds to the homepage
     */
    public boolean isTheHomePage(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) == null){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "about"
     */
    public boolean isAnAboutPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_ABOUT)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request is related to topAnat.
     */
    public boolean isATopAnatPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_TOP_ANAT)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "admin"
//     */
//    public boolean isAnAdminPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("admin")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "anatomy"
//     */
//    public boolean isAnAnatomyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) == null || 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("anatomy")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          gene list upload in topAnat.
     */
    public boolean isATopAnatGeneUpload() {
        log.entry();
        if (isATopAnatPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_GENE_VALIDATION)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          species list upload in topAnat.
     */
    public boolean isATopAnatSpeciesUpload() {
        log.entry();
        if (isATopAnatPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_SPECIES_DATA)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a new job in topAnat.
     */
    public boolean isATopAnatNewJob() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getHttpMethod().equals("POST") &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_NEW_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a tracking job in topAnat.
     */
    public boolean isATopAnatTrackingJob() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getHttpMethod().equals("POST") &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_TRACKING_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a completed job in topAnat.
     */
    public boolean isATopAnatCompletedJob() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getHttpMethod().equals("POST") &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_COMPLETED_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          retrieve form data.
     */
    public boolean isATopAnatFormDataUpload() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getHttpMethod().equals("POST") &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_FORM_DATA)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "documentation"
     */
    public boolean isADocumentationPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOCUMENTATION)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "download"
     */
    public boolean isADownloadPageCategory(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOWNLOAD)){
            return log.exit(true);
        }
        return log.exit(false);
    }    

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "expression"
//     */
//    public boolean isAnExpressionPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("expression")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene"
//     */
//    public boolean isAGenePageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene_family"
//     */
//    public boolean isAGeneFamilyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene_family")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "log"
//     */
//    public boolean isALogPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("log")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "news"
//     */
//    public boolean isANewsPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("news")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "registration"
//     */
//    public boolean isARegistrationPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("registration")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "search"
//     */
//    public boolean isASearchPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("search")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * Determine whether the requested page contains sensitive information, 
     * such as passwords.
     * Such pages should then not be cached, or the URL be stored in the database, etc.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if the page contains sensitive information, {@code false} otherwise.
     */
    public boolean isASecuredPage() 
    {
        log.entry();
        //TODO: implement when necessary (logging page, registration page, ...)
        return log.exit(false);
    }

    /**
     * Determine whether the output of the current request can be stored by the web-cache.
     * Some responses should never be cached, following, e.g., a user identification request, 
     * or a HEAD request (would lead to cache a blank page). 
     * At the opposite, we might be interested in caching only some pages 
     * (e.g., computation-intensive pages are always computed following an AJAX request, 
     * in order to display a waiting message; we could then only cache AJAX requests).
     * <p>
     * Also, some cookies should never be put in cache, because specific to a user.
     * so that a cache will never send cookies. ( TODO : Probably no cookies in the future, but
     * developers have to be aware of the problem. Now your are ! )
     * 
     * @return  {@code true} if the response following the current request should be cached
     */
    public boolean isACacheableRequest()
    {
        log.entry();
        // Do not cache pages containing sensitive information
        if (this.isASecuredPage()) {
            return log.exit(false);
        }
        // Do not cache responses to HEAD requests, would lead to cache blank page
        // for security, we only accept POST and GET requests to be cached.
        // @see org.bgee.controller.servletUtils.BgeeWebCache#calculateKey(HttpServletRequest)
        if (!this.getHttpMethod().equalsIgnoreCase("get") && 
                !this.getHttpMethod().equalsIgnoreCase("post")) {
            return log.exit(false);
        }
        //do not cache POST request that are not AJAX requets: 
        //they should never send any response, and redirect the user to another page 
        //to avoid warning messages when pressing the back button.
        if(! this.isAnAjaxRequest() && this.getHttpMethod().equalsIgnoreCase("post")){
            return log.exit(false);
        }
        return log.exit(true);
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use
     * 
     * @param stringToCheck    a {@code String} to be checked 
     * @return a secured and prepared {@code String}. 
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     */
    private String secureString(String stringToCheck) throws WrongFormatException {
        log.entry(stringToCheck);
        return log.exit(secureString(stringToCheck, 0, null));
    }
    /**
     * Perform security controls and prepare the submitted {@code String} for use, 
     * corresponding to the value of the provided parameter.
     * 
     * @param stringToCheck    a {@code String} to be checked. 
     * @param parameter         A {@code Parameter} which {@code stringToCheck} is 
     *                          the associated value, providing the security parameters 
     *                          (see {@link URLParameters.Parameter#getMaxSize()} and 
     *                          {@link URLParameters.Parameter#getFormat()})
     * @return a secured and prepared {@code String}. 
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     */
    private String secureString(String stringToCheck, URLParameters.Parameter<?> parameter) {
        log.entry(stringToCheck, parameter);
        return log.exit(secureString(stringToCheck, parameter.getMaxSize(), parameter.getFormat()));
    }
    /**
     * Perform security controls and prepare the submitted {@code String} for use. It includes
     * a check of the {@code String} length and the format of the {@code String}.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param stringToCheck    a {@code String} to be checked 
     * @param lengthToCheck    an {@code int} defining the max allowed length of 
     *                         {@code stringToCheck}. If {@code stringToCheck} is greater 
     *                         than 0, and if the length of {@code stringToCheck} is greater
     *                         than {@code lengthToCheck}, this method throw a 
     *                         {@code WrongFormatException}. 
     *                         If {@code stringToCheck} is equal to 0, no control are performed 
     *                         on string length (but other modifications are still performed, 
     *                         such as triming the {@code String}). 
     * @param format           A {@code String} that contains the regular expression the 
     *                         {@code String} should match.
     * @return a secured and prepared {@code String}. 
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     *
     *              
     */
    private String secureString(String stringToCheck, int lengthToCheck, String format)
            throws WrongFormatException
    {
        log.entry(stringToCheck, lengthToCheck, format);
        if (stringToCheck == null) {
            return "";
        }
        else if (lengthToCheck != 0 && stringToCheck.length() > lengthToCheck){
            String msg = "The parameter value it is too long (" + stringToCheck.length() + "). ";
            log.error(msg);
            throw log.throwing(new WrongFormatException(msg));
        }
        else if (format != null && stringToCheck.matches(format) == false) {
            log.error("The string {} does not match the format {}", stringToCheck, format);
            //do not provide the accepted format in the exception, we don't need to provide 
            //too much information to potential hackers :p
            throw log.throwing(new WrongFormatException("The parameter value " + stringToCheck 
                    + " has an invalid format. "));
        }
        return log.exit(stringToCheck.trim());
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use, 
     * without checking length of {@code stringToCheck} ({@code MAXSTRINGLENGTH}).
     * 
     * @param stringToCheck
     * @return a secured and prepared {@code String}. Return an empty String if the stringToCheck
     *         was null.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     * @see #secureString(String)
     */
    private String secureStringWithoutLengthCheck(String stringToCheck) throws WrongFormatException
    {
        return secureString(stringToCheck, 0, null);
    }

    /**
     * Transform {@code paramValue} into a {@code boolean}. This {@code String} should first 
     * have been secured (see {@link #secureString(String, int, String)}).
     * 
     * @param paramValue    A {@code String} corresponding to the value of a parameter 
     *                      in a request, to be converted into a {@code boolean}
     * @return  a {@code boolean} corresponding to {@code paramValue}. 
     *          Return {@code true} if {@code paramValue} is equal to "on", "true", or "1".
     */
    private boolean castToBoolean(String paramValue) {
        log.entry(paramValue);

        if (paramValue.equalsIgnoreCase("on") || 
                paramValue.equalsIgnoreCase("true") || 
                paramValue.equalsIgnoreCase("1")) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * Transform {@code paramValue} into an {@code int}. This {@code String} should first 
     * have been secured (see {@link #secureString(String, int, String)}).
     * 
     * @param paramValue    A {@code String} corresponding to the value of a parameter 
     *                      in a request, to be converted into an {@code int}
     * @return  an {@code int} corresponding to {@code paramValue}. 
     *          Return also 0 if {@code paramValue} is {@code null} or blank.
     * @throws WrongFormatException If {@code paramValue} could not be casted to an {@code int}.
     */
    private int castToInt(String paramValue) throws WrongFormatException {
        log.entry(paramValue);

        int castInt = 0;
        if (StringUtils.isNotBlank(paramValue)) {
            try {
                castInt = Integer.parseInt(paramValue);
            } catch(NumberFormatException e) {
                throw log.throwing(new WrongFormatException(
                        "Incorrect integer value: " + paramValue, e));
            }
        }
        return log.exit(castInt);
    }

    /**
     * Change the {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * @param encodeUrl A {@code boolean} defining whether parameters should be url encoded 
     *                  by the {@code encodeUrl} method.
     */
    public void setEncodeUrl(boolean encodeUrl) {
        this.encodeUrl = encodeUrl;
    }

    /**
     * Change the {@code String} defining the character(s) that are used as parameters 
     * separator in the URL   
     * @param parametersSeparator A {@code String} defining the character(s) that are used as 
     * parameters separator in the URL   
     */
    public void setParametersSeparator(String parametersSeparator) {
        this.parametersSeparator = parametersSeparator;
    }
}