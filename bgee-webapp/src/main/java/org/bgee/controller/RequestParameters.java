package org.bgee.controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Locale;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.URLParameters.Parameter;
import org.bgee.controller.exception.MultipleValuesNotAllowedException;
import org.bgee.controller.exception.RequestParametersNotFoundException;
import org.bgee.controller.exception.RequestParametersNotStorableException;
import org.bgee.controller.exception.WrongFormatException;
import org.bgee.controller.servletutils.BgeeHttpServletRequest;

/**
 * This class is intended to hold parameters of a query to the server, 
 * and also to generate URLs based on these parameters. 
 * <p>
 * This class can analyze a {@code HttpServletRequest} to extract 
 * and secure relevant parameters of a query to the server. 
 * It is also able to generate URLs based on these parameters, 
 * so that all links generated by the View are constructed by this class.
 * <p>
 * The parameters are represented by the class {@link URLParameters.Parameter}
 * and accessible through the class
 * {@link URLParameters} that provides individual access to each
 * {@code URLParameters.Parameter} or a
 * {@code List} that contains all existing {@code URLParameters.Parameter}.
 * These parameters are used by the present class as key to store their values in a 
 * {@code HashMap} 
 * <p>
 * When parameters are too long to be passed through URLs (because exceeding 
 * {@link BgeeProperties#getUrlMaxLength}, 
 * the query string is saved on disk for a later use. This mechanism is used,
 * rather than just putting parameters in session, so that parameters are 
 * indefinitely stored, and can be retrieved through an ID at any time.
 * <p>
 * The idea is: if, through a form, a user submit parameters that can be put in URL, 
 * then so be it. But if the user submit, for instance, a list of thousands of 
 * Ensembl gene IDs, that cannot be passed through URLs because of URLs length
 * limitation, these parameters will be stored on disk: 
 * the query string will be stored in a file, 
 * an ID will be generated to be used as an index to retrieve the file, 
 * and this ID will be passed in URL, 
 * so that the parameters can be retrieved indefinitely. 
 * <p>
 * There are two "big" categories of parameters: "storable" parameters, 
 * that are potentially linked to large data submission, 
 * and "non-storable" parameters, that should never be responsible of large data 
 * submission, and that are meaningful in the URL.
 * Only storable parameters are used to generate IDs, to be stored, and to be 
 * retrieved using the ID provided in the URL. 
 * The properties {@link URLParameters.Parameter#isStorable} tells whether 
 * the parameter is storable or not.
 * 
 * This class has a js counterpart called {@code requestparameters.js} that should be kept 
 * consistent as much as possible if the class evolves.
 * 
 * @author Mathieu Seppey
 * @author Frederic Bastian
 * @version Bgee 13, Aug 2014
 * @since Bgee 1
 */
public class RequestParameters {

    private final static Logger log = LogManager.getLogger(RequestParameters.class.getName());

    /**
     * {@code ConcurrentMap} used to manage concurrent access to 
     * the read/write locks that are used to manage concurrent reading and writing 
     * of the files storing query strings holding storable parameters. 
     * The generated key of the {@code RequestParameters} object to be 
     * loaded or stored is associated to the lock in this {@code Map}.
     * 
     * @see #store()
     * @see #loadStorableParametersFromKey(String)
     */
    private static final ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks= 
            new ConcurrentHashMap<String, ReentrantReadWriteLock>();

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOWNLOAD = "download";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOCUMENTATION = "doc";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_ABOUT = "about";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_CALL_FILES = "expr_calls";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing reference gene expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_REF_EXPR_FILES = "ref_expression";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_CALL_DOWLOAD_FILES = "call_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing reference expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_REF_EXPR_DOWLOAD_FILES = "ref_expr_files";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about how to access to
     * Bgee data is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_HOW_TO_ACCESS = "access";
    
    /**
     * A {@code BgeeProperties} instance to provide all the properties values
     */
    private final BgeeProperties prop ;

    /**
     * A {@code HashMap<URLParameters.Parameter<?>, Object} that store the
     * values of parameters as an {@code Object} using a 
     * {URLParameters.Parameter<T>} instance as key
     */    
    private final HashMap<URLParameters.Parameter<?>, Object> values = 
            new HashMap<URLParameters.Parameter<?>, Object>();

    /**
     * A {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * If {@code false}, then the {@code encodeUrl} method returns 
     * Strings with no modifications, otherwise, they are url encoded if needed 
     * (it does not necessarily mean they will. For index, if there are no 
     * special chars to encode in the submitted String).
     * <parameter>
     * 
     * @see #urlEncode(String)
     */
    private boolean encodeUrl ;

    /**
     * A {@code String} defining the character(s) that are used as parameters separator in the
     * URL 
     */
    private String parametersSeparator;

    /**
     * A {@code String} that contains the URL corresponding to the current state
     * of the request parameters
     */
    private String parametersQuery;

    /**
     * An instance of {@code URLParameters} that provides all the
     * {@code URLParameters.Parameter} that can be present in the request. This follows the pattern 
     * of dependency injection.
     * 
     * @see URLParameters
     */
    private final URLParameters urlParametersInstance;

    /**
     * Name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    private final String httpMethod;

    /**
     * Default constructor. 
     * 
     * @param urlParametersInstance     A instance of {@code URLParameters} that 
     *                                  is injected to provide the available parameters
     *                                  list. 
     *                                  
     * @param prop                      An instance of {@code BgeeProperties}  that is injected
     *                                  to provide the all the properties values
     *                                  
     * @param encodeUrl                 A {@code boolean} defining whether parameters should be
     *                                  url encoded.
     * 
     * @param parametersSeparator       A {@code String} defining the character(s) that are
     *                                  used as parameters separator in the URL 
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator)  {
        log.entry(urlParametersInstance,prop,encodeUrl, parametersSeparator);

        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        //to avoid duplicating methods, 
        //here we simulate a HttpServletRequest with an empty query string, 
        //so that all parameters will be initialized empty
        HttpServletRequest request = new BgeeHttpServletRequest();
        this.httpMethod = request.getMethod();
        try {
            this.constructor(request);
        } catch (RequestParametersNotFoundException | MultipleValuesNotAllowedException | 
                WrongFormatException e) {
            //here we do nothing, 
            //because we provide a "blank" HttpServletRequest, so none of the declared exception
            //is expected
            assert false: "Unreachable code reached in default constructor";
        }

        log.exit();
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <parameter>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * 
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     *                              
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values
     *                                                          
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * 
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL                              
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator)
                    throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(request, urlParametersInstance, prop, encodeUrl, parametersSeparator);

        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        this.httpMethod = request.getMethod();
        this.constructor(request);

        log.exit();
    }

    /**
     * Method that is called by the constructors to allow different handling of exceptions but
     * avoid the duplication of the code within constructors.
     * 
     * @param request   The HttpServletRequest object corresponding to the current 
     *                  request to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     *                                                  
     * @see #RequestParameters(URLParameters, BgeeProperties, boolean, String)
     * @see #RequestParameters(HttpServletRequest, URLParameters, BgeeProperties, boolean, String)
     */
    private void constructor(HttpServletRequest request) throws RequestParametersNotFoundException,
    MultipleValuesNotAllowedException, WrongFormatException{
        log.entry(request);

        this.loadParameters(request);

        log.exit();
    }

    /**
     * Load all the parameters related to the request, based on 
     * the {@code HttpServletRequest} object. 
     * It uses the parameters present in the request or load them from a file.
     * If the current request includes a key to retrieve a stored query string, 
     * the corresponding query string is retrieved from a file named as the key, 
     * If no key is provided, the storable parameters are simply retrieved from
     * the current request.
     * 
     * @param request   the {@code HttpServletRequest} object representing the current request
     *                  to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParametersFromRequest
     * @see #loadStorableParametersFromKey
     */
    private void loadParameters(HttpServletRequest request) 
            throws RequestParametersNotFoundException, 
            MultipleValuesNotAllowedException, WrongFormatException{
        log.entry(request);

        //Get the key
        String key = request.getParameter(this.getKeyParam().getName());
        if (StringUtils.isBlank(key)) {
            log.debug("The key is blank, load params from request");
            //no key set, get the parameters from the URL
            this.loadParametersFromRequest(request, true);
        } else {
            //a key is set, get the storable parameters from a file
            log.debug("The key is set, load params from the file");
            try {
                this.loadStorableParametersFromKey(key);
            } catch (IOException e) {
                // Re throw a custom exception instead
                throw new RequestParametersNotFoundException(e);
            }
            // Store the key as param
            this.addValue(this.getKeyParam(), key);
            // load the non storable params
            this.loadParametersFromRequest(request, false);
        }

        log.exit();
    }

    /**
     * Load the parameters from the {@code HttpServletRequest} object
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param request          the {@code HttpServletRequest} object representing 
     *                         the current request to the server.
     * 
     * @param loadStorable     a {@code boolean} that indicates whether the storable 
     *                         parameters have to be loaded from the request. 
     *                         For example, if the storable parameters were already
     *                         loaded from the key, this method will be called to load
     *                         the non-storable parameter only, i.e. with loadStorable 
     *                         set at {@code false}
     *                         
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadStorableParametersFromKey
     * @see #loadParameters
     */
    private void loadParametersFromRequest(HttpServletRequest request, boolean loadStorable) 
            throws MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(request, loadStorable);

        // Browse all available parameters
        for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){    
            // If it is a param that has the desired isStorable status, proceed...
            if (loadStorable || !parameter.isStorable()){
                // Fetch the string values from the URL
                String[] valuesFromUrl = request.getParameterValues(parameter.getName());
                // If the param is set, initialize an List to receive the values 
                // and browse them
                if(valuesFromUrl != null){
                    if(!parameter.allowsMultipleValues() && valuesFromUrl.length > 1){
                        throw(new MultipleValuesNotAllowedException(parameter.getName()));
                    }
                    List<Object> parameterValues = new ArrayList<Object>();
                    for (String valueFromUrl : valuesFromUrl){
                        // Convert the string values into the appropriate type and add it to
                        // the list
                        // First secure the string
                        try {
                            valueFromUrl = this.secureString(valueFromUrl, 
                                    parameter.getMaxSize(), parameter.getFormat());
                        } catch (WrongFormatException e) {
                            throw new WrongFormatException(parameter.getName());
                        }
                        if(parameter.getType().equals(String.class)){
                            parameterValues.add(valueFromUrl);
                        } else if(parameter.getType().equals(Integer.class)){
                            parameterValues.add(Integer.valueOf(valueFromUrl));
                        } else if(parameter.getType().equals(Boolean.class)){
                            parameterValues.add(Boolean.valueOf(valueFromUrl));
                        }
                    }
                    // store the list of values in the HashMap using
                    // the parameter itself as a key
                    log.debug("Set {} as values for the param {}", parameterValues, parameter);
                    //TODO: why doesn't this use addValue method?
                    this.values.put(parameter, parameterValues);
                }
            }
        }

        log.exit();
    }

    /**
     * Load the storable parameters from the file corresponding to the provided key.
     * If a key is provided, but no stored query string is found corresponding to this key, 
     * a IOException is thrown.
     * 
     * @throws IOException                              thrown if a error occurs while trying 
     *                                                  to read the file associated to the key,
     *                                                  containing the query string to be used.
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParameters
     * @see #loadParametersFromRequest
     * 
     */
    private void loadStorableParametersFromKey(String key) throws IOException, 
    MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(key);

        ReentrantReadWriteLock lock = this.getReadWriteLock(key);
        try {
            lock.readLock().lock();

            while (readWriteLocks.get(key) == null ||  
                    !readWriteLocks.get(key).equals(lock)) {
                lock = this.getReadWriteLock(key);
                lock.readLock().lock();
            }
            try (BufferedReader br = new BufferedReader(new FileReader(
                    prop.getRequestParametersStorageDirectory() + key))) {
                String retrievedQueryString;
                //just one line in the file, a query string including storable parameters, 
                //that will be used to recover storable parameters
                if ((retrievedQueryString = br.readLine()) != null) {
                    //here we create a fake HttpServletRequest using the query 
                    // string we retrieved.
                    //this way we do not duplicate code to load parameters into 
                    // this RequestParameters object.
                    HttpServletRequest request = new BgeeHttpServletRequest(
                            retrievedQueryString);
                    this.loadParametersFromRequest(request, true);
                }
            }

        } finally {
            lock.readLock().unlock();
            this.removeLockIfPossible(key);
        }

        log.exit();

    }

    /**
     * Store the part of the query string holding storable parameters into a file: 
     * get the part of the query string containing "storable" parameters 
     * generate a key based on that string, and store the string in a file named as the key.
     * This allows to store parameters too lengthy to be put in URL, to replace these parameters 
     * by the key, which is stored in the {@code URLParameters.Parameter} DATA 
     * and to store these parameters to retrieve them at later pages 
     * using that key.
     * 
     * @throws RequestParametersNotStorableException    if an error occur while trying to use
     *                                                  the key or to write the query string in
     *                                                  a file
     * @see #generateParametersQuery(String)
     * @see URLParameters#getParamData
     */
    private void store() throws RequestParametersNotStorableException {
        log.entry();

        if (StringUtils.isBlank(this.getFirstValue(
                this.getKeyParam()))) {
            throw new RequestParametersNotStorableException("No key generated before storing a "
                    + "RequestParameters object");
        }
        //first check whether these parameters have already been serialized
        File storageFile = new File(prop.getRequestParametersStorageDirectory() 
                + this.getFirstValue(this.getKeyParam()));
        if (storageFile.exists()) {
            //file already exists, no need to continue
            return;
        }
        ReentrantReadWriteLock lock = this.getReadWriteLock(this.getFirstValue(
                this.getKeyParam()));
        try {
            lock.writeLock().lock();
            while (readWriteLocks.get(this.getFirstValue(
                    this.getKeyParam())) == null ||  
                    !readWriteLocks.get(this.getFirstValue(
                            this.getKeyParam())).equals(lock)) {
                lock = this.getReadWriteLock(this.getFirstValue(
                        this.getKeyParam()));
                lock.writeLock().lock();
            }
            try (BufferedWriter bufferedWriter = new BufferedWriter(
                    new FileWriter(prop.getRequestParametersStorageDirectory() 
                            + this.getFirstValue(this.getKeyParam())))) {
                // decode the parameters, so the value written is the real encoding independent
                // value.
                bufferedWriter.write(this.urlDecode(generateParametersQuery(true, false, "&")));
            }
        } catch (IOException e) {
            //delete the file if something went wrong
            storageFile = new File(prop.getRequestParametersStorageDirectory() 
                    + this.getFirstValue(this.getKeyParam()));
            if (storageFile.exists()) {
                storageFile.delete();
            }
            throw new RequestParametersNotStorableException(e.getMessage(), e);
        } finally {
            lock.writeLock().unlock();
            this.removeLockIfPossible(this.getFirstValue(
                    this.getKeyParam()));
        }

        log.exit();
    }

    /**
     * Try to remove the {@code ReentrantReadWriteLock} corresponding to 
     * the argument {@code key}, from the {@code ConcurrentHashMap} 
     * {@link #readWriteLocks}.
     * The lock will be removed from the map only if there are no read or write locks, 
     * and no ongoing request for a read or write lock.
     * <p>
     * Note: there might be here a race, where another thread acquired the lock and 
     * actually locked it, i) just after this method tests the presence of read or write locks 
     * and ongoing requests for a read or write lock, 
     * and ii) just before removing it from the map.
     * To solve this issue, methods acquiring a lock must check after locking it 
     * whether it is still in the readWriteLocks map, 
     * or whether the element present in the map for the key is equal to the acquired lock. 
     * If it is not, they must generate a new lock to be used.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}, to remove it. This key is generated by the method
     *              {@code generateKey}
     * @see         #generateKey(String)
     * @see         #readWriteLocks
     */
    private void removeLockIfPossible(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock lock = readWriteLocks.get(key);
        //there is a lock to remove
        if (lock != null) {
            //there is no thread with write lock, or read lock, or waiting to acquire a lock
            if (!lock.isWriteLocked() && lock.getReadLockCount() == 0 && !lock.hasQueuedThreads()) {
                readWriteLocks.remove(key);
            }
        }

        log.exit();
    }

    /**
     * Obtain a {@code ReentrantReadWriteLock}, for the param {@code key}.
     * 
     * This method tries to obtain {@code ReentrantReadWriteLock} corresponding to the key, 
     * from the {@code ConcurrentHashMap} {@code readWriteLocks}. 
     * If the lock is not already stored, 
     * create a new one, and put it in {@code readWriteLocks}, to be used by other threads.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}. This key is generated by the method {@code generateKey}
     * @return  a {@code ReentrantReadWriteLock} corresponding to the key.
     * @see #generateKey(String)
     * @see #readWriteLocks
     */
    private ReentrantReadWriteLock getReadWriteLock(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock readWritelock = readWriteLocks.get(key);

        //no lock already stored
        if (readWritelock == null) {
            ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(true);
            //try to put the new lock in the ConcurrentHashMap
            readWritelock = readWriteLocks.putIfAbsent(key, newReadWriteLock);
            //if readWritelock is null, the newLock has been successfully put in the map, and we use it.
            //otherwise, it means that another thread has inserted a new lock for this key in the mean time.
            //readWritelock then corresponds to this value, that we should use.
            if (readWritelock == null) {
                readWritelock = newReadWriteLock;
            }
        }

        return log.exit(readWritelock);
    }

    /**
     * Generate the query from the current state of the parameters 
     * 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     */
    private void generateParametersQuery(String parametersSeparator) throws
    RequestParametersNotStorableException 
    {
        log.entry(parametersSeparator);

        // If there is a key already present, continue to work with a key
        if(StringUtils.isNotBlank(this.getFirstValue(
                this.getKeyParam()))){
            // Regenerate the key in case a storable param has changed
            // Always use & as separator to generate the key, so the key is the same for 
            // the same parameters, no matter the separator provided.
            this.generateKey(this.generateParametersQuery(true, false,"&"));
            // Regenerate the parameters query, with the non storable that include
            // the key parameter
            this.parametersQuery = generateParametersQuery(false, true,parametersSeparator);
        } else{
            // No key for the moment, generate the query and then evaluate if its
            // length is still under the threshold at which the key is used
            this.parametersQuery = generateParametersQuery(true, true,parametersSeparator);
            if(this.isUrlTooLong()){
                // Generate the key, store the values and regenerate the query
                // Always use & as separator to generate the key, so the key is the same for 
                // the same parameters, no matter the separator provided
                this.generateKey(this.generateParametersQuery(true, false,"&"));
                if(StringUtils.isNotBlank(this.getFirstValue(
                        this.getKeyParam()))){
                    this.store();
                    this.generateParametersQuery(parametersSeparator);
                }
            }    
        }

        log.exit();
    }

    /**
     * Generate the query from the current state of the parameters and can 
     * include or not some elements depending on the given params.
     * 
     * This method has a js counterpart in {@code requestparameters.js}, called getRequestURL(),
     * that should be kept consistent as much as possible if the method evolves.
     * 
     * @param parametersSeparator   A {@code String} that is used as parameters separator in the URL
     * 
     * @param includeStorable       A {@code boolean} to indicate whether to include
     *                              the storable parameters
     *                              
     * @param includeNonStorable    A {@code boolean} to indicate whether to include
     *                              the non-storable parameters
     *                              
     * @return  A {@code String} that is the generated query
     */
    private String generateParametersQuery(boolean includeStorable, 
            boolean includeNonStorable, String parametersSeparator){

        log.entry(includeStorable, includeNonStorable, parametersSeparator);

        String urlFragment = "";

        // Browse all available parameters
        for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){

            // If it is one of the param to include, proceed...
            if((includeStorable && parameter.isStorable()) || (includeNonStorable 
                    && !parameter.isStorable())){
                // Fetch the values of this param and generate a query with all
                // its values
                List<?> parameterValues = this.getValues(parameter);
                if(parameterValues != null && !parameterValues.isEmpty()){
                    for(Object parameterValue : parameterValues){
                        if(parameterValue != null && StringUtils.isNotBlank(
                                parameterValue.toString())){
                            urlFragment += parameter.getName()+ "=";
                            urlFragment += this.urlEncode(parameterValue.toString()) 
                                    + parametersSeparator;
                        }
                    }
                }
            }
        }

        // Remove the extra separator at the end 
        if(StringUtils.isNotBlank(urlFragment)){
            int paramSeparatorLength = parametersSeparator.length();
            urlFragment = urlFragment.substring(0, urlFragment.length()-paramSeparatorLength);
        }

        return log.exit(urlFragment);
    }

    /** 
     * Determine whether the submitted {@code String}, representing an URL, 
     * exceeds the URL length restriction. 
     * See {@code BgeeProperties#getUrlMaxLength} for more details.
     * 
     * @return  {@code true} if the {@code String}, representing an URL, exceeds the max allowed
     *          URL length. {@code false} otherwise.
     *          
     * @see BgeeProperties#getUrlMaxLength
     */
    private boolean isUrlTooLong() {

        log.entry();

        if (this.parametersQuery.length() > prop.getUrlMaxLength()) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Generate a key to set the parameter {@code URLParameters.getParamData}, 
     * based on {@code urlFragment}, 
     * in order to keep the storable parameters of this  {@code RequestParameters} object
     * on the disk
     * 
     * This key is a hash of an URL fragment generated from the storable attributes
     * of this object, without any length restriction (all the storable attributes are then
     * represented). 
     * It will be used as an index to store and retrieve the storable part of this
     * {@code RequestParameters} object.
     * <p>
     * A new call to this method will then trigger the computation of a new key.
     * 
     * @param urlFragment   The fragment of URL based on the storable parameters
     *                                                  
     * @see #store()
     */
    private void generateKey(String urlFragment) {
        log.entry(urlFragment);

        log.info("Trying to generate a key based on urlFragment: {}", urlFragment);

        if (StringUtils.isNotBlank(urlFragment)) {
            // Reset the present key and add the new one
            this.resetValues(this.getKeyParam());
            try {
                this.addValue(this.getKeyParam(), 
                        DigestUtils.sha1Hex(urlFragment.toLowerCase(Locale.ENGLISH)));
            } catch (MultipleValuesNotAllowedException | WrongFormatException e) {
                // In this particular case, should never be thrown.
                assert false: "Unreachable code reached in generateKey";
            }
        }

        log.info("Key generated: {}", this.getFirstValue(
                this.getKeyParam()));

        log.exit();
    }

    /**
     * Encode String to be used in URLs. 
     * This method is different from the {@code encodeURL} method 
     * of {@code HttpServletResponse}, as it does not include a logic 
     * for session tracking. It just converts special chars to be used in URL.
     * The encoding can be desactivated by setting the {@code encodeUrl} attribute to
     * {@code false}.
     *  
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param url   the {@code String} to be encoded.
     * @return  a {@code String} encoded, if needed (meaning, if including special chars), 
     *          and if the {@code encodeUrl} attribute is {@code true}
     * 
     * @see #encodeUrl
     */
    private String urlEncode(String url){

        log.entry(url);

        String encodeString = url;

        if (!this.encodeUrl) {
            return encodeString;
        }
        try {
            // warning, you need to add an attribut to the connector in server.xml  
            // in order to get the utf-8 encoding working : URIEncoding="UTF-8"
            // See https://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q8
            encodeString = java.net.URLEncoder.encode(url, "UTF-8");
        } catch (Exception e) {
            log.error("Error while URLencoding", e);
        }
        return log.exit(encodeString);
    }

    /**
     * Decode String that was received through the URL.
     * 
     * @param url   the {@code String} to be decoded.
     * @return  a {@code String} decoded
     * 
     * @see #encodeUrl
     */
    private String urlDecode(String url){

        log.entry(url);
        String decodeString = url;

        try {
            decodeString = java.net.URLDecoder.decode(url, "UTF-8");
        } catch (Exception e) {
            log.error("Error while URLdecoding", e);
        }
        return log.exit(decodeString);
    }

    /**
     * @return The Parameter<String> that contains the key used to store the storable parameters
     */
    private Parameter<String> getKeyParam(){
        log.entry();
        return log.exit(this.urlParametersInstance.getParamData());
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state of the request. 
     *          It will change every time a parameter is modified
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     * 
     */
    public String getRequestURL() throws RequestParametersNotStorableException
    {
        log.entry();
        return log.exit(this.getRequestURL(this.parametersSeparator));
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator}.
     * TODO : is this method still useful now if we can set the parameter separator ?
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator in the URL
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state of the request. 
     *          It will change every time a parameter is modified
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     * 
     */
    public String getRequestURL(String parametersSeparator) throws RequestParametersNotStorableException
    {
        log.entry(parametersSeparator);
        this.generateParametersQuery(parametersSeparator);
        String prefix = "";
        if (StringUtils.isNotBlank(this.parametersQuery)) {
            prefix = "?";
        }
        return log.exit(prefix + this.parametersQuery);
    }

    /**
     * Return all the values for the given {@code URLParameters.Parameter<T>} 
     * in a {@code List<T>} or null if it is empty.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} that corresponds 
     *                  to the values to be returned
     *                  
     * @return  an {@code List<T>} of values
     */
    public <T> List<T> getValues(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        // Because the data type of URLParameters.Parameter is always checked 
        // when the value is stored, it is safe to not check.
        @SuppressWarnings("unchecked")
        ArrayList<T> values = (ArrayList<T>) this.values.get(parameter);

        try{
            // Return a copy of the list and not the original list
            // As the values contained are only immutable object, such as String
            // Integer, Boolean, Long, there is no need to clone the content
            return log.exit(new ArrayList<T>(values));

        } catch(NullPointerException e){
            return log.exit(null);
        }
    }

    /**
     * Return the first value of the given {@code URLParameters.Parameter<T>} 
     * or null if it is empty
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter the {@code URLParameters.Parameter<T>} 
     *                  that corresponds to the value to be returned
     *                  
     * @return  a {@code T}, the value
     */
    @SuppressWarnings("unchecked")    // Because the data type of URLParameters.Parameter
    // is always checked when the value is stored, it should be safe.
    public <T> T getFirstValue(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        try{
            return log.exit(((List<T>) this.values.get(parameter)).get(0));

        } catch(IndexOutOfBoundsException | NullPointerException e){
            return log.exit(null);            
        }
    }

    /**
     * Add a value to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * 
     * @param value     A {@code T}, the value to set
     * 
     * 
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws WrongFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */    
    @SuppressWarnings("unchecked")
    public <T> void addValue(URLParameters.Parameter<T> parameter, T value) 
            throws MultipleValuesNotAllowedException, WrongFormatException {
        log.entry(parameter,value);

        // Secure the value
        if(value != null){
            value = (T) this.secureString(value.toString(), parameter.getMaxSize(),
                    parameter.getFormat());
        }

        // fetch the existing values for the given parameter and try to add the value
        List<T> parameterValues = (List<T>) this.values.get(parameter);
        try{
            // Throw an exception if the param does not allow 
            // multiple values and has already one
            if (!parameter.allowsMultipleValues() && parameterValues.get(0) != null){
                throw(new MultipleValuesNotAllowedException(parameter.getName()));
            }
            parameterValues.add(value);
        }
        // If nullpointer, it means that there were no previous values at all, 
        // create the list
        catch(NullPointerException e){
            parameterValues = new ArrayList<T>();
            parameterValues.add(value);
        }

        this.values.put(parameter, parameterValues);
        log.exit();
    }

    
    /**
     * Reset the value for the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to reset
     */
    public <T>  void resetValues(URLParameters.Parameter<T> parameter) 
    {
        log.entry(parameter);
        this.values.put(parameter, null);
        log.exit();
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * with all parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with all parameter copied.
     *             
     */
    public RequestParameters cloneWithAllParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(true));
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * but only with the "storable" parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with the same values for "storable" as this one, 
     *             but with "non-storable" parameters simply initialized.
     */
    public RequestParameters cloneWithStorableParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(false));
    }

    /**
     * Method that actually proceed to the cloning and is called by 
     * {@link #cloneWithAllParameters()} and {@link #cloneWithStorableParameters()}
     * @param includeNonStorable    A boolean to tell whether to keep the non storable parameters
     * @return     a new {@code RequestParameters} object, with or without the non storable 
     *             parameters depending on {@code includeNonStorable}
     */
    private RequestParameters cloneRequestParameter(boolean includeNonStorable){
        log.entry(includeNonStorable);
        //to avoid duplicating methods, 
        //we we simulate a HttpServletRequest with parameters corresponding by a query string we provide 
        //holding storable parameters of this object
        String queryString = this.generateParametersQuery(true, includeNonStorable, "&");
        BgeeHttpServletRequest request = new BgeeHttpServletRequest(this.urlDecode(queryString));
        RequestParameters clonedRequestParameters = null;
        try {
            clonedRequestParameters = new RequestParameters(request, 
                    this.urlParametersInstance.getClass().newInstance(),this.prop,
                    this.encodeUrl, this.parametersSeparator);
            if(! includeNonStorable){
                // Add the key which is not a storable parameters and was not included
                clonedRequestParameters.addValue(this.getKeyParam(), 
                        this.getFirstValue(this.getKeyParam()));
            }
        } catch ( RequestParametersNotFoundException
                | MultipleValuesNotAllowedException | WrongFormatException e) {
            // In this particular case, should never be thrown.
            assert false: "Unreachable code reached in cloneWithAllParameters";
        } catch (InstantiationException | IllegalAccessException e) {
            // Do nothing but log the event
            log.throwing(e);
        }
        return log.exit(clonedRequestParameters);
    }

    /**
     * @return  An instance of {@code URLParameters} that provides all the
     *          {@code URLParameters.Parameter} that can be present in the request
     */
    public URLParameters getUrlParametersInstance() {
        return urlParametersInstance;
    }

    /**
     * @return  A {@code String } that is the name of the HTTP method with which this request
     *          was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    public String getHttpMethod() {
        return this.httpMethod;
    }

    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code action} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getAction() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamAction());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #addValue(Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code action} URL parameter 
     *                  to set.
     */
    public void setAction(String action) {
        this.addValue(this.getUrlParametersInstance().getParamAction(), action);
    }
    
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code page} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getPage() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPage());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #addValue(Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code page} URL parameter 
     *                  to set.
     */
    public void setPage(String page) {
        this.addValue(this.getUrlParametersInstance().getParamPage(), page);
    }
    
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Xml or not
     */
    public boolean isXmlDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals("xml")){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Csv or not
     */
    public boolean isCsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals("csv")){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Tsv or not
     */
    public boolean isTsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals("tsv")){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Allow to know if this request has been performed through AJAX. 
     * It is currently simply based on the fact that, in Bgee, all AJAX actions 
     * starts by "ajax_". It should be kept that way ;)
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if this request was performed through AJAX
     */
    public boolean isAnAjaxRequest()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamAction()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamAction()).toLowerCase()
                .startsWith("ajax_")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the page corresponds to the homepage
     */
    public boolean isTheHomePage(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) == null){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "about"
     */
    public boolean isAnAboutPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("about")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "admin"
//     */
//    public boolean isAnAdminPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("admin")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "anatomy"
//     */
//    public boolean isAnAnatomyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) == null || 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("anatomy")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "documentation"
     */
    public boolean isADocumentationPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOCUMENTATION)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "download"
     */
    public boolean isADownloadPageCategory(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOWNLOAD)){
            return log.exit(true);
        }
        return log.exit(false);
    }    

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "expression"
//     */
//    public boolean isAnExpressionPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("expression")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene"
//     */
//    public boolean isAGenePageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene_family"
//     */
//    public boolean isAGeneFamilyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene_family")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "log"
     */
    public boolean isALogPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("log")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "news"
     */
    public boolean isANewsPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("news")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "registration"
     */
    public boolean isARegistrationPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("registration")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "search"
     */
    public boolean isASearchPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("search")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "top_anat"
     */
    public boolean isATopOBOPageCategory()
    {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("top_anat")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Determine whether the requested page contains sensitive information, 
     * such as passwords.
     * Such pages should then not be cached, or the URL be stored in the database, etc.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if the page contains sensitive information, {@code false} otherwise.
     */
    public boolean isASecuredPage() 
    {
        log.entry();
        if (this.isALogPageCategory() || this.isARegistrationPageCategory()) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Determine whether the output of the current request can be stored by the web-cache.
     * Some responses should never be cached, following, e.g., a user identification request, 
     * or a HEAD request (would lead to cache a blank page). 
     * At the opposite, we might be interested in caching only some pages 
     * (e.g., computation-intensive pages are always computed following an AJAX request, 
     * in order to display a waiting message; we could then only cache AJAX requests).
     * <p>
     * Also, some cookies should never be put in cache, because specific to a user.
     * so that a cache will never send cookies. ( TODO : Probably no cookies in the future, but
     * developers have to be aware of the problem. Now your are ! )
     * 
     * @return  {@code true} if the response following the current request should be cached
     */
    public boolean isACacheableRequest()
    {
        log.entry();
        // Do not cache pages containing sensitive information
        if (this.isASecuredPage()) {
            return log.exit(false);
        }
        // Do not cache responses to HEAD requests, would lead to cache blank page
        // for security, we only accept POST and GET requests to be cached.
        // @see org.bgee.controller.servletUtils.BgeeWebCache#calculateKey(HttpServletRequest)
        if (!this.getHttpMethod().equalsIgnoreCase("get") && 
                !this.getHttpMethod().equalsIgnoreCase("post")) {
            return log.exit(false);
        }
        //do not cache POST request that are not AJAX requets: 
        //they should never send any response, and redirect the user to another page 
        //to avoid warning messages when pressing the back button.
        if(! this.isAnAjaxRequest() && this.getHttpMethod().equalsIgnoreCase("post")){
            return log.exit(false);
        }
        return log.exit(true);
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use
     * 
     * @param stringToCheck    a {@code String} to be checked 
     * @return a secured and prepared {@code String}. Return an empty String if security checks 
     *         have failed.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     */
    public String secureString(String stringToCheck) throws WrongFormatException
    {
        return secureString(stringToCheck, 0, null);
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use. It includes
     * a check of the {@code String} length and the format of the {@code String}.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param stringToCheck    a {@code String} to be checked 
     * @param lengthToCheck    an {@code int} defining the max allowed length of 
     *                         {@code stringToCheck}. If {@code stringToCheck} is greater 
     *                         than 0, and if the length of {@code stringToCheck} is greater
     *                         than {@code lengthToCheck}, this method throw a 
     *                         {@code WrongFormatException}. 
     *                         If {@code stringToCheck} is equal to 0, no control are performed 
     *                         on string length (but other modifications are still performed, 
     *                         such as triming the {@code String}). 
     * @param format           A {@code String} that contains the regular expression the 
     *                         {@code String} should match.
     * @return a secured and prepared {@code String}. Return an empty String if the stringToCheck
     *         was null.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     *
     *              
     */
    public String secureString(String stringToCheck, int lengthToCheck, String format)
            throws WrongFormatException
    {
        log.entry(stringToCheck, lengthToCheck, format);
        if (stringToCheck == null) {
            return "";
        }
        else if(lengthToCheck != 0 && stringToCheck.length() > lengthToCheck){
            log.info("The string {} cannot be validated because it is too long ({})", 
                    stringToCheck, stringToCheck.length());
            throw(new WrongFormatException());
        }
        else if(format != null && stringToCheck.matches(format) == false){
            log.info("The string {} cannot be validated because it does not match the format {}", 
                    stringToCheck, format);
            throw(new WrongFormatException());
        }
        return log.exit(stringToCheck.trim());
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use, 
     * without checking length of {@code stringToCheck} ({@code MAXSTRINGLENGTH}).
     * 
     * @param stringToCheck
     * @return a secured and prepared {@code String}. Return an empty String if the stringToCheck
     *         was null.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     * @see #secureString(String)
     */
    public String secureStringWithoutLengthCheck(String stringToCheck) throws WrongFormatException
    {
        return secureString(stringToCheck, 0, null);
    }

    /**
     * Perform security controls on the submitted {@code String} and transform it to a boolean.
     * 
     * @param stringToCheck a {@code String} to be checked 
     * @return  a {@code boolean} corresponding to the {@code stringToCheck}. 
     *          Return also {@code false} if {@code stringToCheck} was null, empty,
     *          or not secured.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     */
    public boolean secureStringAndCastToBoolean(String stringToCheck) throws WrongFormatException
    {
        log.entry(stringToCheck);
        String tempStringToCheck = secureString(stringToCheck);

        if (tempStringToCheck.equalsIgnoreCase("on") || 
                tempStringToCheck.equalsIgnoreCase("true")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Perform security controls on the submitted {@code String} and transform it to an int.
     * 
     * @param stringToCheck a {@code String} to be checked 
     * @return  an {@code int} corresponding to the {@code stringToCheck}. 
     *          Return also 0 if {@code stringToCheck} was null, empty, or not secured.
     * @throws WrongFormatException The {@code String} to secure does not fit the requirement
     */
    public int secureStringAndCastToInt(String stringToCheck) throws WrongFormatException
    {
        log.entry(stringToCheck);
        String tempStringToCheck = secureString(stringToCheck);

        int castInt = 0;
        if (StringUtils.isNotBlank(tempStringToCheck)) {
            try {
                castInt = Integer.parseInt(tempStringToCheck);
            } catch(NumberFormatException e) {
                castInt = 0;
            }
        }
        return log.exit(castInt);
    }

    /**
     * Change the {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * @param encodeUrl A {@code boolean} defining whether parameters should be url encoded 
     *                  by the {@code encodeUrl} method.
     */
    public void setEncodeUrl(boolean encodeUrl) {
        this.encodeUrl = encodeUrl;
    }

    /**
     * Change the {@code String} defining the character(s) that are used as parameters 
     * separator in the URL   
     * @param parametersSeparator A {@code String} defining the character(s) that are used as 
     * parameters separator in the URL   
     */
    public void setParametersSeparator(String parametersSeparator) {
        this.parametersSeparator = parametersSeparator;
    }
}


