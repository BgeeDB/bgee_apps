package org.bgee.controller.user;

import java.util.Arrays;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.UUID;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.RequestParameters;
import org.bgee.controller.user.UUIDSource;

/**
 * Represents a user using the Bgee webapp. Allows to track users over different requests to the server.
 * 
 * @author Frederic Bastian
 * @version Bgee 13 Nov 2016
 * @since Bgee 13 Nov 2016
 */
public class User {
    private final static Logger log = LogManager.getLogger(User.class.getName());
    
    /**
     * A {@code String} that is the name of the cookie storing the UUIDs generated by Bgee.
     */
    public static final String BGEE_UUID_COOKIE_NAME = "bgeeUUID";
    /**
     * A {@code String} that is the separator between the UUID and the creation timestamp 
     * in a Bgee cookie: in our tracking cookie, we store both the UUID and the creation date, 
     * for better cookie management.
     */
    protected final static String UUID_TIMESTAMP_COOKIE_SEPARATOR = "--";
    /**
     * An {@code int} that is the max age in second of the Bgee tracking cookie. 
     * Currently set to 2 years as recommended in: 
     * https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters#cid
     * max age in seconds: 3600 * 24 * 365 * 2 = 63,072,000
     */
    protected final static int BGEE_UUID_COOKIE_MAX_AGE = 63072000;
    
    
    //*****************************
    // attributes and constructors
    //*****************************
    /**
     * The {@code BgeeUUID} allowing to uniquely identify the user.
     */
    private final BgeeUUID uuid;
    
    // Info about the user for analytics purpose:
    /**
     * A {@code String} that is the IP address of the user as retrieved by 
     * {@link #extractIPAddress(HttpServletRequest)}.
     */
    private final String ipAddress;
    /**
     * An {@code Optional} {@code String} that is the user agent as retrieved by 
     * {@code request.getHeader("user-agent")}.
     */
    private final Optional<String> userAgent;
    /**
     * An {@code Optional} {@code String} that is the referring URL as retrieved by 
     * {@code request.getHeader("referer")}.
     */
    private final Optional<String> referrer;
    /**
     * An {@code Optional} {@code String} that is the preferred language of the user as retrieved by parsing 
     * {@code request.getHeader("accept-language")} using {@code Locale.LanguageRange.parse} 
     * (see http://stackoverflow.com/a/29000266/1768736).
     */
    private final Optional<String> preferredLanguage;
    
    /**
     * Construct a new {@code User} by using the request a user sent and the analyzed request parameters.
     * 
     * @param request           The {@code HttpServletRequest} sent by the user.
     * @param requestParams     The {@code RequestParameters} loaded from the request.
     * @throws IllegalArgumentException If the provided parameters do not allow to retrieve 
     *                                  all required information about the user.
     * @throws IllegalStateException    If it was not possible to generate an UUID for unknown reasons.
     */
    protected User(HttpServletRequest request, RequestParameters requestParams) 
            throws IllegalArgumentException, IllegalStateException {
        log.entry(request, requestParams);
        
        //First, try to identify user through API key
        BgeeUUID tmpUUID = this.retrieveUUIDFromAPIKey(request, requestParams);
        if (tmpUUID == null) {
            //Now, from cookie. If an exception is launched, we catch it, we don't want a query 
            //to fail only because of a cookie issue
            try {
                tmpUUID = this.retrieveUUIDFromCookie(request);
            } catch (IllegalArgumentException e) {
                log.catching(e);
            }
            if (tmpUUID == null) {
                //Everything failed, we generate a UUID from the request information
                tmpUUID = this.generateUUID(request);
            }
        }
        this.uuid = tmpUUID;
        if (this.uuid == null) {
            throw log.throwing(new IllegalStateException(
                    "Not possible to generate an UUID for unknown reason"));
        }
        
        this.ipAddress = this.extractIPAddress(request);
        if (this.ipAddress == null) {
            throw log.throwing(new IllegalArgumentException("The provided argument did not allow "
                    + "to discover the IP address of the user for unknown reason"));
        }
        
        this.userAgent = Optional.ofNullable(this.secureString(request.getHeader("user-agent")));
        this.referrer = Optional.ofNullable(this.secureString(request.getHeader("referer")));
        
        //Locale.LanguageRange.parse returns LanguageRanges in preferred order, most preferred first.
        String tmpLanguage = null;
        try {
            tmpLanguage = Locale.LanguageRange.parse(this.secureString(request.getHeader("accept-language")))
                    .stream().findFirst().map(range -> range.getRange()).orElse(null);
        } catch (NullPointerException|IllegalArgumentException e) {
            //Do nothing, we don't care if the header is absent of malformed
            log.catching(Level.TRACE, e);
        }
        this.preferredLanguage = Optional.ofNullable(tmpLanguage);

        log.debug("User created: {}", this);
        log.exit();
    }
    
    //***************************************
    // generate UUID and extract user info
    //***************************************
    
    /**
     * Generate a {@code BgeeUUID} to be used to identify a user. This method is used 
     * when no cookie allowing to identify the user was found, and no other identifying parameters, 
     * such as an API key, was retrieved.
     * 
     * @param request           The {@code HttpServletRequest} sent by the user.
     * @param requestParams     The {@code RequestParameters} loaded from the request.
     * @return                  A {@code BgeeUUID} uniquely identifying a user.
     */
    private BgeeUUID generateUUID(HttpServletRequest request) {
        log.entry(request);
        
        //Info to NOT use: 
        // * Do not use "origin": maybe a same user makes a query to our webservice 
        //   through a cross-domain AJAX query from another resource. 
        // * Similarly, do not use "Host" and "X-Forwarded-Host".
        // * remoteUser: seems good because it requires authentication, but, according to tomcat javadoc, 
        //   "Whether the user name is sent with each subsequent request depends on the browser and type of authentication."
        // * Authorization: if used in Digest access authentication, will change at each request
        StringBuilder sb = new StringBuilder();

        //Info to use, see https://amiunique.org/faq and https://amiunique.org/fp
        sb.append("generated: ");
        sb.append(this.secureString(request.getHeader("accept"))).append("; ");
        sb.append(this.secureString(request.getHeader("accept-charset"))).append("; ");
        sb.append(this.secureString(request.getHeader("accept-encoding"))).append("; ");
        sb.append(this.secureString(request.getHeader("accept-language"))).append("; ");
        sb.append(this.secureString(request.getHeader("user-agent"))).append("; ");
        //Do not use email address solely as a unique ID, seems a bit weird to send his email...
        sb.append(this.secureString(request.getHeader("from"))).append("; "); //email address
        //OOOK, I know what you think, using the DNT header for better discriminating users 
        //seems a bit unethical. But it's only to better discriminate them for limiting 
        //number of parallel jobs per users, not for really tracking them :x
        sb.append(this.secureString(request.getHeader("dnt"))).append("; ");  //DoNotTrack
        
        //Actually, real fingerprinting does not use this info, see https://amiunique.org/faq
        //(but it also uses javascript/flash/image canva-based information)
        //XXX: when our web-application will be fully AJAX-based, retrieve some more information 
        //using javascript
        sb.append(this.extractIPAddressInfo(request)).append("; ");
        sb.append(this.secureString(request.getRemoteHost())).append("; ");   //name of client or last proxy
        
        String id = sb.toString();
        log.debug("ID String generated: {} ", id);
        
        return log.exit(new BgeeUUID(id, UUIDSource.GENERATED, System.currentTimeMillis()));
    }

    /**
     * Try to identify the IP address of the user. There is no guarantee that the user IP address 
     * can be reliably discovered. 
     * 
     * @param request   The {@code HttpServletRequest} sent by the user.
     * @return          A {@code String} that is the IP address of the user.
     * @see #extractIPAddressInfo(HttpServletRequest)
     */
    private String extractIPAddress(HttpServletRequest request) {
        log.entry(request);
        //split the IP address info based on the first char that is not valid in IP v4 or v6 addresses.
        String ipInfo = this.extractIPAddressInfo(request);
        log.debug("IP Info: {}", ipInfo);
        return log.exit(ipInfo == null? null: ipInfo.split("[^a-f0-9\\.:%/]", 2)[0]);
    }
    /**
     * Try to identify the IP address of the user. There is no guarantee that the user IP address 
     * can be reliably discovered. Moreover, some header values can contain multiple IP addresses, 
     * such as the header "X-Forwarded-For". The {@code String} returned is therefore not formally 
     * an IP address, more like an IP address "info". The aim is simply to generate a reliable 
     * UUID for the user on first visit.
     * 
     * @param request   The {@code HttpServletRequest} sent by the user.
     * @return          A {@code String} that represents the most likely information 
     *                  about the IP address of the user.
     * @see http://stackoverflow.com/a/18350661/1768736
     * @see #extractIPAddress(HttpServletRequest)
     */
    private String extractIPAddressInfo(HttpServletRequest request) {
        log.entry(request);
        
        String ip = this.filterIP(request.getHeader("X-Forwarded-For"));
        if (ip != null) {
            return log.exit(ip);
        }
        ip = this.filterIP(request.getHeader("Proxy-Client-IP")); 
        if (ip != null) {
            return log.exit(ip);
        }
        ip = this.filterIP(request.getHeader("WL-Proxy-Client-IP"));
        if (ip != null) {
            return log.exit(ip);
        }
        ip = this.filterIP(request.getHeader("HTTP_CLIENT_IP"));
        if (ip != null) {
            return log.exit(ip);
        }
        ip = this.filterIP(request.getHeader("HTTP_X_FORWARDED_FOR"));
        if (ip != null) {
            return log.exit(ip);
        }
        ip = this.filterIP(request.getHeader("X-Real-IP"));
        if (ip != null) {
            return log.exit(ip);
        }
        return log.exit(this.filterIP(request.getRemoteAddr()));
    }
    /**
     * @param ip    A {@code String} that is an IP address info to be filtered.
     * @return      A {@code String} that is {@code null} if {@code ip} was invalid, 
     *              or the trimmed lower-case value of {@code ip} if it was valid.
     */
    private String filterIP(String ip) {
        log.entry(ip);
        if (StringUtils.isBlank(ip) || "unknown".equalsIgnoreCase(ip)) {
            return log.exit(null);
        }
        //lower case for IPv6 addresses
        return log.exit(this.secureString(ip).trim().toLowerCase(Locale.US));
    }
    
    /**
     * Secure an input {@code String}. Since a header or cookie sent by a client could be anything, 
     * we need to secure this input. For now, we discard any {@code String}s with weird characters, 
     * and limit their max length to 5,000 characters.
     * 
     * @param toSecure  The {@code String} to be secured.
     * @return          A secured {@code String}.
     */
    private String secureString(String toSecure) {
        log.entry();
        //avoid weird Chinese characters etc. See UrlParameters.DEFAULT_FORMAT
        if (toSecure == null || !toSecure.matches("^[\\w~@#&$^*/()_+=\\[\\]{}|\\\\,;.?!'\": \\-%]*$")) {
            return log.exit(null);
        }
        int maxLength = 5000;
        return log.exit(toSecure.substring(0, 
                toSecure.length() < maxLength? toSecure.length(): maxLength));
    }
    
    
    //***************************************
    // UUID retrieval
    //***************************************
    /**
     * Generate the UUID from an API key provided.
     * @param request   The {@code HttpServletRequest} sent by the user.
     * @return          A {@code BgeeUUID} built from an API key.
     */
    private BgeeUUID retrieveUUIDFromAPIKey(HttpServletRequest request, RequestParameters requestParams) {
        log.entry(request);
        //If the user sent an API key, then solely use it
        if (StringUtils.isNotBlank(requestParams.getApiKey())) {
            //XXX: as long as we do not enforce users to request a real API key, 
            //we merge this info with the IP address (API keys in our R package are produced 
            //based on the 'sys.getEnv()' information, two users could have the same)
            return log.exit(new BgeeUUID(
                    "apiKey: " + requestParams.getApiKey() + "; " + this.extractIPAddressInfo(request), 
                    UUIDSource.API_KEY, 0));
        }
        return log.exit(null);
    }
    
    /**
     * Retrieve the UUID from the cookies available.
     * @param request   The {@code HttpServletRequest} sent by the user.
     * @return          A {@code BgeeUUID} built from an UUID retrieved in a cookie.
     * @throws IllegalArgumentException     If the Bgee cookie retrieved from {@code request} is malformed.
     */
    private BgeeUUID retrieveUUIDFromCookie(HttpServletRequest request) throws IllegalArgumentException {
        log.entry(request);
        
        Cookie[] cookies = request.getCookies();
        if (cookies == null) {
            return log.exit(null);
        }
        Cookie bgeeCookie = Arrays.stream(request.getCookies())
                .filter(c -> BGEE_UUID_COOKIE_NAME.equals(c.getName()) && 
                        StringUtils.isNotBlank(c.getValue()))
                .findFirst().orElse(null);
        if (bgeeCookie == null) {
            return log.exit(null);
        }
        String value = this.secureString(bgeeCookie.getValue()); //can return null if unsecured string
        if (value == null) {
            return log.exit(null);
        }
        
        //In the Bgee cookie, we store both the UUID and the last update timestamp, 
        //in the form: UUID + UUID_TIMESTAMP_COOKIE_SEPARATOR + timestamp
        String[] valSplit = value.split(UUID_TIMESTAMP_COOKIE_SEPARATOR, 2);
        if (valSplit.length != 2) {
            throw log.throwing(new IllegalArgumentException(
                    "The request provided a malformed Bgee cookie: " + value));
        }
        try {
            String bgeeUUID = valSplit[0];
            long lastUpdate = Long.parseLong(valSplit[1]);
            
            BgeeUUID uuid = new BgeeUUID(bgeeUUID, UUIDSource.BGEE_COOKIE, lastUpdate);
            log.debug("BgeeUUID retrieved from Bgee cookie: {}", uuid);
            return log.exit(uuid);
            
        } catch (NumberFormatException e) {
            throw log.throwing(new IllegalArgumentException(
                    "The request provided a malformed Bgee cookie: " + value, e));
        }
    }

    /**
     * Create or update the Bgee tracking cookie for this user. If an UUID has just been generated 
     * for this user (no existing cookie nor API key provided, etc), this method will create 
     * a new {@code Cookie} to be added to the response. If the UUID was retrieved from a Bgee cookie, 
     * this method retrieves it from the request and update the expiration date if needed: 
     * because adding a cookie to the response will prevent caching when HTTP 1.0 protocol is used, 
     * and because it modifies the response so that we cannot simply cache it ourselves, 
     * we update the cookie only if it has reached half of its expiration date.
     * <p>
     * If it was not needed to create or update the {@code Cookie}, this method returns {@code null}.
     * 
     * @param request           The {@code HttpServletRequest} sent by the user.
     * @param rootDomain        The root domain of Bgee (e.g., '.bgee.org') to define the domain 
     *                          of the {@code Cookie}, so that it can be shared between 
     *                          different Bgee webservices and versions. If {@code null}, 
     *                          no domain will be set.
     * @return                  An {@code Optional} {@code Cookie} for Bgee newly created an updated. 
     *                          Empty {@code Optional} if it was not needed to create or update a cookie.
     * @throws IllegalArgumentException If {@code rootDomain} is not null but invalid, 
     *                                  of if the parameters do not allow to retrieve 
     *                                  the required information.
     */
    public Optional<Cookie> manageTrackingCookie(HttpServletRequest request, String rootDomain) 
            throws IllegalArgumentException {
        log.entry(request, rootDomain);
        return log.exit(this.manageTrackingCookie(request, rootDomain, System.currentTimeMillis()));
    }
    /**
     * Create or update the Bgee tracking cookie for this user. If an UUID has just been generated 
     * for this user (no existing cookie nor API key provided, etc), this method will create 
     * a new {@code Cookie} to be added to the response. If the UUID was retrieved from a Bgee cookie, 
     * this method retrieves it from the request and update the expiration date if needed: 
     * because adding a cookie to the response will prevent caching when HTTP 1.0 protocol is used, 
     * and because it modifies the response so that we cannot simply cache it ourselves, 
     * we update the cookie only if it has reached half of its expiration date.
     * <p>
     * If it was not needed to create or update the {@code Cookie}, this method returns {@code null}.
     * 
     * @param request           The {@code HttpServletRequest} sent by the user.
     * @param rootDomain        The root domain of Bgee (e.g., '.bgee.org') to define the domain 
     *                          of the {@code Cookie}, so that it can be shared between 
     *                          different Bgee webservices and versions. If {@code null}, 
     *                          no domain will be set.
     * @param currentTimestamp  A {@code long} that is the current timestamp in milliseconds, 
     *                          to be compared with the last udpate date of a Bgee cookie. 
     *                          Allows easier unit testing.
     * @return                  An {@code Optional} {@code Cookie} for Bgee newly created an updated. 
     *                          Empty {@code Optional} if it was not needed to create or update a cookie.
     * @throws IllegalArgumentException If {@code rootDomain} is not null but invalid, 
     *                                  of if the parameters do not allow to retrieve 
     *                                  the required information.
     */
    protected Optional<Cookie> manageTrackingCookie(HttpServletRequest request, String rootDomain, 
            long currentTimestamp) throws IllegalArgumentException {
        log.entry(request, rootDomain, currentTimestamp);
        
        if (rootDomain != null && StringUtils.countMatches(rootDomain, ".") < 2) {
            throw log.throwing(new IllegalArgumentException("Incorrect domain: " + rootDomain 
                    + " - a root domain must contain at least 2 dots."));
        }
        
        //If an UUID has just been generated for this user (no existing cookie nor API key provided, etc), 
        //try to store a cookie on the client
        Cookie bgeeCookie = null;
        
        if (UUIDSource.GENERATED.equals(this.getUUIDSource())) {
            //In our cookie, we store both the UUID and the creation timestamp, using a separator, 
            //for better cookie management
            bgeeCookie = new Cookie(User.BGEE_UUID_COOKIE_NAME, this.getUUID().toString() 
                    + UUID_TIMESTAMP_COOKIE_SEPARATOR + this.uuid.getLastUpdateTimestamp());
            
            //set the path and domain so the cookie can be shared 
            //between different Bgee webservices and versions
            bgeeCookie.setPath("/");
            if (StringUtils.isNotBlank(rootDomain)) {
                bgeeCookie.setDomain(rootDomain);
            }
            bgeeCookie.setMaxAge(BGEE_UUID_COOKIE_MAX_AGE);
            log.debug("Creating new Cookie {}: {}", bgeeCookie.getName(), bgeeCookie.getValue());
            
        }
        //If the UUID was retrieved from a cookie, we update the expiration date.
        //But because setting a cookie will prevent caching when HTTP 1.0 protocol is used, 
        //and because it modifies the response so that we cannot simply cache it ourselves, 
        //we update the cookie only if it has reached half of its expiration date
        else if (UUIDSource.BGEE_COOKIE.equals(this.getUUIDSource()) && 
                (currentTimestamp - this.uuid.getLastUpdateTimestamp())/1000l >= BGEE_UUID_COOKIE_MAX_AGE/2) {
            try {
                bgeeCookie = Arrays.stream(request.getCookies())
                        .filter(c -> User.BGEE_UUID_COOKIE_NAME.equals(c.getName()))
                        .findFirst().get();
                
                bgeeCookie.setValue(this.getUUID().toString() 
                    + UUID_TIMESTAMP_COOKIE_SEPARATOR + currentTimestamp);
                bgeeCookie.setMaxAge(BGEE_UUID_COOKIE_MAX_AGE);
                
                if (!StringUtils.equals(rootDomain, bgeeCookie.getDomain())) {
                    log.warn("It was requested to define a cookie domain, but the cookie to update "
                            + "has a different domain. Requested domain: {} - Cookie to update domain: {}", 
                            rootDomain, bgeeCookie.getDomain());
                }
                log.debug("Updating expiration date of existing cookie: {}: {}", 
                        bgeeCookie.getName(), bgeeCookie.getValue());
            } catch (NoSuchElementException e) {
                //if we couldn't find the cookie, while the UUID was retrieved from the cookie, 
                //we have a problem...
                log.catching(e);
                throw log.throwing(new IllegalArgumentException("The provided request did not allow "
                        + "to retrieve the cookie used to identify the user."));
            }
        } else {
            log.debug("No cookie updated");
        }
        
        return log.exit(Optional.ofNullable(bgeeCookie));
    }
    
    //*****************************
    // getters
    //*****************************
    //we do not expose the BgeeUUID publicly, I guess it's unnecessary
    /**
     * @return  The {@code BgeeUUID} for this {@code User}.
     */
    protected BgeeUUID getBgeeUUID() {
        return uuid;
    }
    /**
     * @return  The {@code UUID} for this {@code User}.
     * @see #getUUIDSource()
     */
    public UUID getUUID() {
        return this.getBgeeUUID().getUUID();
    }
    /**
     * @return  The {@code UUIDSource} the UUID returned by {@code #getUUID()} was retrieved from.
     * @see #getUUID()
     */
    public UUIDSource getUUIDSource() {
        return this.getBgeeUUID().getUUIDSource();
    }
    /**
     * @return  A {@code String} that is the IP address of the user as retrieved from the HTTP request.
     */
    public String getIPAddress() {
        return this.ipAddress;
    }
    /**
     * @return  An {@code Optional} {@code String} that is the user agent as retrieved from the HTTP request.
     */
    public Optional<String> getUserAgent() {
        return userAgent;
    }
    /**
     * @return  An {@code Optional} {@code String} that is the referring URL the user comes from, 
     *          as retrieved from the HTTP request.
     */
    public Optional<String> getReferrer() {
        return referrer;
    }
    /**
     * @return  An {@code Optional} {@code String} that is the most preferred language of the user, 
     *          as retrieved from the HTTP request and parsed using {@code Locale.LanguageRange.parse}.
     */
    public Optional<String> getPreferredLanguage() {
        return preferredLanguage;
    }

    //*****************************
    // equals/hashCode/toString
    //*****************************
    @Override
    public int hashCode() {
        //solely based on BgeeUUID
        final int prime = 31;
        int result = 1;
        result = prime * result + ((uuid == null) ? 0 : uuid.hashCode());
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        //solely based on BgeeUUID
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        User other = (User) obj;
        if (uuid == null) {
            if (other.uuid != null) {
                return false;
            }
        } else if (!uuid.equals(other.uuid)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("User [ipAddress=").append(ipAddress)
               .append(", userAgent=").append(userAgent)
               .append(", referrer=").append(referrer)
               .append(", preferredLanguage=").append(preferredLanguage)
               .append(", uuid=").append(uuid)
               .append("]");
        return builder.toString();
    }
}
