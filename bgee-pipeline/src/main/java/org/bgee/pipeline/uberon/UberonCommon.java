package org.bgee.pipeline.uberon;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.pipeline.ontologycommon.OntologyUtils;
import org.obolibrary.oboformat.parser.OBOFormatConstants.OboFormatTag;
import org.obolibrary.oboformat.parser.OBOFormatParserException;
import org.semanticweb.owlapi.model.AxiomType;
import org.semanticweb.owlapi.model.OWLAnnotationAssertionAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;
import org.semanticweb.owlapi.model.OWLObjectProperty;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;

import owltools.graph.OWLGraphWrapper;

/**
 * Class holding attributes and methods common to {@link Uberon} and {@link UberonDevStage}.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
abstract class UberonCommon {
    /**
     * {@code Logger} of the class.
     */
    private final static Logger log = LogManager.getLogger(UberonCommon.class.getName());
    
    /**
     * A {@code String} that is the OBO-like ID of the root of the NCBI taxonomy ontology.
     */
    public final static String TAXONOMY_ROOT_ID = "NCBITaxon:1";
    
    /**
     * A {@code String} that is the name of the column containing the anatomical entity IDs 
     * (for instance, "UBERON:0001905") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String UBERON_ENTITY_ID_COL = "Uberon ID";
    /**
     * A {@code String} that is the name of the column containing the anatomical entity names 
     * (for instance, "pineal body") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String ANAT_ENTITY_NAME_COL = "Uberon name";
    /**
     * A {@code String} that is the name of the column containing the is_a/part_of relations 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String RELATIONS_COL = "is_a/part_of relations";
    /**
     * A {@code String} that is the name of the column containing the reason for the removal 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String REASON_FOR_REMOVAL = "Reason for removal";
    /**
     * A {@code String} that is the name of the column containing the IDs of the XRefs 
     * we want a mapping from, to Uberon IDs, in the file generated by 
     * {@link #saveXRefMappingsToFile(String, String)}.
     * 
     * @see #saveXRefMappingsToFile(String, String)
     */
    public static final String XREF_ID_COL = "XRef ID";
    
    /**
     * A {@code String} that is the path to the file storing the Uberon ontology 
     * (recommended version is OWL, but OBO versions can be used as well).
     */
    private String pathToUberonOnt;
    /**
     * A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     * in files (suffixes ".obo" and ".owl" will be automatically added).
     */
    private String modifiedOntPath;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs of {@code OWLClass}es 
     * to remove from the ontology, and to propagate their incoming edges 
     * to their outgoing edges. Argument when calling 
     * {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     */
    private Collection<String> classIdsToRemove;
    /**
     * A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     * Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     * to remove, the associated value being a {@code Set} of {@code String}s 
     * that are the OBO-like ID of the targets of the relations to remove.
     * {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     * for each key with each entry in the associated {@code Set}.
     */
    private Map<String, Set<String>> relsBetweenToRemove;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     * of relations to be filtered and mapped to parent relations. Argument when calling 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     * with second argument {@code true}.
     */
    private Collection<String> relIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs 
     * to be removed from the ontology. Classes part both of a subgraph to remove 
     * and a subgraph not to be removed will be kept. 
     * Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toRemoveSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     * in the ontology. Their ancestors will be kept as well. Argument when calling 
     * {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toFilterSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of subgraphs to ignore. 
     * This is useful for instance for OBO GCI relations: they make use of taxon classes, 
     * so that it is not possible to remove the taxonomy from the ontology; yet, 
     * when inserting anatomy or developmental stages, we do not want to consider them; 
     * the root of the taxonomy would then define a subgraph to ignore.
     */
    private Collection<String> toIgnoreSubgraphRootIds;
    /**
     * A {@code String} that is the path to the file that will store information about 
     * the {@code OWLClass}es that were removed as a result of simplification.
     */
    private String classesRemovedFilePath;
    /**
     * A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     * and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     * in which the {@code OWLClass} exists. 
     */
    private Map<String, Set<Integer>> taxonConstraints;
    /**
     * A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     * of {@code OWLClass}es removed as a result of the simplification process, 
     * the associated values being {@code String}s representing the reason 
     * for the class removal.
     * <p>
     * Note: this could be represented in a better object-oriented way, but we just go 
     * fast and dirty for the pipeline.
     */
    private final Map<String, String> classesRemoved;
    
    /**
     * The {@code OntologyUtils} used to perform operations, wrapping the Uberon ontology 
     * that will be used. 
     */
    private final OntologyUtils ontUtils;
    
    /**
     * Default constructor private in purpose, an ontology should always be provided somehow.
     */
    @SuppressWarnings("unused")
    private UberonCommon() {
        this((OntologyUtils) null);
    }
    
    /**
     * Constructor providing the path to the Uberon ontology to used to perforn operations.
     * 
     * @param pathToUberon  A {@code String} that is the path to the Uberon ontology. 
     * @throws OWLOntologyCreationException If an error occurred while loading the ontology.
     * @throws OBOFormatParserException     If the ontology is malformed.
     * @throws IOException                  If the file could not be read. 
     */
    public UberonCommon(String pathToUberon) throws OWLOntologyCreationException, 
    OBOFormatParserException, IOException {
        this(new OntologyUtils(pathToUberon));
    }
    /**
     * Constructor providing the {@code OntologyUtils} used to perform operations, 
     * wrapping the Uberon ontology that will be used, and the {@code MySQLDAOManager} 
     * to interract with the data source. 
     * 
     * @param ontUtils  the {@code OntologyUtils} that will be used. 
     */
    public UberonCommon(OntologyUtils ontUtils) {
        this.ontUtils = ontUtils;
        this.classesRemoved = new HashMap<String, String>();
        this.setTaxonConstraints(null);
    }

    
    /**
     * Delegates to {@link #getOWLClasses(String, boolean)} with the {@code boolean} 
     * argument set to {@code true}, and returns either the {@code OWLClass} contained 
     * in the returned {@code Set}, or {@code null} if it is empty. 
     * 
     * @param id    See same name argument in {@link #getOWLClasses(String, boolean)}
     * @return      The {@code OWLClass} retrieved based on {@code id}, or {@code null} 
     *              if none were retrieved.
     * @see #getOWLClasses(String, boolean)
     */
    public OWLClass getOWLClass(String id) {
        log.entry(id);
        
        Set<OWLClass> potentialClasses = this.getOWLClasses(id, true);
        if (potentialClasses.size() == 1) {
            return log.exit(potentialClasses.iterator().next());
        } 
        return log.exit(null);
    }
    
    /**
     * Obtains from the ontology wrapped in this object the {@code OWLClass}es corresponding to 
     * {@code id}. The {@code OWLClass}es will be tried to be identified: first by assuming 
     * {@code id} is an OBO-like ID (using 
     * {@code OWLGraphWrapperExtended.getOWLClassByIdentifier(String)}); then, if not identified, 
     * by assuming it is the {@code String} representation of an {@code IRI} (using 
     * {@code OWLGraphWrapperExtended.getOWLClass(String)}); at this point, if a class 
     * was retrieved, it will be checked whether it is a taxon equivalence to an Uberon class 
     * (using ECAs between the retrieved class and 
     * IntersectionOf(Uberon_class part_of some taxon_class)), in which case 
     * the Uberon class will be returned; then, if the class was not identified, it will 
     * be assumed that {@code id} is an xref (in that case, xref mappings are retrieved calling 
     * {@link #getXRefMappings()}; then, if not identified, by checking whether {@code id} 
     * maps to an obsolete {@code OWLClass}, in which case the "replaced_by" mappings 
     * will be returned (replaced_by mappings are retrieved by calling 
     * {@link #getReplacedByMappings()}). If {@code isStrict} is {@code true}, 
     * then only an {@code OWLClass} uniquely corresponding to an Uberon term or an xref or 
     * a replaced_by annotation will be considered, and if it maps to several 
     * {@code OWLClass}es, they will be discarded. If {@code isStrict} 
     * is {@code false}, then ambiguously mapped {@code OWLClass}es will all be returned. 
     * <p>
     * If an {@code OWLClass} is retrieved by its OBO-like ID or its IRI, then 
     * the returned {@code Set} will contain only one {@code OWLClass}. If {@code isStrict} 
     * is {@code true}, the returned {@code Set} will always contain 
     * either 0 or 1 {@code OWLClass} (this is similar to calling 
     * {@link #getOWLClass(String)}). If {@code isStrict} is {@code false}, 
     * the returned {@code Set} can contain any number of elements. 
     * 
     * @param id    A {@code String} that can be either the OBO-like ID or the {@code IRI} 
     *              of an {@code OWLClass}, or an XRef mapped to some {@code OWLClass}es, 
     *              or the OBO-like ID or {@code IRI} of an obsolete {@code OWLClass}, 
     *              for which to retrieve the {@code OWLClass}es to use as replacement.
     * @param isStrict  A {@code boolean} defining whether only unambiguous xref 
     *                  or replaced_by mappings should be considered. In that case, 
     *                  the returned {@code Set} will contain at most 1 element.
     * @return          A {@code Set} of {@code OWLClass}es that were retrieved 
     *                  from {@code id}.
     * @see #getOWLClass(String)
     */
    public Set<OWLClass> getOWLClasses(String id, boolean isStrict) {
        return this.getOWLClasses(id, isStrict, null);
    }
    
    /**
     * Same as {@link #getOWLClasses(String, boolean)}, with an additional argument 
     * {@code visitedIds}, to protect against infinite cycles when calling this method 
     * recursively. 
     * 
     * @param id            See {@link #getOWLClasses(String, boolean)}
     * @param isStrict      See {@link #getOWLClasses(String, boolean)}
     * @param visitedIds    A {@code Set} of {@code String}s storing IDs already visited 
     *                      when calling this method recursively.
     * @return              See {@link #getOWLClasses(String, boolean)}
     */
    private Set<OWLClass> getOWLClasses(String id, boolean isStrict, Set<String> visitedIds) {
        log.entry(id, isStrict, visitedIds);

        Set<OWLClass> potentialClasses = new HashSet<OWLClass>();
        
        if (visitedIds == null) {
            visitedIds = new HashSet<String>();
        }
        if (visitedIds.contains(id)) {
            return potentialClasses;
        }
        visitedIds.add(id);
        
        OWLGraphWrapper wrapper = this.getOntologyUtils().getWrapper();
        OWLClass cls = wrapper.getOWLClassByIdentifier(id);
        //if id was not an OBO-like ID, but an IRI
        if (cls == null) {
            cls = wrapper.getOWLClass(id);
        }
        
        
        if (cls != null) {
            //check that this class is not actually equivalent to the intersection 
            //of an Uberon class in a given taxon, in which case we would return 
            //the Uberon equivalent class
            OWLObjectProperty partOf = wrapper.getOWLObjectPropertyByIdentifier(
                    OntologyUtils.PART_OF_ID);
            OWLClass taxonomyRoot = wrapper.getOWLClassByIdentifier(TAXONOMY_ROOT_ID);
            Set<OWLClass> classesMapped = 
                    this.getOntologyUtils().getECAIntersectionOf(cls, partOf, taxonomyRoot);
            if (classesMapped.size() == 1 || !isStrict) {
                potentialClasses.addAll(classesMapped);
            } 
            //if no equivalent class, just consider cls
            if (classesMapped.isEmpty()) {
                potentialClasses.add(cls);
            }
        } else {
            //in case the id provided was actually an xref
            Set<String> classIdsMapped = this.getOntologyUtils().getXRefMappings().get(id);
            if (classIdsMapped != null) {
                Set<OWLClass> classesMapped = new HashSet<OWLClass>();
                for (String idMapped: classIdsMapped) {
                    //recursivity to get the class corresponding to the xref
                    classesMapped.addAll(this.getOWLClasses(idMapped, isStrict, visitedIds));
                }
                if (classesMapped.size() == 1 || !isStrict) {
                    potentialClasses.addAll(classesMapped);
                }
            }
        }
        
        //iterate a copy of potentialClasses to be able to modify it.
        //here, we check for obsolete classes replaced by another class
        for (OWLClass potentialClass: new HashSet<OWLClass>(potentialClasses)) {
            //if the class is obsolete, search for replaced_by annotations
            if (wrapper.isObsolete(potentialClass) || 
                    wrapper.getIsObsolete(potentialClass)) {
                
                potentialClasses.remove(potentialClass);

                //otherwise, we need to use the replaced_by annotations
                Set<String> replacedByIds = this.getOntologyUtils().getReplacedByMappings().get(
                        wrapper.getIdentifier(potentialClass));
                if (replacedByIds != null) {
                    Set<OWLClass> classesMapped = new HashSet<OWLClass>();
                    //we iterate all IDs even if isStrict is true: maybe several replaced_by 
                    //annotations will end up pointing to the same OWLClass
                    for (String idMapped: replacedByIds) {
                        //use recursivity in case the replaced_by annotation is itself pointing 
                        //to an obsolete class or an xref
                        Set<OWLClass> tempClassesMapped = this.getOWLClasses(idMapped, isStrict, visitedIds);
                        if (tempClassesMapped.isEmpty()) {
                            log.warn("A replaced_by annotation from OWLClass {} did not allow to retrieve an OWLClass: {}", 
                                    id, idMapped);
                        }
                        classesMapped.addAll(tempClassesMapped);
                    }
                    if (classesMapped.size() == 1 || !isStrict) {
                        potentialClasses.addAll(classesMapped);
                    }
                }
            }
        } 
        
        return log.exit(potentialClasses);
    }
    
    protected void convertTaxonECAsToXrefs() {
        log.entry();
        
        OWLGraphWrapper wrapper = this.getOntologyUtils().getWrapper();
        OWLObjectProperty partOf = wrapper.getOWLObjectPropertyByIdentifier(
                OntologyUtils.PART_OF_ID);
        OWLClass taxonomyRoot = wrapper.getOWLClassByIdentifier(TAXONOMY_ROOT_ID);
        
        for (OWLOntology ont: this.getOntologyUtils().getWrapper().getAllOntologies()) {
            OWLDataFactory fac = ont.getOWLOntologyManager().getOWLDataFactory();
            for (OWLClass cls: ont.getClassesInSignature()) {
                //retrieve taxonomy equivalent classes
                CONTINUE HERE WITH getECAIntersectionOf
                for (OWLClass equivalentCls: 
                    this.getOntologyUtils().getECAIntersectionOf(cls, partOf, taxonomyRoot)) {
                    //create the xref 
                    OWLAnnotationAssertionAxiom ax = fac.getOWLAnnotationAssertionAxiom(
                            wrapper.getAnnotationProperty(OboFormatTag.TAG_XREF.getTag()), 
                            cls.getIRI(), equivalentCls.getIRI());
                    if (!ont.containsAxiomIgnoreAnnotations(ax)) {
                        ont.getOWLOntologyManager().addAxiom(ont, ax);
                    }
                }
            }
        }
        
        log.exit();
    }


    /**
     * Determines whether {@code cls} belongs to the taxon with ID {@code taxonId}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * or {@code taxonId} is equal to 0, this method will always return {@code true}. 
     * If some taxon constraints have been provided, and if {@code taxonId} is different from 0, 
     * then this method will return {@code true} if {@code cls} belongs to the taxon, 
     * {@code false} otherwise (if the taxon does not belong to the set of taxon IDs 
     * associated to the class). 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to the taxon with ID {@code taxonId}.
     * @param taxonId       An {@code int} that is the NCBI ID of the taxon for which 
     *                      we want to know if {@code cls} belongs to.
     * @return              {@code false} if it is shown that {@code cls} doesa not belong to 
     *                      taxon with ID {@code taxonId}, {@code false} otherwise. 
     * @see #existsInAtLeastOneSpecies(OWLClass, Collection)
     */
    public boolean existsInSpecies(OWLClass cls, int taxonId) {
        log.entry(cls, taxonId);
        if (this.getTaxonConstraints() == null || taxonId == 0) {
            return log.exit(true);
        }
        Set<Integer> validSpecies = this.getTaxonConstraints().get(
                this.getOntologyUtils().getWrapper().getIdentifier(cls));
        if (validSpecies == null || !validSpecies.contains(taxonId)) {
            return log.exit(false);
        }
        return log.exit(true);
    }

    /**
     * Determines whether {@code cls} belongs to at least one taxon with ID in {@code taxonIds}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * or if {@code taxonIds} contains 0, this method will always return {@code true}. 
     * If some taxon constraints have been provided, and if {@code taxonIds} does not contain 0, 
     * then this method will return {@code true} if {@code cls} belongs to one of the taxa, 
     * {@code false} otherwise. 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to one of the taxa with ID in {@code taxonIds}.
     * @param taxonId       A {@code Collection} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxon for which we want to know if {@code cls} belongs to any.
     * @return              {@code false} if it is shown that {@code cls} does not belong to 
     *                      any taxon with ID in {@code taxonIds}, {@code false} otherwise. 
     * @throw IllegalArgumentException  If {@code taxonIds} is empty, as this method would then 
     *                                  only return {@code false}.
     * @see #existsInSpecies(OWLClass, int)
     */
    public boolean existsInAtLeastOneSpecies(OWLClass cls, Collection<Integer> taxonIds) {
        log.entry(cls, taxonIds);
        if (this.getTaxonConstraints() == null || taxonIds.contains(0)) {
            return log.exit(true);
        }
        if (taxonIds.isEmpty()) {
            throw log.throwing(new IllegalArgumentException("The provided Collection of taxon IDs " + 
                               "is empty, this method will always return false"));
        }
        Set<Integer> copiedTaxonIds = new HashSet<Integer>(taxonIds);
        Set<Integer> validSpecies = this.getTaxonConstraints().get(
                this.getOntologyUtils().getWrapper().getIdentifier(cls));
        if (validSpecies == null) {
            return log.exit(false);
        }
        copiedTaxonIds.retainAll(validSpecies);
        
        //if there is an intersection => valid cls
        return log.exit(!copiedTaxonIds.isEmpty());
    }

    /**
     * @return  A {@code String} that is the path to the file storing the Uberon ontology 
     *          (recommended version is OWL, but OBO versions can be used as well).
     * @see #setPathToUberonOnt(String)
     */
    public String getPathToUberonOnt() {
        return pathToUberonOnt;
    }
    /**
     * Sets the parameter returned by {@link #getPathToUberonOnt()}.
     * 
     * @param pathToUberonOnt   See {@link #getPathToUberonOnt()}.
     * @see #getPathToUberonOnt()
     */
    public void setPathToUberonOnt(String pathToUberonOnt) {
        this.pathToUberonOnt = pathToUberonOnt;
    }

    /**
     * @return  A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     *          in files (suffixes ".obo" and ".owl" will be automatically added).
     * @see #setModifiedOntPath(String)
     */
    public String getModifiedOntPath() {
        return modifiedOntPath;
    }
    /**
     * Sets the parameter returned by {@link #getModifiedOntPath()}.
     * 
     * @param modifiedOntPath   See {@link #getModifiedOntPath()}.
     * @see #getModifiedOntPath()
     */
    public void setModifiedOntPath(String modifiedOntPath) {
        this.modifiedOntPath = modifiedOntPath;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es to remove from the ontology, and to propagate 
     *          their incoming edges to their outgoing edges. Argument when calling 
     *          {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     * @see #setClassIdsToRemove(Collection)
     */
    public Collection<String> getClassIdsToRemove() {
        return classIdsToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getClassIdsToRemove()}.
     * 
     * @param classIdsToRemove  See {@link #getClassIdsToRemove()}.
     * @see #getClassIdsToRemove()
     */
    public void setClassIdsToRemove(Collection<String> classIdsToRemove) {
        this.classIdsToRemove = classIdsToRemove;
    }

    /**
     * @return  A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     *          Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     *          to remove, the associated value being a {@code Set} of {@code String}s 
     *          that are the OBO-like ID of the targets of the relations to remove.
     *          {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     *          for each key with each entry in the associated {@code Set}.
     * @see #setRelsBetweenToRemove(Map)
     */
    public Map<String, Set<String>> getRelsBetweenToRemove() {
        return relsBetweenToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getRelsBetweenToRemove()}.
     * 
     * @param relsBetweenToRemove   See {@link #getRelsBetweenToRemove()}.
     * @see #getRelsBetweenToRemove()
     */
    public void setRelsBetweenToRemove(Map<String, Set<String>> relsBetweenToRemove) {
        this.relsBetweenToRemove = relsBetweenToRemove;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     *          of relations to be filtered and mapped to parent relations. Argument when calling 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     *          with second argument {@code true}.
     * @see #setRelIds(Collection)
     */
    public Collection<String> getRelIds() {
        return relIds;
    }
    /**
     * Sets the parameter returned by {@link #getRelIds()}.
     * 
     * @param relIds    See {@link #getRelIds()}.
     * @see #getRelIds()
     */
    public void setRelIds(Collection<String> relIds) {
        this.relIds = relIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs 
     *          to be removed from the ontology. Classes part both of a subgraph to remove 
     *          and a subgraph not to be removed will be kept. 
     *          Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToRemoveSubgraphRootIds(Collection)
     */
    public Collection<String> getToRemoveSubgraphRootIds() {
        return toRemoveSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToRemoveSubgraphRootIds()}.
     * 
     * @param toRemoveSubgraphRootIds   See {@link #getToRemoveSubgraphRootIds()}.
     * @see #getToRemoveSubgraphRootIds()
     */
    public void setToRemoveSubgraphRootIds(
            Collection<String> toRemoveSubgraphRootIds) {
        this.toRemoveSubgraphRootIds = toRemoveSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     *          in the ontology. Their ancestors will be kept as well. Argument when calling 
     *          {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToFilterSubgraphRootIds(Collection)
     */
    public Collection<String> getToFilterSubgraphRootIds() {
        return toFilterSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToFilterSubgraphRootIds()}.
     * 
     * @param toFilterSubgraphRootIds   See {@link #getToFilterSubgraphRootIds()}.
     * @see #getToFilterSubgraphRootIds()
     */
    public void setToFilterSubgraphRootIds(
            Collection<String> toFilterSubgraphRootIds) {
        this.toFilterSubgraphRootIds = toFilterSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of subgraphs to ignore. 
     *          This is useful for instance for OBO GCI relations: they make use of taxon classes, 
     *          so that it is not possible to remove the taxonomy from the ontology; yet, 
     *          when inserting anatomy or developmental stages, we do not want to consider them; 
     *          the root of the taxonomy would then define a subgraph to ignore.
     * @see #setToIgnoreSubgraphRootIds(Collection)
     */
    public Collection<String> getToIgnoreSubgraphRootIds() {
        return toIgnoreSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToIgnoreSubgraphRootIds()}.
     * 
     * @param toIgnoreSubgraphRootIds   See {@link #getToIgnoreSubgraphRootIds()}.
     * @see #getToIgnoreSubgraphRootIds()
     */
    public void setToIgnoreSubgraphRootIds( Collection<String> toIgnoreSubgraphRootIds) {
        this.toIgnoreSubgraphRootIds = toIgnoreSubgraphRootIds;
    }
    
    /**
     * @return  A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     *          and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     *          in which the {@code OWLClass} exists. 
     */
    public Map<String, Set<Integer>> getTaxonConstraints() {
        return taxonConstraints;
    }
    /**
     * Set taxon constraints.
     * 
     * @param taxonConstraints  A {@code Map} where keys are OBO-like IDs of the Uberon 
     *                          {@code OWLClass}es, and values are {@code Set}s of 
     *                          {@code Integer}s containing the IDs of taxa 
     *                          in which the {@code OWLClass} exists. 
     */
    public void setTaxonConstraints(Map<String, Set<Integer>> taxonConstraints) {
        this.taxonConstraints = taxonConstraints;
    }
    
    /**
     * @return  A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es removed as a result of the simplification process, 
     *          the associated values being {@code String}s representing the reason 
     *          for the class removal.
     */
    public Map<String, String> getClassesRemoved() {
        return this.classesRemoved;
    }
    /**
     * @return  A {@code String} that is the path to the file that will store information about 
     *          the {@code OWLClass}es that were removed as a result of simplification.
     * @see #setClassesRemovedFilePath(String)
     */
    public String getClassesRemovedFilePath() {
        return classesRemovedFilePath;
    }
    /**
     * Sets the parameter returned by {@link #getClassesRemovedFilePath()}.
     * 
     * @param classesRemovedFilePath    See {@link #getClassesRemovedFilePath()}.
     * @see #getClassesRemovedFilePath()
     */
    public void setClassesRemovedFilePath(String classesRemovedFilePath) {
        this.classesRemovedFilePath = classesRemovedFilePath;
    }
    
    /**
     * @return  The {@code OntologyUtils} used by this object. 
     */
    public OntologyUtils getOntologyUtils() {
        return this.ontUtils;
    }
}
