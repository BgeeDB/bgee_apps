package org.bgee.pipeline.uberon;

import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Matcher;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.pipeline.CommandRunner;
import org.bgee.pipeline.OntologyUtils;
import org.bgee.pipeline.Utils;
import org.obolibrary.oboformat.parser.OBOFormatParserException;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLAnnotation;
import org.semanticweb.owlapi.model.OWLAnnotationProperty;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLLiteral;
import org.semanticweb.owlapi.model.OWLObject;
import org.semanticweb.owlapi.model.OWLObjectProperty;
import org.semanticweb.owlapi.model.OWLObjectPropertyExpression;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.semanticweb.owlapi.model.OWLOntologyStorageException;
import org.semanticweb.owlapi.model.OWLPropertyExpression;
import org.semanticweb.owlapi.model.UnknownOWLOntologyException;
import org.supercsv.cellprocessor.Optional;
import org.supercsv.cellprocessor.constraint.NotNull;
import org.supercsv.cellprocessor.constraint.UniqueHashCode;
import org.supercsv.cellprocessor.ift.CellProcessor;
import org.supercsv.io.CsvMapWriter;
import org.supercsv.io.ICsvMapWriter;

import owltools.graph.OWLGraphEdge;
import owltools.graph.OWLGraphWrapper;

/**
 * Class related to the use, and insertion into the database of the ontology Uberon.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
public class Uberon {
    /**
     * {@code Logger} of the class.
     */
    private final static Logger log = 
            LogManager.getLogger(Uberon.class.getName());
    
    /**
     * A {@code String} that is the name of the column containing the anatomical entity IDs 
     * (for instance, "UBERON:0001905") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String UBERON_ENTITY_ID_COL = "Uberon ID";
    /**
     * A {@code String} that is the name of the column containing the anatomical entity names 
     * (for instance, "pineal body") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String ANAT_ENTITY_NAME_COL = "Uberon name";
    /**
     * A {@code String} that is the name of the column containing the is_a/part_of relations 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String RELATIONS_COL = "is_a/part_of relations";
    /**
     * A {@code String} that is the name of the column containing the reason for the removal 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String REASON_FOR_REMOVAL = "Reason for removal";
    /**
     * A {@code String} that is the name of the column containing the IDs of the XRefs 
     * we want a mapping from, to Uberon IDs, in the file generated by 
     * {@link #saveXRefMappingsToFile(String, String)}.
     * 
     * @see #saveXRefMappingsToFile(String, String)
     */
    public static final String XREF_ID_COL = "XRef ID";
    
    /**
     * Several actions can be launched from this main method, depending on the first 
     * element in {@code args}: 
     * <ul>
     * <li>If the first element in {@code args} is "extractTaxonIds", the action 
     * will be to extract from the Uberon ontology all NCBI taxon IDs that are the targets 
     * of {@code OWLRestriction}s over the object properties "in taxon" (or any 
     * sub-properties), or that are used in ontology annotations 
     * "treat-xrefs-as-reverse-genus-differentia", and to write them in a file.
     * Following elements in {@code args} must then be: 
     *   <ol>
     *   <li>path to the Uberon ontology (a version making use of such restrictions...).
     *   <li>path to the output file where to write taxon IDs into, one per line.
     *   </ol>
     * <li>If the first element in {@code args} is "simplifyUberon", the action 
     * will be to simplify the Uberon ontology and to save it to files in OBO and OWL formats, 
     * see {@link #simplifyUberonAndSaveToFile()}.
     * Following elements in {@code args} must then be: 
     *   <ol>
     *   <li>path to the file storing the Uberon ontology, see {@link #setPathToUberonOnt(String)}.
     *   <li>path to use to generate the files storing the resulting 
     *   ontology in OBO and OWL. The prefixes ".owl" or ".obo" will be automatically added. 
     *   See {@link #setModifiedOntPath(String)}.
     *   <li>path to a file storing information about classes removed. 
     *   See {@link #setClassesRemovedFilePath(String)}.
     *   <li>A list of OBO-like IDs of {@code OWLClass}es to remove from the ontology, 
     *   and to propagate their incoming edges to their outgoing edges. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setClassIdsToRemove(Collection)}.
     *   <li>A list of OBO-like IDs or {@code IRI}s of relations to be filtered 
     *   and mapped to parent relations. These IDs must be separated by the {@code String} 
     *   {@link CommandRunner#LIST_SEPARATOR}. See {@link #setRelIds(Collection)}.
     *   <li>A list of OBO-like IDs of the {@code OWLClass}es that are the roots 
     *   of the subgraphs to be removed from the ontology. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setToRemoveSubgraphRootIds(Collection)}.
     *   <li>A list of OBO-like IDs of the {@code OWLClass}es that are the roots 
     *   of the subgraphs that will be kept in the ontology. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setToFilterSubgraphRootIds(Collection)}.
     *   <li>A list of names of targeted subsets, for which member {@code OWLClass}es 
     *   should have their is_a/part_of incoming edges removed. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setSubsetNames(Collection)}.
     *   <li>A list of OBO-like IDs of {@code OWLClass}es whose incoming edges 
     *   should not be removed, even if member of a subset listed in the previous argument. 
     *   See {@link #setClassIdsExcludedFromSubsetRemoval(Collection)}.
     *   <li>a map specifying specific relations to remove between pairs of {@code OWLClass}es. 
     *   In a key-value pair, the key should be the OBO-like ID of the source of relations 
     *   to remove, the value being the target of the relations to remove. Key-value pairs 
     *   must be separated by {@link CommandRunner#LIST_SEPARATOR}, keys must be  
     *   separated from their associated value by {@link CommandRunner#KEY_VALUE_SEPARATOR}. 
     *   A key can be associated to several values. See {@link #setRelsBetweenToRemove(Map)}.
     *   </ol>
     *   Example of command line usage for this task: {@code java -Xmx2g -jar myJar 
     *   Uberon simplifyUberon composite-metazoan.owl custom_composite simplification_composite.tsv 
     *   UBERON:0001062,UBERON:0000465,UBERON:0000061,UBERON:0010000,UBERON:0008979 
     *   BFO:0000050,RO:0002202,RO:0002494 
     *   UBERON:0000467/UBERON:0000468,UBERON:0000475/UBERON:0000468,UBERON:0000479/UBERON:0000468,UBERON:0000480/UBERON:0000468,UBERON:0007688/UBERON:0000468,UBERON:0010707/UBERON:0000468,UBERON:0012641/UBERON:0000468,UBERON:0002199/UBERON:0000468,UBERON:0002416/UBERON:0000468,UBERON:0007376/UBERON:0000468,UBERON:0000463/UBERON:0000468,UBERON:0001048/UBERON:0000468,UBERON:0007567/UBERON:0000468,UBERON:0015119/UBERON:0000468 
     *   NBO:0000313,GO:0008150,ENVO:01000254,BFO:0000040,GO:0003674,PATO:0000001,NCBITaxon:1,CHEBI:24431,UBERON:0004458,UBERON:0000466,SO:0000704 
     *   UBERON:0013701,UBERON:0000026,UBERON:0000480,UBERON:0000479,UBERON:0000468,GO:0005575 
     *   grouping_class,non_informative,ubprop:upper_level,upper_level 
     *   UBERON:0013701,UBERON:0000026,UBERON:0000480,UBERON:0000479,UBERON:0011676,GO:0005575}
     *   
     * <li>If the first element in {@code args} is "generateStageOntology", the action 
     * will be to extract from the Uberon ontology the developmental stages subgraph, 
     * and to save it to files in OBO and OWL formats, 
     * see {@link #generateStageOntologyAndSaveToFile()}.
     * Following elements in {@code args} must then be: 
     *   <ol>
     *   <li>path to the file storing the Uberon ontology, see {@link #setPathToUberonOnt(String)}.
     *   <li>path to use to generate the files storing the resulting 
     *   ontology in OBO and OWL. The prefixes ".owl" or ".obo" will be automatically added. 
     *   See {@link #setModifiedOntPath(String)}.
     *   <li>A list of OBO-like IDs of {@code OWLClass}es to remove from the ontology, 
     *   and to propagate their incoming edges to their outgoing edges. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setClassIdsToRemove(Collection)}.
     *   <li>A list of OBO-like IDs of {@code OWLClass}es for which we want to remove 
     *   all their children, reachable by any path in their graph closure. 
     *   The {@code OWLClass}es themselves will not be removed. 
     *   See {@link #setChildrenOfToRemove(Collection)}.
     *   <li>A list of OBO-like IDs or {@code IRI}s of relations to be filtered 
     *   and mapped to parent relations. These IDs must be separated by the {@code String} 
     *   {@link CommandRunner#LIST_SEPARATOR}. See {@link #setRelIds(Collection)}.
     *   <li>A list of OBO-like IDs of the {@code OWLClass}es that are the roots 
     *   of the subgraphs that will be kept in the ontology. These IDs must be 
     *   separated by the {@code String} {@link CommandRunner#LIST_SEPARATOR}. 
     *   See {@link #setToFilterSubgraphRootIds(Collection)}.
     *   </ol>
     *   Example of command line usage for this task: {@code java -Xmx2g -jar myJar 
     *   Uberon generateStageOntology ext.owl dev_stage_ont  
     *   UBERON:0000067,UBERON:0000071,UBERON:0000105,UBERON:0000000 
     *   UBERON:0000069 
     *   BFO:0000050,BFO:0000062
     *   UBERON:0000104,FBdv:00000000}
     *   
     * <li>If the first element in {@code args} is "extractXRefMappings", the action will be 
     * to retrieve mappings from XRef IDs to Uberon IDs from Uberon, and to save them 
     * to a TSV file, see {@link #saveXRefMappingsToFile(String, String)} for details.
     * Following elements in {@code args} must then be: 
     *   <ol>
     *   <li>path to the Uberon ontology.
     *   <li>path to the output file where to save the mappings.
     *   </ol>
     * </ul>
     * @param args  An {@code Array} of {@code String}s containing the requested parameters.
     * @throws IllegalArgumentException If {@code args} does not contain the proper 
     *                                  parameters or does not allow to obtain 
     *                                  correct information.
     */
    public static void main(String[] args) throws OWLOntologyCreationException, 
        OBOFormatParserException, IOException, IllegalArgumentException, 
        OWLOntologyStorageException {
        log.entry((Object[]) args);
        
        if (args[0].equalsIgnoreCase("extractTaxonIds")) {
            if (args.length != 3) {
                throw log.throwing(new IllegalArgumentException(
                        "Incorrect number of arguments provided, expected " + 
                        "3 arguments, " + args.length + " provided."));
            }
            
            new Uberon(args[1]).extractTaxonIds(args[2]);

// NOTE May 13 2014: this method seems now completely useless, to remove if it is confirmed.
//        } else if (args[0].equalsIgnoreCase("extractDevelopmentRelatedRelations")) {
//            if (args.length != 4) {
//                throw log.throwing(new IllegalArgumentException(
//                        "Incorrect number of arguments provided, expected " + 
//                        "4 arguments, " + args.length + " provided."));
//            }
//            
//            new Uberon().extractRelatedEdgesToOutputFile(args[1], args[2], args[3]);
            
        } else if (args[0].equalsIgnoreCase("simplifyUberon")) {
            if (args.length != 11) {
                throw log.throwing(new IllegalArgumentException(
                        "Incorrect number of arguments provided, expected " + 
                        "11 arguments, " + args.length + " provided."));
            }
            
            Uberon ub = new Uberon(args[1]);
            ub.setModifiedOntPath(args[2]);
            ub.setClassesRemovedFilePath(args[3]);
            ub.setClassIdsToRemove(CommandRunner.parseListArgument(args[4]));
            ub.setRelIds(CommandRunner.parseListArgument(args[5]));
            ub.setRelsBetweenToRemove(CommandRunner.parseMapArgument(args[6]));
            ub.setToRemoveSubgraphRootIds(CommandRunner.parseListArgument(args[7]));
            ub.setToFilterSubgraphRootIds(CommandRunner.parseListArgument(args[8]));
            ub.setSubsetNames(CommandRunner.parseListArgument(args[9]));
            ub.setClassIdsExcludedFromSubsetRemoval(CommandRunner.parseListArgument(args[10]));
            
            
            ub.simplifyUberonAndSaveToFile();
            
        } else if (args[0].equalsIgnoreCase("generateStageOntology")) {
            if (args.length != 7) {
                throw log.throwing(new IllegalArgumentException(
                        "Incorrect number of arguments provided, expected " + 
                        "7 arguments, " + args.length + " provided."));
            }
            
            Uberon ub = new Uberon(args[1]);
            ub.setModifiedOntPath(args[2]);
            ub.setClassIdsToRemove(CommandRunner.parseListArgument(args[3]));
            ub.setChildrenOfToRemove(CommandRunner.parseListArgument(args[4]));
            ub.setRelIds(CommandRunner.parseListArgument(args[5]));
            ub.setToFilterSubgraphRootIds(CommandRunner.parseListArgument(args[6]));
            
            
            ub.generateStageOntologyAndSaveToFile();
            
        } else if (args[0].equalsIgnoreCase("extractXRefMappings")) {
            if (args.length != 3) {
                throw log.throwing(new IllegalArgumentException(
                        "Incorrect number of arguments provided, expected " + 
                        "3 arguments, " + args.length + " provided."));
            }
            new Uberon(args[1]).saveXRefMappingsToFile(args[2]);
        } else {
            throw log.throwing(new UnsupportedOperationException("The following action " +
                    "is not recognized: " + args[0]));
        }
        
        log.exit();
    }
    
    /**
     * A {@code String} that is the path to the file storing the Uberon ontology 
     * (recommended version is OWL, but OBO versions can be used as well).
     */
    private String pathToUberonOnt;
    /**
     * A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     * in files (suffixes ".obo" and ".owl" will be automatically added).
     */
    private String modifiedOntPath;
    /**
     * A {@code String} that is the path to the file that will store information about 
     * the {@code OWLClass}es that were removed as a result of simplification.
     */
    private String classesRemovedFilePath;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs of {@code OWLClass}es 
     * to remove from the ontology, and to propagate their incoming edges 
     * to their outgoing edges. Argument when calling 
     * {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     */
    private Collection<String> classIdsToRemove;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     * of relations to be filtered and mapped to parent relations. Argument when calling 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     * with second argument {@code true}.
     */
    private Collection<String> relIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs 
     * to be removed from the ontology. Classes part both of a subgraph to remove 
     * and a subgraph not to be removed will be kept. 
     * Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toRemoveSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     * in the ontology. Their ancestors will be kept as well. Argument when calling 
     * {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toFilterSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the names of the targeted subsets, 
     * for which member {@code OWLClass}es should have their is_a/part_of 
     * incoming edges removed (only if the source of the incoming edge 
     * will not be left orphan of other is_a/part_of relations to {@code OWLClass}es 
     * not in {@code subsets}. First argument when calling 
     * {@code OWLGraphManipulator#removeRelsToSubsets(Collection, Collection)}.
     */
    private Collection<String> subsetNames;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of {@code OWLClass}es whose incoming edges should not be removed even if member 
     * of a subset listed in {@link #subsetNames}. Second argument when calling 
     * {@code OWLGraphManipulator#removeRelsToSubsets(Collection, Collection)}.
     */
    private Collection<String> classIdsExcludedFromSubsetRemoval;
    /**
     * A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     * Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     * to remove, the associated value being a {@code Set} of {@code String}s 
     * that are the OBO-like ID of the targets of the relations to remove.
     * {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     * for each key with each entry in the associated {@code Set}.
     */
    private Map<String, Set<String>> relsBetweenToRemove;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs of {@code OWLClass}es 
     * for which we want to remove all their children, reachable by any path 
     * in their graph closure. The {@code OWLClass}es will not be removed. 
     */
    private Collection<String> childrenOfToRemove;
    
    /**
     * A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     * of {@code OWLClass}es removed as a result of the simplification process, 
     * the associated values being {@code String}s representing the reason 
     * for the class removal.
     * <p>
     * Note: this could be represented in a better object-oriented way, but we just go 
     * fast and dirty for the pipeline.
     */
    private final Map<String, String> classesRemoved;
    
    /**
     * The {@code OntologyUtils} used to perform operations, wrapping the Uberon ontology 
     * that will be used. 
     */
    private final OntologyUtils ontUtils;
    
    /**
     * A {@code Set} of {@code OWLPropertyExpression} that can be conveniently used 
     * to query for relations and/or relatives only over part_of relations,
     */
    private final Set<OWLPropertyExpression> overPartOf;
    
    /**
     * Default constructor private in purpose, an ontology should always be provided somehow.
     */
    @SuppressWarnings("unused")
    private Uberon() {
        this((OntologyUtils) null);
    }
    
    /**
     * Constructor providing the path to the Uberon ontology to used to perforn operations.
     * 
     * @param pathToUberon  A {@code String} that is the path to the Uberon ontology. 
     * @throws OWLOntologyCreationException If an error occurred while loading the ontology.
     * @throws OBOFormatParserException     If the ontology is malformed.
     * @throws IOException                  If the file could not be read. 
     */
    public Uberon(String pathToUberon) throws OWLOntologyCreationException, 
    OBOFormatParserException, IOException {
        this(new OntologyUtils(pathToUberon));
    }
    /**
     * Constructor providing the {@code OntologyUtils} used to perform operations, 
     * wrapping the Uberon ontology that will be used. 
     * 
     * @param ontUtils  the {@code OntologyUtils} that will be used. 
     */
    public Uberon(OntologyUtils ontUtils) {
        this.classesRemoved = new HashMap<String, String>();
        this.ontUtils = ontUtils;
        this.overPartOf = Collections.unmodifiableSet(new HashSet<OWLPropertyExpression>(
                Arrays.asList(this.ontUtils.getWrapper().getOWLObjectPropertyByIdentifier(
                        OntologyUtils.PART_OF_ID))));
    }
    
    /**
     * Simplifies the Uberon ontology stored in the file provided through 
     * {@link #setPathToUberonOnt(String)}, and saves it in OWL and OBO format 
     * in the path provided through {@link #setModifiedOntPath(String)}. Information about 
     * the {@code OWLClass}es that were removed as a result of the simplification is stored 
     * in a separated file, provided through {@link #setClassesRemovedFilePath(String)} (see 
     * {@code #saveSimplificationInfo} method). This attribute can be left {@code null} 
     * or blank if this information does not need to be stored. 
     * <p>
     * This method calls {@link #simplifyUberon(OWLOntology)}, by loading the {@code OWLOntology} 
     * provided, and using attributes set before calling this method. Attributes that are used 
     * can be set prior to calling this method through the methods: 
     * {@link #setClassIdsToRemove(Collection)}, {@link #setToRemoveSubgraphRootIds(Collection)}, 
     * {@link #setToFilterSubgraphRootIds(Collection)}, {@link #setSubsetNames(Collection)}, 
     * {@link #setClassIdsExcludedFromSubsetRemoval(Collection)}, and 
     * {@link #setRelsBetweenToRemove(Map)}.
     * <p>
     * The resulting {@code OWLOntology} is then saved, in OBO (with a ".obo" extension 
     * to the path provided through {@link #setModifiedOntPath(String)}), 
     * and in OWL (with a ".owl" extension to the path {@link #setModifiedOntPath(String)}).
     * 
     * @throws IOException                      If an error occurred while reading the file 
     *                                          returned by {@link #getPathToUberonOnt()}.
     * @throws OBOFormatParserException         If the ontology was provided in OBO format 
     *                                          and a parser error occurred. 
     * @throws OWLOntologyCreationException     If an error occurred while loading 
     *                                          the ontology to modify it.
     * @throws UnknownOWLOntologyException      If an error occurred while loading 
     *                                          the ontology to modify it.
     * @throws OWLOntologyStorageException      If an error occurred while saving the resulting 
     *                                          ontology in OWL.
     * @see #simplifyUberon(OWLOntology)
     */
    public void simplifyUberonAndSaveToFile() throws UnknownOWLOntologyException, 
            OWLOntologyCreationException, OBOFormatParserException, IOException, 
            OWLOntologyStorageException {
        //we provide to the entry methods all class attributes that will be used 
        //(use to be arguments of this method)
        log.entry(this.getPathToUberonOnt(), this.getModifiedOntPath(), 
                this.getClassesRemovedFilePath(), this.getClassIdsToRemove(), 
                this.getRelsBetweenToRemove(), this.getRelIds(), 
                this.getToRemoveSubgraphRootIds(), 
                this.getToFilterSubgraphRootIds(), this.getSubsetNames(), 
                this.getClassIdsExcludedFromSubsetRemoval());
        
        this.simplifyUberon();

        //save ontology
        this.ontUtils.saveAsOWL(this.getModifiedOntPath() + ".owl");
        //we do not check the structure of the ontology to generate the OBO version, 
        //with the composite ontology there are too many problems.
        this.ontUtils.saveAsOBO(this.getModifiedOntPath() + ".obo", false);
        
        //save information about the simplification process if requested
        if (StringUtils.isNotBlank(this.getClassesRemovedFilePath())) {
            //we need the original ontology, as before the simplification, 
            //so we reload the ontology
            this.saveSimplificationInfo(OntologyUtils.loadOntology(this.getPathToUberonOnt()), 
                    this.getClassesRemovedFilePath(), this.getClassesRemoved());
        }
        
        log.exit();
    }
    
    /**
     * Simplifies {@code uberonOnt} by using an {@code OWLGraphManipulator}. This method 
     * calls various methods of {@code owltools.graph.OWLGraphManipulator} using the attributes 
     * set before calling this method, then removes the {@code OWLAnnotationAssertionAxiom}s 
     * that are problematic to convert the ontology in OBO, using 
     * {@link org.bgee.pipeline.OntologyUtils#removeOBOProblematicAxioms()}.
     * <p>
     * Note that the {@code OWLOntology} passed as argument will be modified as a result 
     * of the call to this method. Information about the simplification process 
     * can be retrieved afterwards, (see {@link #getClassesRemoved()}), or saved to a file (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * <p>
     * Operations that are performed, in order:
     * <ul>
     * <li>{@code OWLGraphManipulator#removeClassAndPropagateEdges(String)} on each of the 
     * {@code String} part of the {@code Collection} returned by {@link #getClassIdsToRemove()}.
     * <li>{@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)}, called for 
     * each {@code Entry}s in the {@code Map} returned by {@link #getRelsBetweenToRemove()}.
     * <li>{@code OWLGraphManipulator#reduceRelations()} and 
     * {@code OWLGraphManipulator#reducePartOfIsARelations()}
     * <li>{@code OWLGraphManipulator#mapRelationsToParent(Collection)} using value returned by 
     * {@link #getRelIds()}.
     * <li>{@code OWLGraphManipulator#filterRelations(Collection, boolean)} using value 
     * returned by {@link #getRelIds()}, with second argument {@code true}.
     * <li>{@code OWLGraphManipulator#removeSubgraphs(Collection, boolean, Collection)} 
     * with value returned by {@link #getToRemoveSubgraphRootIds()} as first argument, 
     * with second argument {@code true}, and with value returned by 
     * {@link #getToFilterSubgraphRootIds()} as third argument.
     * <li>{@code OWLGraphManipulator#filterSubgraphs(Collection)} with value returned by 
     * {@link #getToFilterSubgraphRootIds()}.
     * <li>{@code OWLGraphManipulator#removeRelsToSubsets(Collection, Collection)} using 
     * value returned by {@link #getSubsetNames()} as first argument, returned by 
     * {@link #getClassIdsExcludedFromSubsetRemoval()} as second argument.
     * <li>{@link org.bgee.pipeline.OntologyUtils#removeOBOProblematicAxioms()}
     * </ul>
     *  
     * @param uberonOnt                         The {@code OWLOntology} to simplify.
     * @throws UnknownOWLOntologyException      If an error occurred while wrapping 
     *                                          the {@code uberonOnt} into an 
     *                                          {@code OWLGraphManipulator}.
     */
    public void simplifyUberon() throws UnknownOWLOntologyException {
        //we provide to the entry methods all class attributes that will be used 
        //(use to be arguments of this method)
        log.entry(this.getClassIdsToRemove(), this.getRelsBetweenToRemove(), 
                this.getRelIds(), this.getToRemoveSubgraphRootIds(), 
                this.getToFilterSubgraphRootIds(), this.getSubsetNames(), 
                this.getClassIdsExcludedFromSubsetRemoval());
        
        OWLGraphManipulator manipulator = new OWLGraphManipulator(this.ontUtils.getWrapper());

        if (this.getClassIdsToRemove() != null) {
            for (String classIdToRemove: this.getClassIdsToRemove()) {
                manipulator.removeClassAndPropagateEdges(classIdToRemove);
            }
        }
        
        if (this.getRelsBetweenToRemove() != null) {
            for (Entry<String, Set<String>> relsToRemove: this.getRelsBetweenToRemove().entrySet()) {
                for (String targetId: relsToRemove.getValue()) {
                    manipulator.removeDirectEdgesBetween(relsToRemove.getKey(), targetId);
                }
            }
        }
        
        manipulator.reduceRelations();
        manipulator.reducePartOfIsARelations();
        
        if (this.getRelIds() != null && !this.getRelIds().isEmpty()) {
            manipulator.mapRelationsToParent(this.getRelIds());
            manipulator.filterRelations(this.getRelIds(), true);
        }
        
        if (this.getToRemoveSubgraphRootIds() != null) {
            for (String subgraphRootId: this.getToRemoveSubgraphRootIds()) {
                for (String classIdRemoved: 
                    manipulator.removeSubgraphs(Arrays.asList(subgraphRootId), true, 
                            this.getToFilterSubgraphRootIds())) {
                    this.classesRemoved.put(classIdRemoved, 
                            "Removal of subgraph with root ID " + subgraphRootId + 
                            " - subgraphs excluded from removal: " + 
                            this.getToFilterSubgraphRootIds());
                }
            }
        }
        if (this.getToFilterSubgraphRootIds() != null && 
                !this.getToFilterSubgraphRootIds().isEmpty()) {
            for (String classIdRemoved: 
                manipulator.filterSubgraphs(this.getToFilterSubgraphRootIds())) {
                this.classesRemoved.put(classIdRemoved, 
                        "Filtering of subgraph with root IDs: " + this.getToFilterSubgraphRootIds());
            }
        }
        if (this.getSubsetNames() != null && !this.getSubsetNames().isEmpty()) {
            manipulator.removeRelsToSubsets(this.getSubsetNames(), 
                    this.getClassIdsExcludedFromSubsetRemoval());
        }

        this.ontUtils.removeOBOProblematicAxioms();
        
        log.exit();
    }
    
    /**
     * Save information about the simplification process of the original 
     * {@code OWLOntology} {@code ont}. The information is provided through 
     * this method arguments: {@code classesRemoved} a listing of the {@code OWLClass}es 
     * that were removed as a result of the simplification performed by 
     * the {@code simplifyUberon} method, associated to the reason for removal. 
     * This information will be written to the file {@code subgraphFilteredFilePath}.
     * </ul>
     * <p>
     * If more information was to be stored in the future, it should be stored in separate 
     * files (thus, modifying this method signature).
     * 
     * @param ont                       The original {@code OWLOntology}, 
     *                                  as before simplification.
     * @param classesRemovedFilePath    A {@code String} that is the path to the file that will 
     *                                  store information about the {@code OWLClass}es 
     *                                  that were removed as a result of simplification.
     * @param classesRemoved            A {@code Collection} of {@code String}s that are 
     *                                  the OBO-like IDs of {@code OWLClass}es 
     *                                  removed as a result of simplification.
     * @throws IOException  If an error occurred while writing information.
     */
    public void saveSimplificationInfo(OWLOntology ont, String classesRemovedFilePath, 
            Map<String, String> classesRemoved) throws IOException {
        log.entry(ont, classesRemovedFilePath, classesRemoved);
        
        //get a OWLGraphWrapper to obtain information about classes
        OWLGraphWrapper wrapper = new OWLGraphWrapper(ont);
        //we will also need an OntologyUtils to retrieve is_a/part_of outgoing edges
        OntologyUtils utils = new OntologyUtils(wrapper);
        
        //Write IDs removed as a result of graph filtering
        //first, filter potential redundancy 
        Set<String> filteredIds = new HashSet<String>(classesRemoved.keySet());
        //then, order the IDs. 
        List<String> orderedIds = new ArrayList<String>(filteredIds);
        //To get a natural ordering
        Collections.sort(orderedIds, OntologyUtils.ID_COMPARATOR);
        //create the header of the file, and the conditions on the columns
        String[] header = new String[4];
        header[0] = UBERON_ENTITY_ID_COL;
        header[1] = ANAT_ENTITY_NAME_COL;
        header[2] = RELATIONS_COL;
        header[3] = REASON_FOR_REMOVAL;
        CellProcessor[] processors = new CellProcessor[4];
        //ID of the OWLClass (must be unique)
        processors[0] = new UniqueHashCode(new NotNull());
        //label of the OWLClass
        processors[1] = new NotNull();
        //is_a/part_of relations, can be empty if no relations
        processors[2] = new Optional();
        //reason for removal, there is always one
        processors[3] = new NotNull();
        
        try (ICsvMapWriter mapWriter = 
                new CsvMapWriter(new FileWriter(classesRemovedFilePath),
                Utils.TSVCOMMENTED)) {
            mapWriter.writeHeader(header);
            
            for (String uberonId: orderedIds) {
                OWLClass cls = wrapper.getOWLClassByIdentifier(uberonId);
                if (cls != null) {
                    //check that the class is not obsolete
                    if (wrapper.isObsolete(cls) || wrapper.getIsObsolete(cls)) {
                        continue;
                    }
                    //get the is_a/part_of relations, translated to a String
                    String relations = "";
                    for (OWLGraphEdge edge: utils.getIsAPartOfOutgoingEdges(cls)) {
                        if (!relations.equals("")) {
                            relations += " - ";
                        }
                        String relationType = "is_a";
                        if (edge.getSingleQuantifiedProperty().getProperty() != null) {
                            relationType = wrapper.getLabelOrDisplayId(
                                    edge.getSingleQuantifiedProperty().getProperty());
                        }
                        relations += relationType + " " + 
                                wrapper.getIdentifier(edge.getTarget()) + " " + 
                                wrapper.getLabelOrDisplayId(edge.getTarget());
                    }
                    
                    Map<String, Object> row = new HashMap<String, Object>();
                    row.put(header[0], uberonId);
                    row.put(header[1], wrapper.getLabelOrDisplayId(cls));
                    row.put(header[2], relations);
                    row.put(header[3], classesRemoved.get(uberonId));
                    
                    mapWriter.write(row, header, processors);
                } //else {
                    //we disable this assertion error, there are weird case 
                    //were getOWLClassByIdentifier does not find the OWLClass, 
                    //for instance, ID "biological:modeling".
                    //throw log.throwing(new AssertionError("Could not find class " +
                    //      "with ID " + uberonId));
                //}
            }
        }
        
        log.exit();
    }
    
    /**
     * Modify the Uberon ontology stored in the file provided through 
     * {@link #setPathToUberonOnt(String)} to make a deelopmental stage ontology, and saves it 
     * in OWL and OBO format in the path provided through {@link #setModifiedOntPath(String)}. 
     * <p>
     * This method calls {@link #generateStageOntology(OWLOntology)}, by loading the 
     * {@code OWLOntology} provided, and using attributes set before calling this method. 
     * Attributes that are used can be set prior to calling this method through the methods: 
     * {@link #setClassIdsToRemove(Collection)}, {@link #setToRemoveSubgraphRootIds(Collection)}, 
     * {@link #setToFilterSubgraphRootIds(Collection)}, and 
     * {@link #setChildrenOfToRemove(Collection)}.
     * <p>
     * The resulting {@code OWLOntology} is then saved, in OBO (with a ".obo" extension 
     * to the path provided through {@link #setModifiedOntPath(String)}), 
     * and in OWL (with a ".owl" extension to the path {@link #setModifiedOntPath(String)}).
     * 
     * @throws IOException                      If an error occurred while reading the file 
     *                                          {@code pathToUberonOnt}.
     * @throws OWLOntologyCreationException     If an error occurred while loading 
     *                                          the ontology to modify it.
     * @throws UnknownOWLOntologyException      If an error occurred while loading 
     *                                          the ontology to modify it.
     * @throws OWLOntologyStorageException      If an error occurred while saving the resulting 
     *                                          ontology in OWL.
     */
    public void generateStageOntologyAndSaveToFile() throws OWLOntologyCreationException, 
            IOException, IllegalArgumentException, OWLOntologyStorageException {
        //we provide to the entry methods all class attributes that will be used 
        //(use to be arguments of this method)
        log.entry(this.getPathToUberonOnt(), this.getModifiedOntPath(), 
                this.getClassIdsToRemove(), this.getChildrenOfToRemove(), 
                this.getRelIds(), this.getToFilterSubgraphRootIds());
        
        this.generateStageOntology();

        //save ontology
        this.ontUtils.saveAsOWL(this.getModifiedOntPath() + ".owl");
        this.ontUtils.saveAsOBO(this.getModifiedOntPath() + ".obo", false);
        
        log.exit();
    }
    
    /**
     * Generates a developmental stage ontology extracted from {@code uberonOnt}, then 
     * removes the {@code OWLAnnotationAssertionAxiom}s that are problematic to convert 
     * the ontology in OBO (using 
     * {@link org.bgee.pipeline.OntologyUtils#removeOBOProblematicAxioms()}). 
     * This method is very similar to {@link #simplifyUberon(OWLOntology)}, 
     * but the simplification process for the developmental stages is much simpler and faster. 
     * <p>
     * Note that the {@code OWLOntology} passed as argument will be modified as a result 
     * of the call to this method.
     * <p>
     * Operations that are performed, in order:
     * <ul>
     * <li>{@code OWLGraphManipulator#removeClassAndPropagateEdges(String)} on each of the 
     * {@code String} part of the {@code Collection} returned by {@link #getClassIdsToRemove()}.
     * <li>remove all children, reachable by any path in their graph closure, 
     * of the {@code OWLClass}es with their OBO-like IDs returned by {@link #getChildrenOfToRemove()}. 
     * <li>{@code OWLGraphManipulator#mapRelationsToParent(Collection)} using value returned by 
     * {@link #getRelIds()}.
     * <li>{@code OWLGraphManipulator#filterRelations(Collection, boolean)} using value 
     * returned by {@link #getRelIds()}, with second argument {@code true}.
     * <li>{@code OWLGraphManipulator#filterSubgraphs(Collection)} with value returned by 
     * {@link #getToFilterSubgraphRootIds()}.
     * <li>{@code OWLGraphManipulator#reducePartOfIsARelations()}
     * <li>{@link org.bgee.pipeline.OntologyUtils#removeOBOProblematicAxioms()}
     */
    public void generateStageOntology() {
        //we provide to the entry methods all class attributes that will be used 
        //(use to be arguments of this method)
        log.entry(this.getClassIdsToRemove(), this.getChildrenOfToRemove(), 
                this.getRelIds(), this.getToFilterSubgraphRootIds());
        
        OWLGraphManipulator manipulator = new OWLGraphManipulator(this.ontUtils.getWrapper());

        //potential terms to call this code on: 
        //UBERON:0000067 embryo stage part
        //UBERON:0000071 death stage
        //UBERON:0000105 life cycle stage
        //UBERON:0000000 processual entity
        for (String classIdToRemove: this.getClassIdsToRemove()) {
            manipulator.removeClassAndPropagateEdges(classIdToRemove);
        }
        
        //remove all children of childrenOfToRemove
        //potential terms to call this code on: UBERON:0000069 "larval stage"
        for (String parentId: this.getChildrenOfToRemove()) {
            OWLClass parent = manipulator.getOwlGraphWrapper().getOWLClassByIdentifier(parentId);
            //in case it was an IRI and not an OBO-like ID
            if (parent == null) {
                parent = manipulator.getOwlGraphWrapper().getOWLClass(parentId);
            }
            if (parent == null) {
                throw log.throwing(new IllegalArgumentException("A parent term whose children " +
                		"shoud be removed could not be found: " + parentId));
            }
            
            //remove children
            for (OWLClass child: manipulator.getOwlGraphWrapper().getOWLClassDescendants(parent)) {
                if (!manipulator.removeClass(child)) {
                    throw log.throwing(new AssertionError("An OWLClass could not be removed: " + 
                           child));
                }
                log.debug("Child of {} removed: {}", parent, child);
            } 
        }
        
        //potential rel IDs to keep: 
        //OntologyUtils.PART_OF_ID
        //OntologyUtils.PRECEDED_BY
        if (this.getRelIds() != null && !this.getRelIds().isEmpty()) {
            manipulator.mapRelationsToParent(this.getRelIds());
            manipulator.filterRelations(this.getRelIds(), true);
        }
        
        //potential subgraph root to keep: UBERON:0000104 life cycle, FBdv:00000000 Drosophila life 
        if (this.getToFilterSubgraphRootIds() != null && !this.getToFilterSubgraphRootIds().isEmpty()) {
            for (String classIdRemoved: manipulator.filterSubgraphs(toFilterSubgraphRootIds)) {
                this.classesRemoved.put(classIdRemoved, 
                        "Filtering of subgraph with root IDs" + toFilterSubgraphRootIds);
            }
        }   
        
        manipulator.reducePartOfIsARelations();
        
        this.ontUtils.removeOBOProblematicAxioms();
        
        log.exit();
    }
    
    /**
     * Compute a nested set model from a developmental stage ontology. The stage ontology 
     * should have been provided at instantiation. {@code root} will be considered 
     * as the root which to start nested set model computations from (as if it was 
     * the actual root of the ontology). {@code OWLClass}es will be ordered 
     * according to their immediately_preceded_by and preceded_by relations, and 
     * the nested set model computed using the method {@link 
     * org.bgee.pipeline.OntologyUtils#computeNestedSetModelParams(List)}.
     * 
     * @param root  An {@code OWLClass} that will be considered as the root of the ontology 
     *              to start the conputations from.
     * @return      See {@link org.bgee.pipeline.OntologyUtils#computeNestedSetModelParams(List)} 
     *              for details about values returned. 
     * @see org.bgee.pipeline.OntologyUtils#computeNestedSetModelParams(List)
     */
    public Map<OWLClass, Map<String, Integer>> generateStageNestedSetModel(OWLClass root) {
        log.entry(root);
        
        OWLGraphWrapper wrapper = this.ontUtils.getWrapper();
        
        //get the ordering between sibling OWLClasses according to preceded_by relations. 
        //This is enough to compute the nested set model. To do that, we walk each level 
        //starting from root, using a Deque
        Deque<OWLClass> walker = new ArrayDeque<OWLClass>();
        walker.add(root);
        //we don't care of the ordering of non-sibling taxa, 
        //as long as sibling taxa are ordered. 
        List<OWLClass> globalOrdering = new ArrayList<OWLClass>();
        OWLClass classWalked = null;
        while ((classWalked = walker.pollFirst()) != null) {
            //order the direct children
            Set<OWLClass> children = new HashSet<OWLClass>();
            for (OWLGraphEdge incomingEdge: wrapper.getIncomingEdges(classWalked)) {
                if (this.ontUtils.isPartOfRelation(incomingEdge) && 
                        incomingEdge.isSourceNamedObject()) {
                  
                    OWLClass child = (OWLClass) incomingEdge.getSource();
                    children.add(child);
                    walker.offerLast(child);
                }
            }
            if (!children.isEmpty()) {
                globalOrdering.addAll(this.orderByPrecededBy(children));
            }
        }
        
        return log.exit(this.ontUtils.computeNestedSetModelParams(root, globalOrdering, 
                this.overPartOf));
    }
    
    /**
     * Retrieve the OBO-like IDs of the developmental stages occurring between the stages 
     * with IDs {@code startStageId} and {@code endStageId}. To achieve this task, 
     * a nested set model is computed for the ontology wrapped by this object 
     * (provided before calling this method through {@link #setPathToUberonOnt(String)}), 
     * starting from the least common ancestor of the start and end stages, using 
     * part_of relations for ancestry between stages, and immediately_preceded_by 
     * and preceded_by for chronological relations between stages (see {@link 
     * #generateStageNestedSetModel(OWLClass)}). 
     * 
     * @param startStageId  A {@code String} that is the OBO-like ID of the start  
     *                      developmental stage.
     * @param endStageId    A {@code String} that is the OBO-like ID of the end  
     *                      developmental stage.
     * @return              A {@code List} of {@code String}s that are the OBO-like IDs 
     *                      of stages occurring between start and end stages, ordered 
     *                      by chronological order. 
     * @see #generateStageNestedSetModel(OWLClass)
     */
    public List<String> getStageIdsBetween(String startStageId, String endStageId) {
        log.entry(startStageId, endStageId);
        
        List<String> stageIdsBetween = new ArrayList<String>();
        OWLGraphWrapper wrapper = this.ontUtils.getWrapper();

        OWLClass startStage = this.ontUtils.getOWLClass(startStageId);
        OWLClass endStage = this.ontUtils.getOWLClass(endStageId);
        if (startStage == null) {
            throw log.throwing(new IllegalArgumentException("Could not find any OWLClass " +
            		"corresponding to " + startStageId));
        }
        if (endStage == null) {
            throw log.throwing(new IllegalArgumentException("Could not find any OWLClass " +
                    "corresponding to " + endStageId));
        }
        
        //identity case
        if (startStage.equals(endStage)) {
            stageIdsBetween.add(startStageId);
        } else {
            
            //first, get the least common ancestor of the two stages over part_of relation
            Set<OWLClass> lcas = this.ontUtils.getLeastCommonAncestors(startStage, endStage, 
                    this.overPartOf);
            
            //the part_of graph should be a tree, so, only one OWLClass lca
            if (lcas.size() != 1) {
                throw log.throwing(new IllegalStateException("The developmental stages " +
                		"used does not represent a tree over part_of relations, " +
                		"cannot continue. Least common ancestors of start and end stages :" + 
                		lcas));
            }
            OWLClass lca = lcas.iterator().next();
            
            //now we obtain a nested set model starting from this LCA
            //this nested set model will be used in a comparator, we make it final.
            final Map<OWLClass, Map<String, Integer>> nestedModel = 
                    this.generateStageNestedSetModel(lca);
            //get the parameters related to startStage and endStage
            int startLeftBound = nestedModel.get(startStage).get(OntologyUtils.LEFT_BOUND_KEY);
            int startRightBound = nestedModel.get(startStage).get(OntologyUtils.RIGHT_BOUND_KEY);
            int startLevel = nestedModel.get(startStage).get(OntologyUtils.LEVEL_KEY);
            int endLeftBound = nestedModel.get(endStage).get(OntologyUtils.LEFT_BOUND_KEY);
            int endRightBound = nestedModel.get(endStage).get(OntologyUtils.RIGHT_BOUND_KEY);
            int endLevel = nestedModel.get(endStage).get(OntologyUtils.LEVEL_KEY);
            int maxLevel = Math.max(startLevel, endLevel);
            
            //now we get all stages between start and end stages, with a level not greater 
            //than the max level between start and end stage. 
            Set<OWLClass> selectedStages = new HashSet<OWLClass>();
            for (Entry<OWLClass, Map<String, Integer>> entry: nestedModel.entrySet()) {
                OWLClass stage = entry.getKey();
                Map<String, Integer> params = entry.getValue();
                if (params.get(OntologyUtils.LEFT_BOUND_KEY) >= startLeftBound && 
                        params.get(OntologyUtils.LEFT_BOUND_KEY) <= endLeftBound && 
                    params.get(OntologyUtils.RIGHT_BOUND_KEY) >= startRightBound && 
                            params.get(OntologyUtils.RIGHT_BOUND_KEY) <= endRightBound && 
                    params.get(OntologyUtils.LEVEL_KEY) <= maxLevel) {
                    
                    selectedStages.add(stage);
                }
            }
            
            //now remove the ancestors of the selected stages, so that we keep only 
            //the most precise and independent selected stages
            Set<OWLObject> ancestors = new HashSet<OWLObject>();
            for (OWLClass selectedStage: selectedStages) {
                ancestors.addAll(wrapper.getAncestors(selectedStage, this.overPartOf));
            }
            selectedStages.removeAll(ancestors);
            
            //finally, order the stages using their left bound
            List<OWLClass> sortedStages = new ArrayList<OWLClass>(selectedStages);
            Collections.sort(sortedStages, new Comparator<OWLClass>() {
                @Override
                public int compare(OWLClass o1, OWLClass o2) {
                    return nestedModel.get(o1).get(OntologyUtils.LEFT_BOUND_KEY) - 
                            nestedModel.get(o2).get(OntologyUtils.LEFT_BOUND_KEY);
                }
              });
            
            //transform the List of OWLClasses into a List of Strings
            for (OWLClass sortedStage: sortedStages) {
                stageIdsBetween.add(wrapper.getIdentifier(sortedStage));
            }
        }
        
        return log.exit(stageIdsBetween);
    }
    
    /**
     * Order the provided {@code OWLClass}es according to their immediately_preceded_by 
     * or preceded_by relations. Usually, {@code classesToOrder} should contain sibling 
     * {@code OWLClass}es, direct descendants of a same {@code OWLClass} by part_of relations.
     * But it can be used with any {@code Set} of {@code OWLClass}es, as long as relations 
     * are consistent (no cycles of preceded_by, no missing preceded_by between the provided 
     * {@code OWLClass}es, etc).
     * 
     * @param classesToOrder    A {@code Set} of {@code OWLClass}es to order according to 
     *                          their immediately_preceded_by or preceded_by relations.
     * @return                  A {@code List} where {@code OWLClass}es are ordered, with 
     *                          first occurring {@code OWLClass} at first position, last 
     *                          occurring {@code OWLClass} at last position.
     */
    public List<OWLClass> orderByPrecededBy(Set<OWLClass> classesToOrder) {
        log.entry(classesToOrder);
        
        OWLGraphWrapper wrapper = this.ontUtils.getWrapper();
        List<OWLClass> orderedClasses = new ArrayList<OWLClass>();
        
        //first, we look for the last class, the only one with no preceded_by  
        //or immediately_preceded_by relations incoming from other OWLClass in classesToOrder. 
        //the subtlety is that the incoming preceded_by relation can actually be propagated 
        //from a child.
        Set<OWLClass> withSuccessors = new HashSet<OWLClass>();
        for (OWLClass classToOrder: classesToOrder) {
            log.trace("Examining OWLClass {}", classToOrder);
            for (OWLGraphEdge outgoingEdge: wrapper.getOutgoingEdges(classToOrder)) {
                log.trace("Testing if edge is valid preceded_by relation: {}", 
                        outgoingEdge);
                if (this.ontUtils.isPrecededByRelation(outgoingEdge)) {
                    OWLClass predecessor = this.getEqualOrParentBelongingTo(
                            outgoingEdge.getTarget(), classesToOrder);
                    if (predecessor != null) {
                        withSuccessors.add(predecessor);
                        log.trace("Valid preceded_by relation leading to predecessor: {}", 
                                predecessor);
                    }
                }
            }
        }
        log.trace("All classes with successors: {}", withSuccessors);
        
        Set<OWLClass> classesSubstracted = new HashSet<OWLClass>(classesToOrder);
        classesSubstracted.removeAll(withSuccessors);
        if (classesSubstracted.size() > 1) {
            throw log.throwing(new IllegalStateException("The provided ontology " +
                    "is missing some preceded_by relations: several OWLClasses " +
                    "with no preceded_by relations incoming from same level OWLClasses " +
                    "among the following: " + classesToOrder));
        }
        if (classesSubstracted.isEmpty()) {
            throw log.throwing(new IllegalStateException("Cycle of preceded_by relations " +
                    "among same level OWLClasses, not possible to determine the last one, " +
                    "among: " + classesToOrder));
        }
        OWLClass lastClass = classesSubstracted.iterator().next();
        log.debug("Last class of the chain identified: {}", lastClass);
        
        //now, we walk from lastClass, following the preceded_by relations
        OWLClass precedingClass = lastClass;
        while (precedingClass != null) {
            log.debug("Walking {}", precedingClass);
            
            if (orderedClasses.contains(precedingClass)) {
                throw log.throwing(new IllegalStateException("Cycle of preceded_by relations " +
                		"among the following OWLClasses: " + classesToOrder));
            }
            
            orderedClasses.add(0, precedingClass);
            
            //we check everything even if we have reached the beginning of the chain 
            //(classesToOrder.size() == orderedClasses.size()), to be sure there is 
            //no cycle of preceded_by relations
            OWLClass potentialPrecedingClass = null;
            
            //check first the immediately_preceded_by relations, there should be only one 
            //leading to sibling OWLClasses
            for (OWLGraphEdge outgoingEdge: wrapper.getOutgoingEdges(precedingClass)) {
                if (this.ontUtils.isImmediatelyPrecededByRelation(outgoingEdge)) {
                    
                    OWLClass clsMatching = this.getEqualOrParentBelongingTo(
                            outgoingEdge.getTarget(), classesToOrder);
                    if (clsMatching == null) {
                        continue;
                    }
                    
                    if (potentialPrecedingClass != null) {
                        //several immediately_preceded_by relations leading to 
                        //different OWLClasses
                        throw log.throwing(new IllegalStateException(
                                "An OWLClass has several " +
                                        "immediately_preceded_by relations to several same level " +
                                        "OWLClasses (" + precedingClass + "), among the following " +
                                        "OWLClasses: " + classesToOrder));
                    }
                    potentialPrecedingClass = clsMatching;
                    log.debug("Preceding class found by immediately_preceded_by: {}", 
                            potentialPrecedingClass);
                    //continue iteration anyway to check for several immediately_preceded_by
                }
            }
            
            //no immediately_preceded_by to sibling OWLClasses, maybe we have 
            //simple preceded_by relations?
            if (potentialPrecedingClass == null) {
                log.debug("No preceding class identified by immediately_preceded_by, checking preceded_by");
                //iterate once again the outgoing edges
                for (OWLGraphEdge outgoingEdge: wrapper.getOutgoingEdges(precedingClass)) {
                    //but check also for simple preceded_by relations 
                    if (this.ontUtils.isPrecededByRelation(outgoingEdge)) {
                        
                        OWLClass clsMatching = this.getEqualOrParentBelongingTo(
                                outgoingEdge.getTarget(), classesToOrder);
                        if (clsMatching == null) {
                            continue;
                        }
                        
                        if (potentialPrecedingClass != null) {
                            //several preceded_by relations leading to different OWLClasses, 
                            //while there is no immediately_preceded_by
                            throw log.throwing(new IllegalStateException("An OWLClass has several " +
                                    "preceded_by relations leading to several same level " +
                                    "OWLClasses, while it has no immediately_preceded_by " +
                                    "relations to these same level OWLClasses (" +
                                    precedingClass + "). Problem among " +
                                    "the following OWLClasses: " + classesToOrder));
                        }
                        potentialPrecedingClass = clsMatching;
                        log.debug("Preceding class found by preceded_by: {}", 
                                potentialPrecedingClass);
                        //continue iteration anyway to check for several preceded_by
                    }
                }
            }
            
            //here, it means we have reached the beginning of the chain, 
            //otherwise it means we have a problem
            if (potentialPrecedingClass == null && 
                    classesToOrder.size() != orderedClasses.size()) {
                throw log.throwing(new IllegalStateException("An OWLClass has no preceded_by " +
                		"relations to same level OWLClasses (" + precedingClass + "), " +
                	    "among the following " + classesToOrder));
            }
            
            precedingClass = potentialPrecedingClass;
        }
        
        return log.exit(orderedClasses);
    }
    
    /**
     * Tests if {@code cls} is included in {@code classes} or is a child of one of 
     * the {@code OWLClass}es in {@code classes} through part_of relations. 
     * {@code classes} should represent sibling terms, member of a single partonomy tree.
     * 
     * @param cls       An {@code OWLObject} needed to be checked whether it belongs to 
     *                  {@code classes}, itself or one of its ancestor through part_of relations.
     * @param classes   A {@code Set} of {@code OWLClass}es for which we want to know 
     *                  if {@code cls} is a member, or is a child through part_of relations 
     *                  of one of the members.
     * @return          {@code true} if {@code cls} belongs to {@code classes}, or is a child 
     *                  through part_of relations of a member of {@code classes}.
     */
    private OWLClass getEqualOrParentBelongingTo(OWLObject cls, Set<OWLClass> classes) {
        log.entry(cls, classes);
        
        if (classes.contains(cls)) {
            return log.exit((OWLClass) cls);
        }
        //test if cls is a child of one of the OWLClasses in classes
        Set<OWLObject> partOfAncestors = this.ontUtils.getWrapper().getAncestors(cls, 
                this.overPartOf);
        partOfAncestors.retainAll(classes);
        //classes should represent sibling terms member of a single partonomy tree, 
        //so partOfAncestors should now contain at most 1 element.
        if (partOfAncestors.size() > 1) {
            throw log.throwing(new IllegalStateException("The OWLClasses provided " +
            		"are not sibling terms, or are not part of a single partonomy tree: " + 
                    classes));
        }
        if (!partOfAncestors.isEmpty()) {
            return log.exit((OWLClass) partOfAncestors.iterator().next());
        }
        return log.exit(null);
    }
    
    /**
     * Extract from the Uberon ontology all NCBI taxon IDs that are the targets 
     * of {@code OWLRestriction}s over the object properties "in taxon" (or any 
     * sub-properties), or that are used in ontology annotations 
     * "treat-xrefs-as-reverse-genus-differentia", and to write them in a file.
     * The IDs used are {@code Integer}s that are the NCBI IDs (for instance, 
     * 9606 for human), not the ontology IDs with a prefix ("NCBITaxon:").
     * 
     * @param outputFile    A {@code String} that is the path to the file where 
     *                      to write IDs into.
     * @throws IllegalArgumentException     If {@code uberonFile} did not allow to obtain 
     *                                      any valid taxon ID, or was incorrectly formatted.
     * @throws OWLOntologyCreationException If an error occurred while loading 
     *                                      the ontology.
     * @throws OBOFormatParserException     If an error occurred while loading 
     *                                      the ontology.
     * @throws IOException                  If {@code uberonFile} could not be read, 
     *                                      or the output could not be written in file.
     */
    public void extractTaxonIds(String outputFile) 
            throws IllegalArgumentException, IOException {
        log.entry(outputFile);
        
        Set<Integer> taxonIds = this.extractTaxonIds();
        try(PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream(outputFile), "utf-8")))) {
            for (int taxonId: taxonIds) {
                writer.println(taxonId);
            }
        }
        
        log.exit();
    }
    
    /**
     * Extract from the Uberon ontology all taxon IDs that are the targets 
     * of {@code OWLRestriction}s over the object properties "in taxon" (or any 
     * sub-properties), or that are used in ontology annotations 
     * "treat-xrefs-as-reverse-genus-differentia". The IDs returned are {@code Integer}s 
     * that are the NCBI IDs (for instance, 9606 for human), not the ontology IDs 
     * with a prefix ("NCBITaxon:").
     * 
     * @return              A {@code Set} of {@code Integer}s that are the NCBI IDs 
     *                      of the taxa used in Uberon as target of restrictions over 
     *                      "in taxon" object properties, or any sub-properties.
     * @throws IllegalArgumentException     If {@code uberonFile} did not allow to obtain 
     *                                      any valid taxon ID or was incorrectly formatted.
     * @throws OWLOntologyCreationException If an error occurred while loading 
     *                                      the ontology.
     * @throws OBOFormatParserException     If an error occurred while loading 
     *                                      the ontology.
     * @throws IOException                  If {@code uberonFile} could not be read.
     */
    public Set<Integer> extractTaxonIds() throws IllegalArgumentException {
        log.entry();

        OWLOntology ont = this.ontUtils.getWrapper().getSourceOntology();
        OWLGraphWrapper wrapper = this.ontUtils.getWrapper();
        
        Set<String> taxonIds = new HashSet<String>();
        
        //will get taxon IDs from axioms over object properties "in_taxon", 
        //"evolved_multiple_times_in" (or any sub-properties)
        Set<OWLObjectPropertyExpression> objectProps = this.getTaxonObjectProperties(wrapper);
        //will also get the taxon IDs from annotation axioms over annotation properties
        //"ambiguous_for_taxon", "dubious_for_taxon", "homologous_in","never_in_taxon", 
        //"RO:0002161", "present_in_taxon", "taxon" (or any sub-properties)
        Set<OWLAnnotationProperty> annotProps = this.getTaxonAnnotationProperties(wrapper);
        
        for (OWLClass cls: ont.getClassesInSignature()) {
            //try to get taxa from any object properties that can lead to a taxon
            for (OWLGraphEdge edge: wrapper.getOutgoingEdges(cls)) {
                
                if (!edge.getQuantifiedPropertyList().isEmpty() && 
                    edge.getFinalQuantifiedProperty().isSomeValuesFrom() && 
                    objectProps.contains(edge.getFinalQuantifiedProperty().getProperty()) && 
                    edge.getTarget() instanceof OWLClass) {
                    log.trace("Taxon {} captured through object property in axiom {}", 
                            edge.getTarget(), edge.getAxioms());
                    taxonIds.add(wrapper.getIdentifier(edge.getTarget()));
                }
            }
            //and from any annotation properties that can lead to a taxon
            for (OWLAnnotation annot: cls.getAnnotations(ont)) {
                if (annotProps.contains(annot.getProperty()) && 
                    annot.getValue() instanceof IRI) {
                    log.trace("Taxon {} captured through annotation property in annotation {}", 
                            annot.getValue(), annot);
                    taxonIds.add(wrapper.getIdentifier(annot.getValue()));
                }
            }
        }
        
        //now we get the "treat-xrefs-as-reverse-genus-differentia" ontology annotations
        OWLAnnotationProperty genusDifferentia = wrapper.getManager().getOWLDataFactory().
                getOWLAnnotationProperty(OntologyUtils.GENUS_DIFFERENTIA_IRI);
        for (OWLAnnotation annot: ont.getAnnotations()) {
            if (annot.getProperty().equals(genusDifferentia)) {
                String value = ((OWLLiteral) annot.getValue()).getLiteral();
                Matcher m = OntologyUtils.GENUS_DIFFERENTIA_LITERAL_PATTERN.matcher(value);
                if (m.matches()) {
                    String taxId = m.group(OntologyUtils.GENUS_DIFFERENTIA_TAXON_GROUP);
                    log.trace("Taxon {} captured through treat-xrefs-as-reverse-genus-differentia {}", 
                            taxId, value);
                    taxonIds.add(m.group(OntologyUtils.GENUS_DIFFERENTIA_TAXON_GROUP));
                } else {
                    throw log.throwing(new IllegalArgumentException("The provided ontology " +
                    		"contains genus-differentia annotations that does not match " +
                    		"the expected pattern"));
                }
            }
        }
        
        
        if (taxonIds.isEmpty()) {
            throw log.throwing(new IllegalArgumentException("The provided ontology " +
                    " did not allow to acquire any taxon ID"));
        }
        return log.exit(OntologyUtils.convertToNcbiIds(taxonIds));
    }
    
    /**
     * @return  A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es removed as a result of the simplification process, 
     *          the associated values being {@code String}s representing the reason 
     *          for the class removal.
     */
    public Map<String, String> getClassesRemoved() {
        return this.classesRemoved;
    }
    
    /**
     * Retrieves mappings from XRef IDs to Uberon IDs from the Uberon ontology, and save them 
     * to {@code outputFile}. {@code outputFile} will be a TSV file with a header, 
     * and two columns, that are in order: {@link #XREF_ID_COL} and 
     * {@link #UBERON_ENTITY_ID_COL}. The XRef mappings are obtained using the method 
     * {@link org.bgee.pipeline.OntologyUtils#getXRefMappings()}.
     * 
     * @param outputFile        A {@code String} that is the path to the generated output file.
     * @throws IOException      If an error occurred while writing in the output file, 
     *                          or when reading the ontology file.
     * @throws OBOFormatParserException     If {@code pathToUberonOnt} was in OBO and could not 
     *                                      be parsed.
     * @throws OWLOntologyCreationException If {@code pathToUberonOnt} was in OWL and could not 
     *                                      be parsed.
     * 
     * @see org.bgee.pipeline.OntologyUtils#getXRefMappings()
     */
    public void saveXRefMappingsToFile(String outputFile) 
            throws IOException {
        log.entry(outputFile);
        
        //create the header of the file, and the conditions on the columns
        String[] header = new String[2];
        header[0] = XREF_ID_COL;
        header[1] = UBERON_ENTITY_ID_COL;
        CellProcessor[] processors = new CellProcessor[2];
        processors[0] = new NotNull();
        processors[1] = new NotNull();
        
        try (ICsvMapWriter mapWriter = new CsvMapWriter(new FileWriter(outputFile),
                Utils.TSVCOMMENTED)) {
            
            mapWriter.writeHeader(header);
            
            for (Entry<String, Set<String>> mappings: 
                this.ontUtils.getXRefMappings().entrySet()) {
                for (String uberonId: mappings.getValue()) {
                    Map<String, Object> row = new HashMap<String, Object>();
                    row.put(header[0], mappings.getKey());
                    row.put(header[1], uberonId);
                    mapWriter.write(row, header, processors);
                }
            }
        }
        
        log.exit();
    }

    /**
     * Obtain from the {@code OWLOntology} wrapped into {@code wrapper} all its 
     * {@code OWLObjectProperty}s that can lead to {@code OWLClass}es representing taxa.
     * 
     * @param wrapper   The {@code OWLGraphWrapper} to use to obtain the object properties.
     * @return          A {@code Set} of {@code OWLObjectPropertyExpression}s that 
     *                  can be used to retrieve {@code OWLClass}es representing taxa.
     */
    private Set<OWLObjectPropertyExpression> getTaxonObjectProperties(OWLGraphWrapper wrapper) {
        log.entry(wrapper);
        
        //get object properties "in_taxon" and "evolved_multiple_times_in", 
        //and any sub-properties
        OWLDataFactory factory = wrapper.getManager().getOWLDataFactory();
        Set<OWLObjectPropertyExpression> objectProps = 
                new HashSet<OWLObjectPropertyExpression>();
        
        OWLObjectProperty inTaxon = 
                factory.getOWLObjectProperty(OntologyUtils.IN_TAXON_IRI);
        if (inTaxon != null) {
            objectProps.addAll(wrapper.getSubPropertyReflexiveClosureOf(inTaxon));
        }
        
        OWLObjectProperty evolved = 
                factory.getOWLObjectProperty(OntologyUtils.EVOLVED_MULTIPLE_TIMES_IRI);
        if (evolved != null) {
            objectProps.addAll(wrapper.getSubPropertyReflexiveClosureOf(evolved));
        }
        
        return log.exit(objectProps);
    }
    
    /**
     * Obtain from the {@code OWLOntology} wrapped into {@code wrapper} all its 
     * {@code OWLAnnotationProperty}s that can lead to {@code OWLClass}es representing taxa.
     * 
     * @param wrapper   The {@code OWLGraphWrapper} to use to obtain the annotation properties.
     * @return          A {@code Set} of {@code OWLAnnotationProperty}s that can be used 
     *                  to retrieve {@code OWLClass}es representing taxa.
     */
    private Set<OWLAnnotationProperty> getTaxonAnnotationProperties(OWLGraphWrapper wrapper) {
        log.entry(wrapper);
        
        //get object properties "ambiguous_for_taxon", "dubious_for_taxon", 
        //"homologous_in","never_in_taxon", "RO:0002161", "present_in_taxon", 
        //"taxon", and any sub-properties
        OWLDataFactory factory = wrapper.getManager().getOWLDataFactory();
        Set<OWLAnnotationProperty> annotProps = new HashSet<OWLAnnotationProperty>();
        
        OWLAnnotationProperty prop = 
                factory.getOWLAnnotationProperty(OntologyUtils.AMBIGUOUS_FOR_TAXON_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.DUIOUS_FOR_TAXON_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.HOMOLOGOUS_IN_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.NEVER_IN_TAXON_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.NEVER_IN_TAXON_BIS_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.PRESENT_IN_TAXON_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        prop = factory.getOWLAnnotationProperty(OntologyUtils.TAXON_IRI);
        if (prop != null) {
            annotProps.addAll(wrapper.getSubAnnotationPropertyReflexiveClosureOf(prop));
        }
        
        return log.exit(annotProps);
    }

    /**
     * @return  A {@code String} that is the path to the file storing the Uberon ontology 
     *          (recommended version is OWL, but OBO versions can be used as well).
     * @see #setPathToUberonOnt(String)
     */
    public String getPathToUberonOnt() {
        return pathToUberonOnt;
    }
    /**
     * Sets the parameter returned by {@link #getPathToUberonOnt()}.
     * 
     * @param pathToUberonOnt   See {@link #getPathToUberonOnt()}.
     * @see #getPathToUberonOnt()
     */
    public void setPathToUberonOnt(String pathToUberonOnt) {
        this.pathToUberonOnt = pathToUberonOnt;
    }

    /**
     * @return  A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     *          in files (suffixes ".obo" and ".owl" will be automatically added).
     * @see #setModifiedOntPath(String)
     */
    public String getModifiedOntPath() {
        return modifiedOntPath;
    }
    /**
     * Sets the parameter returned by {@link #getModifiedOntPath()}.
     * 
     * @param modifiedOntPath   See {@link #getModifiedOntPath()}.
     * @see #getModifiedOntPath()
     */
    public void setModifiedOntPath(String modifiedOntPath) {
        this.modifiedOntPath = modifiedOntPath;
    }

    /**
     * @return  A {@code String} that is the path to the file that will store information about 
     *          the {@code OWLClass}es that were removed as a result of simplification.
     * @see #setClassesRemovedFilePath(String)
     */
    public String getClassesRemovedFilePath() {
        return classesRemovedFilePath;
    }
    /**
     * Sets the parameter returned by {@link #getClassesRemovedFilePath()}.
     * 
     * @param classesRemovedFilePath    See {@link #getClassesRemovedFilePath()}.
     * @see #getClassesRemovedFilePath()
     */
    public void setClassesRemovedFilePath(String classesRemovedFilePath) {
        this.classesRemovedFilePath = classesRemovedFilePath;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es to remove from the ontology, and to propagate 
     *          their incoming edges to their outgoing edges. Argument when calling 
     *          {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     * @see #setClassIdsToRemove(Collection)
     */
    public Collection<String> getClassIdsToRemove() {
        return classIdsToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getClassIdsToRemove()}.
     * 
     * @param classIdsToRemove  See {@link #getClassIdsToRemove()}.
     * @see #getClassIdsToRemove()
     */
    public void setClassIdsToRemove(Collection<String> classIdsToRemove) {
        this.classIdsToRemove = classIdsToRemove;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     *          of relations to be filtered and mapped to parent relations. Argument when calling 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     *          with second argument {@code true}.
     * @see #setRelIds(Collection)
     */
    public Collection<String> getRelIds() {
        return relIds;
    }
    /**
     * Sets the parameter returned by {@link #getRelIds()}.
     * 
     * @param relIds    See {@link #getRelIds()}.
     * @see #getRelIds()
     */
    public void setRelIds(Collection<String> relIds) {
        this.relIds = relIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs 
     *          to be removed from the ontology. Classes part both of a subgraph to remove 
     *          and a subgraph not to be removed will be kept. 
     *          Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToRemoveSubgraphRootIds(Collection)
     */
    public Collection<String> getToRemoveSubgraphRootIds() {
        return toRemoveSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToRemoveSubgraphRootIds()}.
     * 
     * @param toRemoveSubgraphRootIds   See {@link #getToRemoveSubgraphRootIds()}.
     * @see #getToRemoveSubgraphRootIds()
     */
    public void setToRemoveSubgraphRootIds(
            Collection<String> toRemoveSubgraphRootIds) {
        this.toRemoveSubgraphRootIds = toRemoveSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     *          in the ontology. Their ancestors will be kept as well. Argument when calling 
     *          {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToFilterSubgraphRootIds(Collection)
     */
    public Collection<String> getToFilterSubgraphRootIds() {
        return toFilterSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToFilterSubgraphRootIds()}.
     * 
     * @param toFilterSubgraphRootIds   See {@link #getToFilterSubgraphRootIds()}.
     * @see #getToFilterSubgraphRootIds()
     */
    public void setToFilterSubgraphRootIds(
            Collection<String> toFilterSubgraphRootIds) {
        this.toFilterSubgraphRootIds = toFilterSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the names of the targeted subsets, 
     *          for which member {@code OWLClass}es should have their is_a/part_of 
     *          incoming edges removed (only if the source of the incoming edge 
     *          will not be left orphan of other is_a/part_of relations to {@code OWLClass}es 
     *          not in {@code subsets}. First argument when calling 
     *          {@code OWLGraphManipulator#removeRelsToSubsets(Collection, Collection)}.
     * @see #getClassIdsExcludedFromSubsetRemoval()
     * @see #setSubsetNames(Collection)
     */
    public Collection<String> getSubsetNames() {
        return subsetNames;
    }
    /**
     * Sets the parameter returned by {@link #getSubsetNames()}.
     * 
     * @param subsetNames   See {@link #getSubsetNames()}.
     * @see #setClassIdsExcludedFromSubsetRemoval(Collection)
     * @see #getSubsetNames()
     */
    public void setSubsetNames(Collection<String> subsetNames) {
        this.subsetNames = subsetNames;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es whose incoming edges should not be removed even if member 
     *          of a subset listed in {@link #subsetNames}. Second argument when calling 
     *          {@code OWLGraphManipulator#removeRelsToSubsets(Collection, Collection)}.
     * @see #getSubsetNames()
     * @see #setClassIdsExcludedFromSubsetRemoval(Collection)
     */
    public Collection<String> getClassIdsExcludedFromSubsetRemoval() {
        return classIdsExcludedFromSubsetRemoval;
    }
    /**
     * Sets the parameter returned by {@link #getClassIdsExcludedFromSubsetRemoval()}.
     * 
     * @param classIdsExcludedFromSubsetRemoval See {@link #getClassIdsExcludedFromSubsetRemoval()}.
     * @see #setSubsetNames(Collection)
     * @see #getClassIdsExcludedFromSubsetRemoval()
     */
    public void setClassIdsExcludedFromSubsetRemoval(
            Collection<String> classIdsExcludedFromSubsetRemoval) {
        this.classIdsExcludedFromSubsetRemoval = classIdsExcludedFromSubsetRemoval;
    }

    /**
     * @return  A {@code Map} to specify to remove relations between two {@code OWLClass}es. 
     *          Keys are {@code String}s that are the OBO-like IDs of the source of the relations 
     *          to remove, the associated value being a {@code Set} of {@code String}s 
     *          that are the OBO-like ID of the targets of the relations to remove.
     *          {@code OWLGraphManipulator#removeDirectEdgesBetween(String, String)} will be called 
     *          for each key with each entry in the associated {@code Set}.
     * @see #setRelsBetweenToRemove(Map)
     */
    public Map<String, Set<String>> getRelsBetweenToRemove() {
        return relsBetweenToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getRelsBetweenToRemove()}.
     * 
     * @param relsBetweenToRemove   See {@link #getRelsBetweenToRemove()}.
     * @see #getRelsBetweenToRemove()
     */
    public void setRelsBetweenToRemove(Map<String, Set<String>> relsBetweenToRemove) {
        this.relsBetweenToRemove = relsBetweenToRemove;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es for which we want to remove all their children, 
     *          reachable by any path in their graph closure. 
     *          The {@code OWLClass}es will not be removed. 
     * @see #setChildrenOfToRemove(Collection)
     */
    public Collection<String> getChildrenOfToRemove() {
        return childrenOfToRemove;
    }

    /**
     * Sets the parameter returned by {@link #getChildrenOfToRemove()}.
     * 
     * @param childrenOfToRemove    See {@link #getChildrenOfToRemove()}.
     * @see #getChildrenOfToRemove()
     */
    public void setChildrenOfToRemove(Collection<String> childrenOfToRemove) {
        this.childrenOfToRemove = childrenOfToRemove;
    }
    
    
    
// NOTE May 13 2014: this method seems now completely useless, to remove if it is confirmed.
//    /**
//     * Retrieve all {@code OWLGraphEdge}s related to the relation {@code relationToUse}, 
//     * or any of its sub-property, from the ontology stored in {@code uberonFile}, 
//     * and write them into {@code outputFile}.
//     * 
//     * @param uberonFile    A {@code String} that is the path to the Uberon ontology.
//     * @param outputFile    A {@code String} that is the output file to be written.
//     * @param relationToUse A {@code String} that is the OBO-like ID of the IRI of 
//     *                      the relation to use. 
//     * @throws IOException                      If an error occurred while reading the file 
//     *                                          {@code uberonFile}.
//     * @throws OBOFormatParserException         If the ontology was provided in OBO format 
//     *                                          and a parser error occurred. 
//     * @throws OWLOntologyCreationException     If an error occurred while loading 
//     *                                          the ontology.
//     */
//    public void extractRelatedEdgesToOutputFile(
//            String uberonFile, String outputFile, String relationToUseId)  throws OWLOntologyCreationException, 
//            OBOFormatParserException, IOException {
//        log.entry(uberonFile, outputFile, relationToUseId);
//        
//        OWLOntology ont = OntologyUtils.loadOntology(uberonFile);
//        OWLGraphWrapper wrapper = new OWLGraphWrapper(ont);
//        
//        //try to get the relation by its IRI
//        OWLObjectProperty relProp = wrapper.getOWLObjectProperty(relationToUseId);
//        //try to get it from its OBO-like ID
//        if (relProp == null) {
//            relProp = wrapper.getOWLObjectPropertyByIdentifier(relationToUseId);
//        }
//        if (relProp == null) {
//            throw log.throwing(new IllegalArgumentException("The provided ontology did not " +
//            		"contain the relation " + relationToUseId));
//        }
//        Set<OWLObjectPropertyExpression> props = wrapper.getSubPropertyReflexiveClosureOf(relProp);
//        Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
//        
//        for (OWLClass iterateClass: wrapper.getAllOWLClasses()) {
//            for (OWLGraphEdge edge: wrapper.getOutgoingEdges(iterateClass)) {
//                if (edge.getSingleQuantifiedProperty() != null && 
//                        props.contains(edge.getSingleQuantifiedProperty().getProperty())) {
//                    edges.add(edge);
//                }
//            }
//        }
//        
//        //write edges to file
//        String[] header = new String[] {"Uberon source ID", "Uberon source name", 
//                "Relation ID", "Relation name", "Uberon target ID", "Uberon target name"};
//        CellProcessor[] processors = new CellProcessor[] {new NotNull(), new NotNull(), 
//                new NotNull(), new NotNull(), new NotNull(), new NotNull()};
//        try (ICsvMapWriter mapWriter = new CsvMapWriter(new FileWriter(outputFile),
//                Utils.TSVCOMMENTED)) {
//            
//            mapWriter.writeHeader(header);
//            for (OWLGraphEdge edge: edges) {
//                Map<String, String> line = new HashMap<String, String>();
//                line.put("Uberon source ID", wrapper.getIdentifier(edge.getSource()));
//                line.put("Uberon source name", wrapper.getLabel(edge.getSource()));
//                line.put("Relation ID", wrapper.getIdentifier(
//                        edge.getSingleQuantifiedProperty().getProperty()));
//                line.put("Relation name", wrapper.getLabel(
//                        edge.getSingleQuantifiedProperty().getProperty()));
//                line.put("Uberon target ID", wrapper.getIdentifier(edge.getTarget()));
//                line.put("Uberon target name", wrapper.getLabel(edge.getTarget()));
//                mapWriter.write(line, header, processors);
//            }
//        }
//        
//        log.exit();
//    }
}
