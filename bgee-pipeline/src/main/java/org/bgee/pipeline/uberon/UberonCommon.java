package org.bgee.pipeline.uberon;

import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.pipeline.ontologycommon.OntologyUtils;
import org.obolibrary.oboformat.parser.OBOFormatParserException;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLOntologyCreationException;

/**
 * Class holding attributes and methods common to {@link Uberon} and {@link UberonDevStage}.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
abstract class UberonCommon {
    /**
     * {@code Logger} of the class.
     */
    private final static Logger log = LogManager.getLogger(UberonCommon.class.getName());
    
    /**
     * A {@code String} that is the name of the column containing the anatomical entity IDs 
     * (for instance, "UBERON:0001905") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String UBERON_ENTITY_ID_COL = "Uberon ID";
    /**
     * A {@code String} that is the name of the column containing the anatomical entity names 
     * (for instance, "pineal body") in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String ANAT_ENTITY_NAME_COL = "Uberon name";
    /**
     * A {@code String} that is the name of the column containing the is_a/part_of relations 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String RELATIONS_COL = "is_a/part_of relations";
    /**
     * A {@code String} that is the name of the column containing the reason for the removal 
     * of terms in the information files (see 
     * {@link #saveSimplificationInfo(OWLOntology, String, Map)}).
     * 
     * @see #saveSimplificationInfo(OWLOntology, String, Map)
     */
    public static final String REASON_FOR_REMOVAL = "Reason for removal";
    /**
     * A {@code String} that is the name of the column containing the IDs of the XRefs 
     * we want a mapping from, to Uberon IDs, in the file generated by 
     * {@link #saveXRefMappingsToFile(String, String)}.
     * 
     * @see #saveXRefMappingsToFile(String, String)
     */
    public static final String XREF_ID_COL = "XRef ID";
    
    /**
     * A {@code String} that is the path to the file storing the Uberon ontology 
     * (recommended version is OWL, but OBO versions can be used as well).
     */
    private String pathToUberonOnt;
    /**
     * A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     * in files (suffixes ".obo" and ".owl" will be automatically added).
     */
    private String modifiedOntPath;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs of {@code OWLClass}es 
     * to remove from the ontology, and to propagate their incoming edges 
     * to their outgoing edges. Argument when calling 
     * {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     */
    private Collection<String> classIdsToRemove;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     * of relations to be filtered and mapped to parent relations. Argument when calling 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     * {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     * with second argument {@code true}.
     */
    private Collection<String> relIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs 
     * to be removed from the ontology. Classes part both of a subgraph to remove 
     * and a subgraph not to be removed will be kept. 
     * Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toRemoveSubgraphRootIds;
    /**
     * A {@code Collection} of {@code String}s that are the OBO-like IDs 
     * of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     * in the ontology. Their ancestors will be kept as well. Argument when calling 
     * {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     */
    private Collection<String> toFilterSubgraphRootIds;
    /**
     * A {@code String} that is the path to the file that will store information about 
     * the {@code OWLClass}es that were removed as a result of simplification.
     */
    private String classesRemovedFilePath;
    /**
     * A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     * and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     * in which the {@code OWLClass} exists. 
     */
    private Map<String, Set<Integer>> taxonConstraints;
    /**
     * A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     * of {@code OWLClass}es removed as a result of the simplification process, 
     * the associated values being {@code String}s representing the reason 
     * for the class removal.
     * <p>
     * Note: this could be represented in a better object-oriented way, but we just go 
     * fast and dirty for the pipeline.
     */
    private final Map<String, String> classesRemoved;
    
    /**
     * The {@code OntologyUtils} used to perform operations, wrapping the Uberon ontology 
     * that will be used. 
     */
    private final OntologyUtils ontUtils;
    
    /**
     * Default constructor private in purpose, an ontology should always be provided somehow.
     */
    @SuppressWarnings("unused")
    private UberonCommon() {
        this((OntologyUtils) null);
    }
    
    /**
     * Constructor providing the path to the Uberon ontology to used to perforn operations.
     * 
     * @param pathToUberon  A {@code String} that is the path to the Uberon ontology. 
     * @throws OWLOntologyCreationException If an error occurred while loading the ontology.
     * @throws OBOFormatParserException     If the ontology is malformed.
     * @throws IOException                  If the file could not be read. 
     */
    public UberonCommon(String pathToUberon) throws OWLOntologyCreationException, 
    OBOFormatParserException, IOException {
        this(new OntologyUtils(pathToUberon));
    }
    /**
     * Constructor providing the {@code OntologyUtils} used to perform operations, 
     * wrapping the Uberon ontology that will be used. 
     * 
     * @param ontUtils  the {@code OntologyUtils} that will be used. 
     */
    public UberonCommon(OntologyUtils ontUtils) {
        this.ontUtils = ontUtils;
        this.classesRemoved = new HashMap<String, String>();
        this.setTaxonConstraints(null);
    }


    /**
     * @return  A {@code String} that is the path to the file storing the Uberon ontology 
     *          (recommended version is OWL, but OBO versions can be used as well).
     * @see #setPathToUberonOnt(String)
     */
    public String getPathToUberonOnt() {
        return pathToUberonOnt;
    }
    /**
     * Sets the parameter returned by {@link #getPathToUberonOnt()}.
     * 
     * @param pathToUberonOnt   See {@link #getPathToUberonOnt()}.
     * @see #getPathToUberonOnt()
     */
    public void setPathToUberonOnt(String pathToUberonOnt) {
        this.pathToUberonOnt = pathToUberonOnt;
    }

    /**
     * @return  A {@code String} that is the path to use to save the modified {@code OWLOntology}s 
     *          in files (suffixes ".obo" and ".owl" will be automatically added).
     * @see #setModifiedOntPath(String)
     */
    public String getModifiedOntPath() {
        return modifiedOntPath;
    }
    /**
     * Sets the parameter returned by {@link #getModifiedOntPath()}.
     * 
     * @param modifiedOntPath   See {@link #getModifiedOntPath()}.
     * @see #getModifiedOntPath()
     */
    public void setModifiedOntPath(String modifiedOntPath) {
        this.modifiedOntPath = modifiedOntPath;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es to remove from the ontology, and to propagate 
     *          their incoming edges to their outgoing edges. Argument when calling 
     *          {@code OWLGraphManipulator#removeClassAndPropagateEdges(String)}. 
     * @see #setClassIdsToRemove(Collection)
     */
    public Collection<String> getClassIdsToRemove() {
        return classIdsToRemove;
    }
    /**
     * Sets the parameter returned by {@link #getClassIdsToRemove()}.
     * 
     * @param classIdsToRemove  See {@link #getClassIdsToRemove()}.
     * @see #getClassIdsToRemove()
     */
    public void setClassIdsToRemove(Collection<String> classIdsToRemove) {
        this.classIdsToRemove = classIdsToRemove;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs or {@code IRI}s 
     *          of relations to be filtered and mapped to parent relations. Argument when calling 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection)} and 
     *          {@code OWLGraphManipulator#mapRelationsToParent(Collection, boolean)}, 
     *          with second argument {@code true}.
     * @see #setRelIds(Collection)
     */
    public Collection<String> getRelIds() {
        return relIds;
    }
    /**
     * Sets the parameter returned by {@link #getRelIds()}.
     * 
     * @param relIds    See {@link #getRelIds()}.
     * @see #getRelIds()
     */
    public void setRelIds(Collection<String> relIds) {
        this.relIds = relIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs 
     *          to be removed from the ontology. Classes part both of a subgraph to remove 
     *          and a subgraph not to be removed will be kept. 
     *          Argument when calling {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToRemoveSubgraphRootIds(Collection)
     */
    public Collection<String> getToRemoveSubgraphRootIds() {
        return toRemoveSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToRemoveSubgraphRootIds()}.
     * 
     * @param toRemoveSubgraphRootIds   See {@link #getToRemoveSubgraphRootIds()}.
     * @see #getToRemoveSubgraphRootIds()
     */
    public void setToRemoveSubgraphRootIds(
            Collection<String> toRemoveSubgraphRootIds) {
        this.toRemoveSubgraphRootIds = toRemoveSubgraphRootIds;
    }

    /**
     * @return  A {@code Collection} of {@code String}s that are the OBO-like IDs 
     *          of the {@code OWLClass}es that are the roots of the subgraphs that will be kept 
     *          in the ontology. Their ancestors will be kept as well. Argument when calling 
     *          {@code OWLGraphManipulator#filterSubgraphs(Collection)}.
     * @see #setToFilterSubgraphRootIds(Collection)
     */
    public Collection<String> getToFilterSubgraphRootIds() {
        return toFilterSubgraphRootIds;
    }
    /**
     * Sets the parameter returned by {@link #getToFilterSubgraphRootIds()}.
     * 
     * @param toFilterSubgraphRootIds   See {@link #getToFilterSubgraphRootIds()}.
     * @see #getToFilterSubgraphRootIds()
     */
    public void setToFilterSubgraphRootIds(
            Collection<String> toFilterSubgraphRootIds) {
        this.toFilterSubgraphRootIds = toFilterSubgraphRootIds;
    }
    /**
     * @return  A {@code Map} where keys are OBO-like IDs of the Uberon {@code OWLClass}es, 
     *          and values are {@code Set}s of {@code Integer}s containing the IDs of taxa 
     *          in which the {@code OWLClass} exists. 
     */
    public Map<String, Set<Integer>> getTaxonConstraints() {
        return taxonConstraints;
    }
    /**
     * Set taxon constraints.
     * 
     * @param taxonConstraints  A {@code Map} where keys are OBO-like IDs of the Uberon 
     *                          {@code OWLClass}es, and values are {@code Set}s of 
     *                          {@code Integer}s containing the IDs of taxa 
     *                          in which the {@code OWLClass} exists. 
     */
    public void setTaxonConstraints(Map<String, Set<Integer>> taxonConstraints) {
        this.taxonConstraints = taxonConstraints;
    }
    
    /**
     * Determines whether {@code cls} belongs to the taxon with ID {@code taxonId}. 
     * This can be determined only if taxon constraints have been provided (see 
     * {@link #setTaxonConstraints(Map)}). If no taxon contraints have been provided, 
     * or {@code taxonId} is equal to 0, this method will always return {@code true}. 
     * If some taxon constraints have been provided, but none are defined for {@code cls}, 
     * this method will also return {@code true}. If some taxon constraints have been provided, 
     * that some are defined for {@code cls}, and if {@code taxonId} is different from 0, 
     * then this method will return {@code true} if {@code cls} belongs to the taxon, 
     * {@code false} otherwise. 
     * 
     * @param cls           An {@code OWLClass} for which we want to determine whether 
     *                      it belongs to the taxon with ID {@code taxonId}.
     * @param taxonId       An {@code int} that is the NCBI ID of the taxon for which 
     *                      we want to know if {@code cls} belongs to.
     * @return              {@code false} if it is shown that {@code cls} doesa not belong to 
     *                      taxon with ID {@code taxonId}, {@code false} otherwise. 
     */
    public boolean existsInSpecies(OWLClass cls, int taxonId) {
        log.entry(cls, taxonId);
        if (this.getTaxonConstraints() == null || taxonId == 0) {
            return log.exit(true);
        }
        Set<Integer> validSpecies = this.getTaxonConstraints().get(
                this.getOntologyUtils().getWrapper().getIdentifier(cls));
        if (validSpecies != null && !validSpecies.isEmpty() && 
                !validSpecies.contains(taxonId)) {
            return log.exit(false);
        }
        return log.exit(true);
    }

    /**
     * @return  A {@code Map} where keys are {@code String}s that are the OBO-like IDs 
     *          of {@code OWLClass}es removed as a result of the simplification process, 
     *          the associated values being {@code String}s representing the reason 
     *          for the class removal.
     */
    public Map<String, String> getClassesRemoved() {
        return this.classesRemoved;
    }
    /**
     * @return  A {@code String} that is the path to the file that will store information about 
     *          the {@code OWLClass}es that were removed as a result of simplification.
     * @see #setClassesRemovedFilePath(String)
     */
    public String getClassesRemovedFilePath() {
        return classesRemovedFilePath;
    }
    /**
     * Sets the parameter returned by {@link #getClassesRemovedFilePath()}.
     * 
     * @param classesRemovedFilePath    See {@link #getClassesRemovedFilePath()}.
     * @see #getClassesRemovedFilePath()
     */
    public void setClassesRemovedFilePath(String classesRemovedFilePath) {
        this.classesRemovedFilePath = classesRemovedFilePath;
    }
    
    /**
     * @return  The {@code OntologyUtils} used by this object. 
     */
    public OntologyUtils getOntologyUtils() {
        return this.ontUtils;
    }
}
