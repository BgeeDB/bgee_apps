package org.bgee.controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.URLParameters.Parameter;
import org.bgee.controller.exception.MultipleValuesNotAllowedException;
import org.bgee.controller.exception.RequestParametersNotFoundException;
import org.bgee.controller.exception.RequestParametersNotStorableException;
import org.bgee.controller.exception.RequestSizeExceededException;
import org.bgee.controller.exception.ValueSizeExceededException;
import org.bgee.controller.exception.InvalidFormatException;
import org.bgee.controller.servletutils.BgeeHttpServletRequest;
import org.bgee.model.expressiondata.baseelements.SummaryQuality;

/**
 * This class is intended to hold parameters of a query to the server, 
 * and also to generate URLs based on these parameters. 
 * <p>
 * This class can analyze a {@code HttpServletRequest} to extract 
 * and secure relevant parameters of a query to the server. 
 * It is also able to generate URLs based on these parameters, 
 * so that all links generated by the View are constructed by this class.
 * <p>
 * The parameters are represented by the class {@link URLParameters.Parameter}
 * and accessible through the class
 * {@link URLParameters} that provides individual access to each
 * {@code URLParameters.Parameter} or a
 * {@code List} that contains all existing {@code URLParameters.Parameter}.
 * These parameters are used by the present class as key to store their values in a 
 * {@code HashMap} 
 * <p>
 * When parameters are too long to be passed through URLs (because exceeding 
 * {@link BgeeProperties#getUrlMaxLength}, 
 * the query string is saved on disk for a later use. This mechanism is used,
 * rather than just putting parameters in session, so that parameters are 
 * indefinitely stored, and can be retrieved through an ID at any time.
 * <p>
 * The idea is: if, through a form, a user submit parameters that can be put in URL, 
 * then so be it. But if the user submit, for instance, a list of thousands of 
 * Ensembl gene IDs, that cannot be passed through URLs because of URLs length
 * limitation, these parameters will be stored on disk: 
 * the query string will be stored in a file, 
 * an ID will be generated to be used as an index to retrieve the file, 
 * and this ID will be passed in URL, 
 * so that the parameters can be retrieved indefinitely. 
 * <p>
 * There are two "big" categories of parameters: "storable" parameters, 
 * that are potentially linked to large data submission, 
 * and "non-storable" parameters, that should never be responsible of large data 
 * submission, and that are meaningful in the URL.
 * Only storable parameters are used to generate IDs, to be stored, and to be 
 * retrieved using the ID provided in the URL. 
 * The properties {@link URLParameters.Parameter#isStorable} tells whether 
 * the parameter is storable or not.
 * 
 * This class has a js counterpart called {@code requestparameters.js} that should be kept 
 * consistent as much as possible if the class evolves.
 * 
 * @author  Mathieu Seppey
 * @author  Frederic Bastian
 * @author  Valentine Rech de Laval
 * @version Bgee 14, Mar. 2017
 * @since   Bgee 1
 */
public class RequestParameters {

    private final static Logger log = LogManager.getLogger(RequestParameters.class.getName());

    /**
     * {@code ConcurrentMap} used to manage concurrent access to 
     * the read/write locks that are used to manage concurrent reading and writing 
     * of the files storing query strings holding storable parameters. 
     * The generated key of the {@code RequestParameters} object to be 
     * loaded or stored is associated to the lock in this {@code Map}.
     * 
     * @see #store()
     * @see #loadStorableParametersFromKey(String)
     */
    private static final ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks= 
            new ConcurrentHashMap<String, ReentrantReadWriteLock>();
    
    /**
     * A {@code String} that is the default value of character encoding for encoding and 
     * decoding query strings.
     */
    public static final String CHAR_ENCODING = "UTF-8";
    /**
     * A {@code String} that is a magic value to select all possible values of a parameter 
     * accepting multiple values from an {@code Enum}.
     */
    public static final String ALL_VALUE = "all";
    
    /**
     * An {@code int} that is the maximum total length of the parameters, 
     * whether provided by POST or GET method, for security reasons.
     */
    // XXX: could be moved to URLParameters, in which case we should add a getter method to
    // URLParameters class to access this parameter
    private static final int SECURE_MAX_URL_LENGTH = 100000000;

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOWNLOAD = "download";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOCUMENTATION = "doc";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a about page is requested.
     */
    public static final String PAGE_ABOUT = "about";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a species page is requested.
     */
    public static final String PAGE_SPECIES = "species";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to topAnat is requested.
     */
    public static final String PAGE_TOP_ANAT = "top_anat";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to job management is requested.
     */
    public static final String PAGE_JOB = "job";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to DAO queries is requested.
     */
    public static final String PAGE_DAO = "dao";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to R package queries is requested.
     */
    public static final String PAGE_RPACKAGE = "r_package";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a query is made for usage statistics gathering.
     */
    public static final String PAGE_STATS = "stats";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to a gene is requested.
     */
    public static final String PAGE_GENE = "gene";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to sources is requested.
     */
    public static final String PAGE_SOURCE = "source";

    /**
     * A {@code String} that encapsulates the value of the gene id parameter for the gene page.
     */
    public static final String GENE_ID = "gene_id";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_CALL_FILES = "expr_calls";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_PROC_VALUE_FILES = "proc_values";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_CALL_DOWLOAD_FILES = "call_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_PROC_EXPR_VALUE_DOWLOAD_FILES = "proc_value_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_TOP_ANAT = "top_anat";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a species data is requested.
     * Value of the parameter page should be {@link #PAGE_SPECIES}.
     */
    public static final String ACTION_SPECIES_UPLOAD = "species_upload";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a gene list validation is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_GENE_VALIDATION = "gene_validation";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a submission of a new job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_SUBMIT_JOB = "submit_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a tracking job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_TRACKING_JOB = "tracking_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a result is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_GET_RESULT = "get_results";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when the downloading of a result file is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_DOWNLOAD = "download";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when the canceling of a job is requested.
     * Value of the parameter page should be {@link #PAGE_JOB}.
     */
    public static final String ACTION_CANCEL_JOB = "cancel";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when auto-complete gene search is requested.
     * Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_AUTO_COMPLETE_GENE_SEARCH = "auto_complete_gene_search";

    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE = "single";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI = "multi";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the OMA HOG part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_OMA = "oma_hog";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR = "single_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_SIMPLE = "single_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species complete expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_COMPLETE = "single_expr_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR = "multi_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_SIMPLE = "multi_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_COMPLETE = "multi_expr_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF = "single_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_SIMPLE = "single_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_COMPLETE = "single_diff_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF = "multi_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_SIMPLE = "multi_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_COMPLETE = "multi_diff_complete";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about how to access to
     * Bgee data is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_HOW_TO_ACCESS = "access";
    
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a XML view.
     */
    public static final String DISPLAY_TYPE_XML = "xml";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a CSV view.
     */
    public static final String DISPLAY_TYPE_CSV = "csv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a TSV view.
     */
    public static final String DISPLAY_TYPE_TSV = "tsv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a JSON view.
     */
    public static final String DISPLAY_TYPE_JSON = "json";
    
    /**
     * A {@code String} that is the separator to use between the search part and hash part 
     * of URLs generated by the method {@link #getRequestURL(String, Collection, boolean)}. 
     * This is used only for pages where the hash is used to read/write parameters 
     * from URL in javascript.
     * <p>
     * This attribute is useful if you wanted, for instance, to have such pages 
     * indexed by google (it should then be changed to '#!').
     * <p>
     * Note that this attribute is not use as hash separator when the hash is actually used 
     * to link to an element with corresponding ID on the page (see {@link #setURLHash(String)}).
     */
    public static final String JS_HASH_SEPARATOR = "#";
    
    /**
     * A {@code BgeeProperties} instance to provide all the properties values
     */
    private final BgeeProperties prop ;

    /**
     * A {@code HashMap<URLParameters.Parameter<?>, List<Object>} that store the
     * values of parameters as an {@code Object} using a 
     * {URLParameters.Parameter<T>} instance as key
     */    
    private final HashMap<URLParameters.Parameter<?>, List<Object>> values = 
            new HashMap<URLParameters.Parameter<?>, List<Object>>();
    
    /**
     * A {@code String} that is the 'hash' part of the URL to add 
     * when methods {@code getRequestURL} are called. This is used to actually link 
     * to an element with this ID (the 'classical' use of hash), this must not be used 
     * to store parameter values (the javascript use, allowing js to change an URL 
     * with no redirection). For this latter use, see {@link #getRequestURL(Collection, boolean)} 
     * and {@link #getRequestURL(String, Collection, boolean)}.
     * <p>
     * Of course, the hash is never retrieved from a {@code HttpServletRequest}, 
     * this is not meant to be used by the server. 
     */
    private String urlHash;

    /**
     * A {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * If {@code false}, then the {@code encodeUrl} method returns 
     * Strings with no modifications, otherwise, they are url encoded if needed.
     * 
     * @see #urlEncode(String)
     */
    private boolean encodeUrl;
    
    private final int secureMaxURLLength;
    
    /**
     * A {@code String} defining the character encoding for encoding and decoding query strings.
     */
    private final String charEncoding;

    /**
     * A {@code String} defining the character(s) that are used as parameters separator in the
     * URL 
     */
    private String parametersSeparator;

    /**
     * A {@code String} that contains the URL corresponding to the current state
     * of the request parameters
     */
    private String parametersQuery;

    /**
     * An instance of {@code URLParameters} that provides all the
     * {@code URLParameters.Parameter} that can be present in the request. This follows the pattern 
     * of dependency injection.
     * 
     * @see URLParameters
     */
    private final URLParameters urlParametersInstance;

    /**
     * Name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    private final String httpMethod;

    /**
     * 0-arg constructor defining default implementations and values to use to call 
     * {@link #RequestParameters(URLParameters, BgeeProperties, boolean, String)}. It uses 
     * the {@code BgeeProperties} returned by {@link BgeeProperties#getBgeeProperties()}, 
     * the default implementation of {@code URLParameters}, value {@code true} for 
     * {@code encodeUrl}, value "&" for {@code parametersSeparator}.
     */
    public RequestParameters() {
        this(BgeeProperties.getBgeeProperties());
    }
    /**
     * @param props The {@code BgeeProperties} used by this {@code RequestParameters}.
     */
    public RequestParameters(BgeeProperties props) {
        this(new URLParameters(), props, true, "&");
    }
    /**
     * @param urlParametersInstance     A instance of {@code URLParameters} that 
     *                                  is injected to provide the available parameters
     *                                  list. 
     *                                  
     * @param prop                      An instance of {@code BgeeProperties}  that is injected
     *                                  to provide the all the properties values
     *                                  
     * @param encodeUrl                 A {@code boolean} defining whether parameters should be
     *                                  url encoded.
     * 
     * @param parametersSeparator       A {@code String} defining the character(s) that are
     *                                  used as parameters separator in the URL 
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator)  {
        this(urlParametersInstance, prop, encodeUrl, parametersSeparator, CHAR_ENCODING, 
                SECURE_MAX_URL_LENGTH);
    }
    /**
     * @param urlParametersInstance A instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected
     *                              to provide the all the properties values.
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded. 
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL.
     * @param charEncoding          A {@code String} that is the character encoding used 
     *                              to encode/decode query strings.
     * @param urlMaxLength          An {@code int} that is the maximum total length of the parameters, 
     *                              whether provided by POST or GET method, for security reasons.  
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator, String charEncoding, int urlMaxLength)  {
        log.entry(urlParametersInstance,prop,encodeUrl, parametersSeparator, charEncoding, urlMaxLength);

        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.secureMaxURLLength = urlMaxLength;
        this.charEncoding = charEncoding;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        //to avoid duplicating methods, 
        //here we simulate a HttpServletRequest with an empty query string, 
        //so that all parameters will be initialized empty
        HttpServletRequest request = new BgeeHttpServletRequest("", this.charEncoding);
        this.httpMethod = request.getMethod();
        try {
            this.constructor(request);
        } catch (RequestParametersNotFoundException | MultipleValuesNotAllowedException | 
                InvalidFormatException e) {
            //here we do nothing, 
            //because we provide a "blank" HttpServletRequest, so none of the declared exception
            //is expected
            throw log.throwing(new AssertionError("Unreachable code reached in default constructor", e));
        }

        log.exit();
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <p>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values.       
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL                              
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator)
                    throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, InvalidFormatException {
        this(request, urlParametersInstance, prop, encodeUrl, parametersSeparator, CHAR_ENCODING, 
                SECURE_MAX_URL_LENGTH);
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <p>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values 
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL.
     * @param charEncoding          A {@code String} that is the character encoding used 
     *                              to encode/decode query strings.  
     * @param urlMaxLength          An {@code int} that is the maximum total length of the parameters, 
     *                              whether provided by POST or GET method, for security reasons.                       
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator, String charEncoding, 
            int urlMaxLength) throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, InvalidFormatException {
        log.entry(request, urlParametersInstance, prop, encodeUrl, parametersSeparator, 
                charEncoding, urlMaxLength);
        
        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.secureMaxURLLength = urlMaxLength;
        this.charEncoding = charEncoding;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        this.httpMethod = request.getMethod();
        this.urlHash = null;
        this.constructor(request);

        log.exit();
    }

    /**
     * Method that is called by the constructors to allow different handling of exceptions but
     * avoid the duplication of the code within constructors.
     * 
     * @param request   The HttpServletRequest object corresponding to the current 
     *                  request to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     *                                                  
     * @see #RequestParameters(URLParameters, BgeeProperties, boolean, String)
     * @see #RequestParameters(HttpServletRequest, URLParameters, BgeeProperties, boolean, String)
     */
    private void constructor(HttpServletRequest request) throws RequestParametersNotFoundException,
    MultipleValuesNotAllowedException, InvalidFormatException{
        log.entry(request);

        this.loadParameters(request.getParameterMap());

        log.exit();
    }

    /**
     * Load all the parameters related to the request, based on 
     * the {@code HttpServletRequest} object. 
     * It uses the parameters present in the request or load them from a file.
     * If the current request includes a key to retrieve a stored query string, 
     * the corresponding query string is retrieved from a file named as the key, 
     * If no key is provided, the storable parameters are simply retrieved from
     * the current request.
     * 
     * @param paramValues   A {@code Map} where keys are parameter names, and values are 
     *                      {@code Array}s of {@code String}s containing the associatd values, 
     *                      as returned by {@code ServletRequest.getParameterMap()}.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParametersFromRequest
     * @see #loadStorableParametersFromKey
     */
    private void loadParameters(Map<String, String[]> paramValues) 
            throws RequestParametersNotFoundException, 
            MultipleValuesNotAllowedException, InvalidFormatException{
        log.entry(paramValues);

        //Get the key
        String key = Optional.ofNullable(
                paramValues.get(this.getUrlParametersInstance().getParamData().getName()))
                .map(arr -> arr.length > 0? arr[0]: null)
                .orElse(null);
        if (StringUtils.isBlank(key)) {
            log.trace("The key is blank, load params from request");
            //no key set, get the parameters from the URL
            this.loadParametersFromRequest(paramValues, true);
        } else {
            //a key is set, get the storable parameters from a file
            log.trace("The key is set, load params from the file");
            try {
                this.loadStorableParametersFromKey(key);
            } catch (IOException e) {
                // Re throw a custom exception instead
                throw new RequestParametersNotFoundException(key);
            }
            // load the non storable params
            this.loadParametersFromRequest(paramValues, false);
        }

        log.exit();
    }

    /**
     * Load the parameters from the {@code HttpServletRequest} object
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param request          the {@code HttpServletRequest} object representing 
     *                         the current request to the server.
     * 
     * @param loadStorable     a {@code boolean} that indicates whether the storable 
     *                         parameters have to be loaded from the request. 
     *                         For example, if the storable parameters were already
     *                         loaded from the key, this method will be called to load
     *                         the non-storable parameter only, i.e. with loadStorable 
     *                         set at {@code false}
     *                         
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadStorableParametersFromKey
     * @see #loadParameters
     */
    private void loadParametersFromRequest(Map<String, String[]> paramValues, boolean loadStorable) 
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.entry(paramValues, loadStorable);

        // Browse all available parameters
        for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()) {
            log.trace("Trying to retrieve value for parameter {}", parameter.getName());
            // If it is a param that has the desired isStorable status, proceed...
            if (loadStorable || !parameter.isStorable()){
                // Fetch the string values from the URL
                String[] originalValuesFromUrl = paramValues.get(parameter.getName());
                // For backward compatibility with Bgee 13, for the parameter SUMMARY_QUALITY,
                // replace "low" with "silver" and "high" with "gold".
                String[] valuesFromUrl = originalValuesFromUrl;
                if (URLParameters.SUMMARY_QUALITY_PARAM_NAME.equals(parameter.getName()) &&
                        originalValuesFromUrl != null) {
                    valuesFromUrl = Arrays.stream(originalValuesFromUrl)
                            .map(v -> {
                                if ("low".equalsIgnoreCase(v)) {
                                    return SummaryQuality.SILVER.getStringRepresentation();
                                }
                                if ("high".equalsIgnoreCase(v)) {
                                    return SummaryQuality.GOLD.getStringRepresentation();
                                }
                                return v;
                            })
                            .toArray(String[]::new);
                }

                if (log.isTraceEnabled()) {
                    log.trace("Values retrieved: {}", Arrays.deepToString(
                            Optional.ofNullable(valuesFromUrl).orElse(new String[0])));
                }
                if (valuesFromUrl == null) {
                    continue;
                }
                
                //process the parameter and store it into this RequestParameters
                this.addAnyValues(parameter, Arrays.stream(valuesFromUrl)
                    //secure the String value
                    .map(value -> this.secureString(value, parameter))
                    //split into multiple values if the parameter is a separated-value parameter.
                    .flatMap(value -> {
                        List<String> values = new ArrayList<>();
                        if (!parameter.allowsSeparatedValues()) {
                            values.add(value);
                        } else {
                            String splitPattern = "";
                            for (String separator: parameter.getSeparators()) {
                                if (!splitPattern.equals("")) {
                                    splitPattern += "|";
                                }
                                splitPattern += Pattern.quote(separator);
                            }
                            values.addAll(Arrays.asList(value.split(splitPattern)));
                        }
                        return values.stream();
                    })
                    //filter
                    .filter(StringUtils::isNotBlank)
                    //cast to the parameter requested type
                    .map(value -> {
                        value = value.trim();
                        try {
                            if(parameter.getType().equals(String.class)){
                                return value;
                            } else if (parameter.getType().equals(Integer.class)){
                                return Integer.parseInt(value);
                            } else if (parameter.getType().equals(Boolean.class)){
                                return castToBoolean(value);
                            } else if (parameter.getType().equals(Double.class)){
                                return Double.parseDouble(value);
                            } else {
                                throw log.throwing(new IllegalStateException(
                                        "Unsupported parameter type: " + parameter.getType()));
                            }
                        } catch (NumberFormatException e) {
                            throw log.throwing(new InvalidFormatException(parameter, e));
                        }
                    })
                    .collect(Collectors.toList()));
            }
        }

        log.exit();
    }

    /**
     * Load the storable parameters from the file corresponding to the provided key.
     * If a key is provided, but no stored query string is found corresponding to this key, 
     * a IOException is thrown.
     * 
     * @throws IOException                              thrown if a error occurs while trying 
     *                                                  to read the file associated to the key,
     *                                                  containing the query string to be used.
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParameters
     * @see #loadParametersFromRequest
     * 
     */
    private void loadStorableParametersFromKey(String key) throws IOException, 
    MultipleValuesNotAllowedException, InvalidFormatException {
        log.entry(key);

        ReentrantReadWriteLock lock = this.getReadWriteLock(key);
        try {
            lock.readLock().lock();

            while (readWriteLocks.get(key) == null ||  
                    !readWriteLocks.get(key).equals(lock)) {
                lock = this.getReadWriteLock(key);
                lock.readLock().lock();
            }
            try (BufferedReader br = new BufferedReader(new FileReader(
                    prop.getRequestParametersStorageDirectory() + key))) {
                String retrievedQueryString;
                //just one line in the file, a query string including storable parameters, 
                //that will be used to recover storable parameters
                if ((retrievedQueryString = br.readLine()) != null) {
                    //here we create a fake HttpServletRequest using the query 
                    // string we retrieved.
                    //this way we do not duplicate code to load parameters into 
                    // this RequestParameters object.
                    HttpServletRequest request = new BgeeHttpServletRequest(
                            retrievedQueryString, this.getCharacterEncoding());
                    this.loadParametersFromRequest(request.getParameterMap(), true);
                }
            }

        } finally {
            lock.readLock().unlock();
            this.removeLockIfPossible(key);
        }

        log.exit();

    }

    /**
     * Store the part of the query string holding storable parameters into a file: 
     * get the part of the query string containing "storable" parameters 
     * generate a key based on that string, and store the string in a file named as the key.
     * This allows to store parameters too lengthy to be put in URL, to replace these parameters 
     * by the key, which is stored in the {@code URLParameters.Parameter} DATA 
     * and to store these parameters to retrieve them at later pages 
     * using that key.
     * 
     * @throws RequestParametersNotStorableException    if an error occur while trying to use
     *                                                  the key or to write the query string in
     *                                                  a file
     * @see #generateParametersQuery(String)
     * @see URLParameters#getParamData
     */
    private void store() throws RequestParametersNotStorableException {
        log.entry();

        if (StringUtils.isBlank(this.getFirstValue(
                this.getKeyParam()))) {
            throw new RequestParametersNotStorableException(
                    "No key was generated before trying to store the associated parameters.");
        }
        //first check whether these parameters have already been serialized
        File storageFile = new File(prop.getRequestParametersStorageDirectory() 
                + this.getFirstValue(this.getKeyParam()));
        if (storageFile.exists()) {
            //file already exists, no need to continue
            return;
        }
        ReentrantReadWriteLock lock = this.getReadWriteLock(this.getFirstValue(
                this.getKeyParam()));
        try {
            lock.writeLock().lock();
            while (readWriteLocks.get(this.getDataKey()) == null ||  
                    !readWriteLocks.get(this.getDataKey()).equals(lock)) {
                lock = this.getReadWriteLock(this.getDataKey());
                lock.writeLock().lock();
            }
            try (BufferedWriter bufferedWriter = new BufferedWriter(
                    new FileWriter(prop.getRequestParametersStorageDirectory() 
                            + this.getFirstValue(this.getKeyParam())))) {
                // we cannot store an URL-decoded query string, to store encoding-independent values, 
                // because of cases where, e.g., a parameter value include a character such as '&': 
                // we couldn't distinguish it anymore from real parameter separators.
                bufferedWriter.write(generateParametersQuery(null, true, false, "&", null, false));
            }
        } catch (IOException e) {
            log.catching(e);
            //delete the file if something went wrong
            storageFile = new File(prop.getRequestParametersStorageDirectory() 
                    + this.getFirstValue(this.getKeyParam()));
            if (storageFile.exists()) {
                storageFile.delete();
            }
            throw new RequestParametersNotStorableException(
                    "An error occurred and it was not possible to store the parameters.");
        } finally {
            lock.writeLock().unlock();
            this.removeLockIfPossible(this.getFirstValue(
                    this.getKeyParam()));
        }

        log.exit();
    }

    /**
     * Try to remove the {@code ReentrantReadWriteLock} corresponding to 
     * the argument {@code key}, from the {@code ConcurrentHashMap} 
     * {@link #readWriteLocks}.
     * The lock will be removed from the map only if there are no read or write locks, 
     * and no ongoing request for a read or write lock.
     * <p>
     * Note: there might be here a race, where another thread acquired the lock and 
     * actually locked it, i) just after this method tests the presence of read or write locks 
     * and ongoing requests for a read or write lock, 
     * and ii) just before removing it from the map.
     * To solve this issue, methods acquiring a lock must check after locking it 
     * whether it is still in the readWriteLocks map, 
     * or whether the element present in the map for the key is equal to the acquired lock. 
     * If it is not, they must generate a new lock to be used.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}, to remove it. This key is generated by the method
     *              {@code generateKey}
     * @see         #generateKey(String)
     * @see         #readWriteLocks
     */
    private void removeLockIfPossible(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock lock = readWriteLocks.get(key);
        //there is a lock to remove
        if (lock != null) {
            //there is no thread with write lock, or read lock, or waiting to acquire a lock
            if (!lock.isWriteLocked() && lock.getReadLockCount() == 0 && !lock.hasQueuedThreads()) {
                readWriteLocks.remove(key);
            }
        }

        log.exit();
    }

    /**
     * Obtain a {@code ReentrantReadWriteLock}, for the param {@code key}.
     * 
     * This method tries to obtain {@code ReentrantReadWriteLock} corresponding to the key, 
     * from the {@code ConcurrentHashMap} {@code readWriteLocks}. 
     * If the lock is not already stored, 
     * create a new one, and put it in {@code readWriteLocks}, to be used by other threads.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}. This key is generated by the method {@code generateKey}
     * @return  a {@code ReentrantReadWriteLock} corresponding to the key.
     * @see #generateKey(String)
     * @see #readWriteLocks
     */
    private ReentrantReadWriteLock getReadWriteLock(String key) {
        log.entry(key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock readWritelock = readWriteLocks.get(key);

        //no lock already stored
        if (readWritelock == null) {
            ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(true);
            //try to put the new lock in the ConcurrentHashMap
            readWritelock = readWriteLocks.putIfAbsent(key, newReadWriteLock);
            //if readWritelock is null, the newLock has been successfully put in the map, and we use it.
            //otherwise, it means that another thread has inserted a new lock for this key in the mean time.
            //readWritelock then corresponds to this value, that we should use.
            if (readWritelock == null) {
                readWritelock = newReadWriteLock;
            }
        }

        return log.exit(readWritelock);
    }

    /**
     * Generate the search and hash parts of URLs. This method takes care 
     * of checking whether the generated URL is too long, and if it is, 
     * of launching the generation of the key needed to store the storable parameters, 
     * the storage on server, and to re-generate the query URL accordingly.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL. 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     */
    private void generateParametersQuery(String parametersSeparator,
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams) 
                    throws RequestParametersNotStorableException {
        log.entry(parametersSeparator, searchOrHashParams, areSearchParams);

        // If there is a key already present, continue to work with a key
        String previousKey = this.getDataKey();
        boolean toStore = false;
        if(StringUtils.isNotBlank(this.getDataKey())){
            // Regenerate the key in case a storable param has changed
            // Always use & as separator to generate the key, so the key is the same for 
            // the same parameters, no matter the separator provided.
            // Also, never use searchOrHashParams provided, so that all the parameters are always 
            // in the search part of the URL to generate the key.
            this.generateKey(this.generateParametersQuery(null, true, false,"&", null, false));
            // Regenerate the parameters query, with the non storable that include
            // the key parameter
            this.parametersQuery = generateParametersQuery(null, false, true,parametersSeparator, 
                    searchOrHashParams, areSearchParams);
            //if the key has changed, we need to store again this RequestParameters
            if (StringUtils.isNotBlank(this.getDataKey()) && !this.getDataKey().equals(previousKey)) {
                toStore = true;
            }
        } else{
            // No key for the moment, generate the query and then evaluate if its
            // length is still under the threshold at which the key is used
            this.parametersQuery = generateParametersQuery(null, true, true,parametersSeparator, 
                    searchOrHashParams, areSearchParams);
            if(this.isUrlTooLong()){
                // Generate the key, store the values and regenerate the query
                // Always use & as separator to generate the key, so the key is the same for 
                // the same parameters, no matter the separator provided. 
                // Also, never use searchOrHashParams provided, so that all the parameters 
                // are always in the search part of the URL to generate the key.
                this.generateKey(this.generateParametersQuery(null, true, false,"&", null, false));
                if(StringUtils.isNotBlank(this.getDataKey())){
                    toStore = true;
                }
            }    
        }
        if (toStore) {
            this.store();
            this.generateParametersQuery(parametersSeparator, 
                    searchOrHashParams, areSearchParams);
        }

        log.exit();
    }

    /**
     * Generate the query from the current state of the parameters, providing the separator 
     * to use between parameters, and {@code boolean}s defining whether storable and/or 
     * non-storable parameters should be included. This method does not take care 
     * of generating a key if the URL is too long, to store the parameters on server 
     * if needed, etc. This is responsibility of the method 
     * {@link #generateParametersQuery(String, Set, boolean)}. This method simply generates 
     * the URL from the parameters. 
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * <p>
     * This method has a js counterpart in {@code requestparameters.js}, called getRequestURL(),
     * that should be kept consistent as much as possible if the method evolves.
     * 
     * @param targetedParams        A {@code Set} of {@code Parameter}s, allowing which parameters 
     *                              to use to produce the query string. If {@code null} or empty, 
     *                              then all parameters are used. 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL.
     * @param includeStorable       A {@code boolean} to indicate whether to include
     *                              the storable parameters.
     * @param includeNonStorable    A {@code boolean} to indicate whether to include
     *                              the non-storable parameters.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that is the generated query
     */
    private String generateParametersQuery(Set<URLParameters.Parameter<?>> targetedParams, 
            boolean includeStorable, boolean includeNonStorable, String parametersSeparator, 
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams){

        log.entry(targetedParams, includeStorable, includeNonStorable, parametersSeparator, 
                searchOrHashParams, areSearchParams);

        String urlFragment = "";

        // Browse all available parameters. 
        // We will potentially do it twice, to store the parameters either in the search part, 
        //or the hash part of the URL, depending on searchOrHashParams and areSearchParams.
        boolean hashDone = false;
        boolean searchDone = false;
        while (!searchDone || !hashDone) {
            log.trace("Adding parameters for the part: search part ({})/hash part ({})", 
                    !searchDone, searchDone && !hashDone);
            if (searchOrHashParams == null) {
                //no need for a second pass if no param needed in hash
                log.trace("Storing all parameters in search part.");
                hashDone = true;
            }
            boolean paramAdded = false;
            boolean firstParam = true;
            for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){
                if (targetedParams != null && !targetedParams.isEmpty() && !targetedParams.contains(parameter)) {
                    log.trace("Skipping parameter because not targeted: {}", parameter);
                    continue;
                }
                //if a split between parameters in search and hash parts has been requested 
                if (searchOrHashParams != null) {
                    //first pass, store parameters in the search part of the URL
                    if (!searchDone) {
                        if (areSearchParams && !searchOrHashParams.contains(parameter) || 
                            !areSearchParams && searchOrHashParams.contains(parameter)) {
                            //parameter requested in hash, skip
                            continue;
                        }
                        log.trace("Parameter added to search part: {}", parameter);
                    } else {
                        //second pass, store parameters in the hash part of the URL
                        assert searchDone && !hashDone;
                        if (areSearchParams && searchOrHashParams.contains(parameter) || 
                            !areSearchParams && !searchOrHashParams.contains(parameter)) {
                            //parameter requested in search part, skip
                            continue;
                        }
                        log.trace("Parameter added to hash part: {}", parameter);
                        //if this is the first parameter stored in the hash, 
                        // we add the hash separator.
                        if (firstParam) {
                            urlFragment += JS_HASH_SEPARATOR;
                        }
                        firstParam = false;
                    }
                }
                // If it is one of the param to include, proceed...
                if((includeStorable && parameter.isStorable()) || (includeNonStorable 
                        && !parameter.isStorable())){
                    // Fetch the values of this param and generate a query with all
                    // its values
                    String paramFragment = this.generateParameterQueryStringFragment(parameter, 
                            this.getValues(parameter), parametersSeparator);
                    if (StringUtils.isNotBlank(paramFragment)) {
                        urlFragment += paramFragment + parametersSeparator;
                        paramAdded = true;
                    }
                }
            }

            // Remove the extra separator at the end 
            if(paramAdded){
                int paramSeparatorLength = parametersSeparator.length();
                urlFragment = urlFragment.substring(0, urlFragment.length()-paramSeparatorLength);
            }
            
            //if searchDone is true, the first pass was already done, 
            //this was the end of the second pass.
            if (searchDone) {
                hashDone = true;
            }
            //will be set to true at the end of the first pass.
            searchDone = true;
            log.trace("URL fragment at the end of the pass: {}", urlFragment);
        }

        return log.exit(urlFragment);
    }
    
    /**
     * Generates the URL query string fragment related to {@code parameter}, using the values 
     * provided in {@code parameterValues}. Values are URL encoded (see {@link #urlEncode(String)}). 
     * 
     * @param parameter             A {@code URLParameters.Parameter} whose values should be 
     *                              written in an URL query string.
     * @param parameterValues       A {@code List} containing the values associated to 
     *                              {@code parameter}.
     * @param parameterSeparator    A {@code String} that is used as parameter separator 
     *                              in the URL.
     * @return                  A {@code String} that is the resulting URL query string fragment. 
     *                          Empty if no values were written. It does not finish with 
     *                          {@link #parametersSeparator}.
     * @throws IllegalArgumentException If the type of a value does not correspond to 
     *                                  type associated to {@code parameter} (see {@link 
     *                                  URLParameters.Parameter#getType()}).
     */
    private String generateParameterQueryStringFragment(URLParameters.Parameter<?> parameter, 
            List<?> parameterValues, String parameterSeparator) {
        log.entry(parameter, parameterValues, parameterSeparator);
        if (parameterValues == null || parameterValues.isEmpty()) {
            return log.exit("");
        }

        //If the parameter can hold several values provided as a single String 
        //(e.g., list of IDs separated by a line return in a textarea), 
        //we need to regenerate a single String from the multiple values
        List<?> valuesToUse = parameterValues;
        if (parameter.allowsSeparatedValues()) {
            String separatedValues = parameterValues.stream()
                    .filter(v -> v != null && StringUtils.isNotBlank(v.toString()))
                    .map(Object::toString)
                    .collect(Collectors.joining(parameter.getSeparators().get(0)));
            valuesToUse = Arrays.asList(separatedValues);
        } 
        
        return log.exit(valuesToUse.stream()
            .filter(value -> value != null && StringUtils.isNotBlank(value.toString()))
            .map(value -> {
                if (!parameter.getType().equals(value.getClass())) {
                    throw log.throwing(new IllegalArgumentException("The value type ("
                            + value.getClass().getSimpleName() 
                            + " does not correspond to the parameter type ("
                            + parameter.getType().getSimpleName()));
                }
                return parameter.getName() + "=" + this.urlEncode(value.toString());
            })
            .collect(Collectors.joining(parameterSeparator)));
    }

    /** 
     * Determine whether the submitted {@code String}, representing an URL, 
     * exceeds the URL length restriction. 
     * See {@code BgeeProperties#getUrlMaxLength} for more details.
     * 
     * @return  {@code true} if the {@code String}, representing an URL, exceeds the max allowed
     *          URL length. {@code false} otherwise.
     *          
     * @see BgeeProperties#getUrlMaxLength
     */
    private boolean isUrlTooLong() {

        log.entry();
        if (log.isTraceEnabled()) {
            log.trace("length of query: {} - max URL length: {}", 
                    this.parametersQuery.length(), prop.getUrlMaxLength());
        }
        if (this.parametersQuery.length() > prop.getUrlMaxLength()) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Generate a key to set the parameter {@code URLParameters.getParamData}, 
     * based on {@code urlFragment}, 
     * in order to keep the storable parameters of this  {@code RequestParameters} object
     * on the disk
     * 
     * This key is a hash of an URL fragment generated from the storable attributes
     * of this object, without any length restriction (all the storable attributes are then
     * represented). 
     * It will be used as an index to store and retrieve the storable part of this
     * {@code RequestParameters} object.
     * <p>
     * A new call to this method will then trigger the computation of a new key.
     * 
     * @param urlFragment   The fragment of URL based on the storable parameters
     *                                                  
     * @see #store()
     */
    private void generateKey(String urlFragment) {
        log.entry(urlFragment);

        log.info("Trying to generate a key based on urlFragment: {}", urlFragment);

        if (StringUtils.isNotBlank(urlFragment)) {
            // Reset the present key and add the new one
            this.resetValues(this.getKeyParam());
            try {
                this.addValue(this.getKeyParam(), 
                        DigestUtils.sha1Hex(urlFragment.toLowerCase(Locale.ENGLISH)));
            } catch (MultipleValuesNotAllowedException | InvalidFormatException e) {
                // In this particular case, should never be thrown.
                throw log.throwing(new AssertionError("Unreachable code reached in generateKey", e));
            }
        }

        log.info("Key generated: {}", this.getFirstValue(
                this.getKeyParam()));

        log.exit();
    }

    /**
     * Encode String to be used in URLs. 
     * This method is different from the {@code encodeURL} method 
     * of {@code HttpServletResponse}, as it does not include a logic 
     * for session tracking. It just converts special chars to be used in URL.
     * The encoding can be desactivated by setting the {@code encodeUrl} attribute to
     * {@code false}.
     *  
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param url   the {@code String} to be encoded.
     * @return  a {@code String} encoded, if needed (meaning, if including special chars), 
     *          and if the {@code encodeUrl} attribute is {@code true}
     * 
     * @see #encodeUrl
     */
    private String urlEncode(String url){

        log.entry(url);

        String encodeString = url;

        if (!this.encodeUrl) {
            return encodeString;
        }
        try {
            // "In Tomcat 8 starting with 8.0.0 (8.0.0-RC3, to be specific), the default value 
            // of URIEncoding attribute on the <Connector> element depends on 'strict servlet 
            // compliance' setting. The default value (strict compliance is off) of URIEncoding 
            // is now UTF-8. If 'strict servlet compliance' is enabled, the default value 
            // is ISO-8859-1. 
            // => So we should now be fine when using UTF-8 for character encoding.
            // See https://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q8
            encodeString = java.net.URLEncoder.encode(url, this.getCharacterEncoding());
        } catch (Exception e) {
            log.error("Error while URLencoding", e);
        }
        return log.exit(encodeString);
    }

    /**
     * Decode String that was received through the URL.
     * 
     * @param url   the {@code String} to be decoded.
     * @return      A {@code String} decoded
     * 
     * @see #encodeUrl
     */
    private String urlDecode(String url) throws UnsupportedEncodingException {
        log.entry(url);
        return log.exit(java.net.URLDecoder.decode(url, this.getCharacterEncoding()));
    }

    /**
     * @return The Parameter<String> that contains the key used to store the storable parameters
     */
    private Parameter<String> getKeyParam(){
        log.entry();
        return log.exit(this.urlParametersInstance.getParamData());
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    public String getRequestURL() throws RequestParametersNotStorableException {
        log.entry();
        return log.exit(this.getRequestURL(this.parametersSeparator));
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator}.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    //TODO : is this method still useful now if we can set the parameter separator ?
    public String getRequestURL(String parametersSeparator) 
            throws RequestParametersNotStorableException {
        log.entry(parametersSeparator);
        return log.exit(this.getRequestURL(parametersSeparator, null, false));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    public String getRequestURL(Collection<URLParameters.Parameter<?>> searchOrHashParams, 
            boolean areSearchParams) throws RequestParametersNotStorableException, 
            IllegalStateException {
        log.entry(searchOrHashParams, areSearchParams);
        return log.exit(this.getRequestURL(this.parametersSeparator, 
                searchOrHashParams, areSearchParams));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator(String)}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    //XXX: This method has a js counterpart in {@code requestparameters.js} that should be kept 
    //consistent as much as possible if the method evolves.
    public String getRequestURL(String parametersSeparator, 
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams) 
            throws RequestParametersNotStorableException, IllegalStateException {
        log.entry(parametersSeparator, searchOrHashParams, areSearchParams);
        this.generateParametersQuery(parametersSeparator, searchOrHashParams, areSearchParams);
        
        String url = "";
        if (StringUtils.isNotBlank(this.prop.getBgeeRootDirectory())) {
            url += this.prop.getBgeeRootDirectory();
        } else {
            log.warn("No root folder for URL set, using '/'");
            url += "/";
        }
        
        if (StringUtils.isNotBlank(this.parametersQuery)) {
            //if the query stores the parameters only in the hash part of the URL, 
            //we do not prepend '?', it will start with the hash separator
            if (!this.parametersQuery.startsWith(JS_HASH_SEPARATOR)) {
                url += "?";
            }
            url += this.parametersQuery;
        }
        //if hash needs to be added (to really link to an element with corresponding ID 
        //on a page, not to provide parameters readable/writable with javascript),
        if (StringUtils.isNotBlank(this.getURLHash())) {
            //check whether the hash is already used to store data parameters. 
            //It is not possible to simply test whether searchOrHashParams is not null, 
            //because it is still possible to store all parameters in search part of URLs 
            //even if searchOrHashParams is not null. So we look for the hash separator 
            //when used for storing data parameters.
            if (this.parametersQuery.contains(JS_HASH_SEPARATOR)) {
                throw log.throwing(new IllegalStateException("It is not possible "
                        + "to store data parameters in the hash part of URLs "
                        + "while also trying to use a classical anchor (you previously called "
                        + "the method setURLHash on this object)."));
            }
            url += "#" + this.getURLHash();
        }
        return log.exit(url);
    }

    /**
     * Return all the values for the given {@code URLParameters.Parameter<T>} 
     * in a {@code List<T>} or null if it is empty.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} that corresponds 
     *                  to the values to be returned
     *                  
     * @return  an {@code List<T>} of values
     */
    public <T> List<T> getValues(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        // Because the data type of URLParameters.Parameter is always checked 
        // when the value is stored, it is safe to not check.
        @SuppressWarnings("unchecked")
        ArrayList<T> values = (ArrayList<T>) this.values.get(parameter);

        try{
            // Return a copy of the list and not the original list
            // As the values contained are only immutable object, such as String
            // Integer, Boolean, Long, there is no need to clone the content
            return log.exit(new ArrayList<T>(values));

        } catch(NullPointerException e){
            return log.exit(null);
        }
    }

    /**
     * Return the first value of the given {@code URLParameters.Parameter<T>} 
     * or null if it is empty
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter the {@code URLParameters.Parameter<T>} 
     *                  that corresponds to the value to be returned
     *                  
     * @return  a {@code T}, the value
     */
    @SuppressWarnings("unchecked")    // Because the data type of URLParameters.Parameter
    // is always checked when the value is stored, it should be safe.
    public <T> T getFirstValue(URLParameters.Parameter<T> parameter){

        log.entry(parameter);
        try{

        	return log.exit(((List<T>) this.values.get(parameter)).get(0));

        } catch(IndexOutOfBoundsException | NullPointerException e){
            return log.exit(null);            
        }
    }

    /**
     * Add a value to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * 
     * @param value     A {@code T}, the value to set
     * 
     * 
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public <T> void addValue(URLParameters.Parameter<T> parameter, T value) 
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.entry(parameter, value);

        if (value == null) {
            log.exit(); return;
        }
        this.addValues(parameter, Arrays.asList(value));
        
        log.exit();
    }
    /**
     * Add values to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * @param values    A {@code List} of {@code T}s, the values to set
     * @throws MultipleValuesNotAllowedException    If more than one value is present in the
     *                                              {@code request} for a
     *                                              {@link URLParameters.Parameter} that
     *                                              does not allow multiple values.
     * @throws InvalidFormatException                 A value in the {@code request} does not
     *                                              fit the format requirement for related
     *                                              {@link URLParameters.Parameter}
     */
    public <T> void addValues(URLParameters.Parameter<T> parameter, List<T> values)
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.entry(parameter, values);
    
        this.addAnyValues(parameter, values);
    
        log.exit();
    }
    /**
     * Add values associated to the {@code URLParameters.Parameter}.
     *  
     * @param parameter The {@code URLParameters.Parameter} to add the value to.
     * @param values    A {@code List} of {@code Object}s to associate to {@code parameter}.
     * 
     * @throws IllegalArgumentException             If the type of any object in {@code value}s 
     *                                              is different from the type returned by 
     *                                              {@code URLParameters.Parameter.getType()}.
     * @throws InvalidFormatException               If the value in the {@code request} does not
     *                                              fit the format requirement for {parameter}.
     * @throws MultipleValuesNotAllowedException    If more than one value is present in the
     *                                              {@code request} for a {@link URLParameters.Parameter}
     *                                              that does not allow multiple values.
     * @throws RequestSizeExceededException         If the overall size of the request exceeds 
     *                                              the max allowed size, following the addition 
     *                                              of this parameter value.
     */
    private void addAnyValues(URLParameters.Parameter<?> parameter, List<?> values) 
            throws IllegalArgumentException, InvalidFormatException, MultipleValuesNotAllowedException, 
            RequestSizeExceededException {
        log.entry(parameter, values);

        if (values == null || values.isEmpty()) {
            log.exit(); return;
        }
        if (values.stream().anyMatch(e -> !parameter.getType().equals(e.getClass()))) {
            throw log.throwing(new IllegalArgumentException("The class of one of the provided value ("
                    + values + ") is incompatible with "
                    + "the parameter (" + parameter.getType().getSimpleName()));
        }

        //map the values to add 
        List<Object> newVals = values.stream().map(e -> {
            if (parameter.getType().equals(String.class)) {
                return this.secureString(e.toString(), parameter);
            }
            return e;
        }).filter(e -> e != null && 
                (!parameter.getType().equals(String.class) || 
                 StringUtils.isNotBlank(e.toString())))
        .collect(Collectors.toList());
        
        if (newVals.isEmpty()) {
            log.exit(); return;
        }
        
        // fetch the existing values for the given parameter and try to add the value
        List<Object> parameterValues = this.values.get(parameter);
        // Throw an exception if the param does not allow 
        // multiple values and has already one, or contains several values
        if (!parameter.allowsMultipleValues() && !parameter.allowsSeparatedValues() && 
                (parameterValues != null && !parameterValues.isEmpty() || newVals.size() > 1)) {
            throw(new MultipleValuesNotAllowedException(parameter));
        }
        
        //OK, add value
        if (parameterValues == null) {
            parameterValues = new ArrayList<>();
            this.values.put(parameter, parameterValues);
        }
        parameterValues.addAll(newVals);
        
        //Now, we check whether all parameters considered together exceed the global 
        //max request length defined, following the addition of this parameter. 
        int globalQueryLength = this.generateParametersQuery(null, true, true, "&", null, true)
                .length();
        if (globalQueryLength > this.secureMaxURLLength) {
            log.error("Max request size exceeded, current: {} - max allowed: {}", globalQueryLength, 
                    this.secureMaxURLLength);
            throw log.throwing(new RequestSizeExceededException());
        }
        
        //then, if this parameter is a separated-value parameter, then we need to check 
        //whether the overall length of the updated parameter value exceeds its max allowed length.
        if (parameter.allowsSeparatedValues()) {
            String urlFragment = this.generateParameterQueryStringFragment(parameter, parameterValues, "&");
            //remove the parameter name from the beginning of the URL fragment
            String fragmentStart = parameter.getName() + "=";
            if (!urlFragment.startsWith(fragmentStart)) {
                throw log.throwing(new IllegalStateException("The URL fragment produced "
                        + "does not have the expected prefix, expected " + fragmentStart 
                        + ". Actual fragment: " + fragmentStart));
            }
            this.throwIfParamValueTooLong(parameter, urlFragment.substring(fragmentStart.length()));
        }
        
        log.exit();
    }

    /**
     * Reset the value for the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to reset
     */
    public <T>  void resetValues(URLParameters.Parameter<T> parameter) 
    {
        log.entry(parameter);
        this.values.put(parameter, null);
        log.exit();
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * with all parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with all parameter copied.
     *             
     */
    public RequestParameters cloneWithAllParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(true));
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * but only with the "storable" parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with the same values for "storable" as this one, 
     *             but with "non-storable" parameters simply initialized.
     */
    public RequestParameters cloneWithStorableParameters(){
        log.entry();
        return log.exit(this.cloneRequestParameter(false));
    }

    /**
     * Method that actually proceed to the cloning and is called by 
     * {@link #cloneWithAllParameters()} and {@link #cloneWithStorableParameters()}
     * @param includeNonStorable    A boolean to tell whether to keep the non storable parameters
     * @return     a new {@code RequestParameters} object, with or without the non storable 
     *             parameters depending on {@code includeNonStorable}
     */
    private RequestParameters cloneRequestParameter(boolean includeNonStorable){
        log.entry(includeNonStorable);
        //to avoid duplicating methods, 
        //we we simulate a HttpServletRequest with a query string 
        //we provide holding storable parameters of this object
        String queryString = this.generateParametersQuery(null, true, includeNonStorable, "&", 
                null, false);
        BgeeHttpServletRequest request = new BgeeHttpServletRequest(queryString, this.getCharacterEncoding());
        RequestParameters clonedRequestParameters = null;
        try {
            clonedRequestParameters = new RequestParameters(request, 
                    this.urlParametersInstance.getClass().newInstance(),this.prop,
                    this.encodeUrl, this.parametersSeparator, this.charEncoding, this.secureMaxURLLength);
            if (!includeNonStorable){
                // Add the key which is not a storable parameters and was not included
                clonedRequestParameters.addValue(this.getKeyParam(), 
                        this.getFirstValue(this.getKeyParam()));
            }
            log.trace("Cloned RequestParameters generated: {}", clonedRequestParameters);
        } catch ( RequestParametersNotFoundException
                | MultipleValuesNotAllowedException | InvalidFormatException e) {
            // In this particular case, should never be thrown.
            throw log.throwing(new AssertionError("Code supposed to be unreachable", e));
        } catch (InstantiationException | IllegalAccessException e) {
            throw log.throwing(new IllegalStateException(e));
        }
        return log.exit(clonedRequestParameters);
    }

    /**
     * @return  An instance of {@code URLParameters} that provides all the
     *          {@code URLParameters.Parameter} that can be present in the request
     */
    public URLParameters getUrlParametersInstance() {
        return urlParametersInstance;
    }

    /**
     * @return  A {@code String } that is the name of the HTTP method with which this request
     *          was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    public String getHttpMethod() {
        return this.httpMethod;
    }

    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code page} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getPage() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPage());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param page  A {@code String} that is the value of the {@code page} URL parameter to set.
     */
    public void setPage(String page) {
        this.resetValues(this.getUrlParametersInstance().getParamPage());
        this.addValue(this.getUrlParametersInstance().getParamPage(), page);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code action} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getAction() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamAction());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code action} URL parameter 
     *                  to set.
     */
    public void setAction(String action) {
        this.resetValues(this.getUrlParametersInstance().getParamAction());
        this.addValue(this.getUrlParametersInstance().getParamAction(), action);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamData()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getDataKey() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamData());
    }
    
    /**
     * @return the gene_id parameter
     */
    public String getGeneId() {
    	return this.getFirstValue(this.getUrlParametersInstance().getParamGeneId());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamGeneId()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param geneId    A {@code String} that is the value of the {@code gene_id} URL parameter 
     *                  to set.
     */
    public void setGeneId(String geneId) {
        this.resetValues(this.getUrlParametersInstance().getParamGeneId());
        this.addValue(this.getUrlParametersInstance().getParamGeneId(), geneId);
    }

    /**
     * @return the species_id parameter
     */
    public Integer getSpeciesId() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamSpeciesId());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamSpeciesId()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param speciesId     An {@code Integer} that is the value of the {@code species_id}
     *                      URL parameter to set.
     */
    public void setSpeciesId(Integer speciesId) {
        this.resetValues(this.getUrlParametersInstance().getParamSpeciesId());
        this.addValue(this.getUrlParametersInstance().getParamSpeciesId(), speciesId);
    }

    /**
     * @return the search parameter
     */
    public String getSearch() {
    	return this.getFirstValue(this.getUrlParametersInstance().getParamSearch());
    }

    /**
     * @return A {@code String} that will be used as the hash part of URLs returned by 
     *         the  {@code getRequestURL} methods. See {@link #setURLHash(String)} 
     *         for more details.
     * @see #setURLHash(String)
     */
    public String getURLHash() {
        return urlHash;
    }
    /**
     * Set the 'hash' to be added at the end of the URLs generated by the {@code getRequestURL} 
     * methods. This method should be used only to actually link to an element 
     * with the corresponding ID in a page. It should not be used to use the hash 
     * to store data parameters (for instance, to link to pages where the hash part 
     * is used by javascript to read/write data parameters). For this latter use, 
     * see {@link #getRequestURL(Collection, boolean)} and {@link #getRequestURL(String, Collection, boolean)}.
     * <p>
     * Note that {@code urlHash} must not include the hash separator ('#').
     * 
     * @param urlHash   A {@code String} that will be used as the hash part of URLs returned by 
     *                  the  {@code getRequestURL} methods.
     */
    public void setURLHash(String urlHash) {
        this.urlHash = urlHash;
    }

    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamDisplayType()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param displayType   A {@code String} that is the value of the {@code display_type}
     *                      URL parameter to set.
     */
    public void setDisplayType(String displayType) {
        this.resetValues(this.getUrlParametersInstance().getParamDisplayType());
        this.addValue(this.getUrlParametersInstance().getParamDisplayType(), displayType);
    }
    
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamSpeciesList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code species_list} URL parameter. Can be {@code null}. 
     */
    public List<Integer> getSpeciesList(){
        return this.getValues(this.getUrlParametersInstance().getParamSpeciesList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamForegroundList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code fg_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getForegroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamForegroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamForegroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code fg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getForegroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamForegroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code bg_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getBackgroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamBackgroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code bg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getBackgroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamBackgroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamExprType()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code expr_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getExprType() {
        return this.getValues(this.getUrlParametersInstance().getParamExprType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataQuality()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data_qual} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDataQuality() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDataQuality());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataType()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code data_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getDataType() {
        return this.getValues(this.getUrlParametersInstance().getParamDataType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDevStage()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code dev_stage} URL parameter. Can be {@code null}. 
     */
    public List<String> getDevStage() {
        return this.getValues(this.getUrlParametersInstance().getParamDevStage());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamDecorrelationType()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code decorr_type} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDecorrelationType() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDecorrelationType());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNodeSize()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code node_size} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNodeSize() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNodeSize());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNbNode()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code nb_node} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNbNode() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNbNode());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamFdrThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Double} that is the value of the {@code fdr_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Double getFdrThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamFdrThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPValueThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Double} that is the value of the {@code p_value_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Double getPValueThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPValueThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamJobId()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code job_id} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getJobId() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamJobId());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamGeneInfo()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code Boolean} that is the value of the {@code gene_info} URL parameter.
     *          Can be {@code null}. 
     */
    public Boolean getGeneInfo() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamGeneInfo());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamApiKey()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code api_key} URL parameter.
     *          Can be {@code null}. 
     */
    public String getApiKey() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamApiKey());
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Xml or not
     */
    public boolean isXmlDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_XML)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Csv or not
     */
    public boolean isCsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_CSV)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Tsv or not
     */
    public boolean isTsvDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_TSV)){
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is JSON or not
     */
    public boolean isJsonDisplayType() {
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_JSON)){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * Allow to know if this request has been performed through AJAX. 
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if this request was performed through AJAX
     */
    public boolean isAnAjaxRequest() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamAjax()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamAjax())) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the page corresponds to the homepage
     */
    public boolean isTheHomePage(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) == null){
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request is related to species.
     */
    public boolean isASpeciesPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SPECIES)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          species list upload.
     */
    public boolean isASpeciesUpload() {
        log.entry();
        if (isASpeciesPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_SPECIES_UPLOAD)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "about"
     */
    public boolean isAnAboutPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_ABOUT)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to job management.
     */
    public boolean isAJobPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to DAO queries.
     */
    public boolean isADAOPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DAO)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    
    /**
     * @return  A {@code boolean} to tell whether the request is related to BgeeDB_R package queries.
     */
    public boolean isARPackagePageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_RPACKAGE)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to queries for usage statistics 
     *          (meaning, queries made by clients solely for us to have usage statistics).
     */
    public boolean isAStatsPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_STATS)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether it is requested to cancel a job.
     */
    public boolean isACancelJob() {
        log.entry();
        if (this.isAJobPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_CANCEL_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request is related to topAnat.
     */
    public boolean isATopAnatPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_TOP_ANAT)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "admin"
//     */
//    public boolean isAnAdminPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("admin")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "anatomy"
//     */
//    public boolean isAnAnatomyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) == null || 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("anatomy")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          gene list upload in topAnat.
     */
    public boolean isATopAnatGeneUpload() {
        log.entry();
        if (isATopAnatPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_GENE_VALIDATION)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a submission of a submission of a new job in topAnat.
     */
    public boolean isATopAnatSubmitJob() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_SUBMIT_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a tracking job in topAnat.
     */
    public boolean isATopAnatTrackingJob() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_TRACKING_JOB)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          get a job in topAnat.
     */
    public boolean isATopAnatGetResult() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_GET_RESULT)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * @return  A {@code boolean} defining whether it is requested to send to client a result file 
     *          from TopAnat.
     */
    public boolean isATopAnatDownloadFile() {
        log.entry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_DOWNLOAD)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "documentation"
     */
    public boolean isADocumentationPageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOCUMENTATION)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "download"
     */
    public boolean isADownloadPageCategory(){
        log.entry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOWNLOAD)){
            return log.exit(true);
        }
        return log.exit(false);
    }    

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "expression"
//     */
//    public boolean isAnExpressionPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("expression")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "gene"
     */
    public boolean isAGenePageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_GENE)) {
            return log.exit(true);
        }
        return log.exit(false);
    }
    
    /**
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "source"
     */
    public boolean isASourcePageCategory() {
        log.entry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SOURCE)) {
            return log.exit(true);
        }
        return log.exit(false);
    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene_family"
//     */
//    public boolean isAGeneFamilyPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene_family")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "log"
//     */
//    public boolean isALogPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("log")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "news"
//     */
//    public boolean isANewsPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("news")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "registration"
//     */
//    public boolean isARegistrationPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("registration")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "search"
//     */
//    public boolean isASearchPageCategory()
//    {
//        log.entry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("search")) {
//            return log.exit(true);
//        }
//        return log.exit(false);
//    }

    /**
     * Determine whether the requested page contains sensitive information, 
     * such as passwords.
     * Such pages should then not be cached, or the URL be stored in the database, etc.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if the page contains sensitive information, {@code false} otherwise.
     */
    public boolean isASecuredPage() 
    {
        log.entry();
        //TODO: implement when necessary (logging page, registration page, ...)
        return log.exit(false);
    }

    /**
     * Determine whether the output of the current request can be stored by the web-cache.
     * Some responses should never be cached, following, e.g., a user identification request, 
     * or a HEAD request (would lead to cache a blank page). 
     * At the opposite, we might be interested in caching only some pages 
     * (e.g., computation-intensive pages are always computed following an AJAX request, 
     * in order to display a waiting message; we could then only cache AJAX requests).
     * <p>
     * Also, some cookies should never be put in cache, because specific to a user.
     * so that a cache will never send cookies. ( TODO : Probably no cookies in the future, but
     * developers have to be aware of the problem. Now your are ! )
     * 
     * @return  {@code true} if the response following the current request should be cached
     */
    public boolean isACacheableRequest()
    {
        log.entry();
        // Do not cache pages containing sensitive information
        if (this.isASecuredPage()) {
            return log.exit(false);
        }
        // Do not cache responses to HEAD requests, would lead to cache blank page
        // for security, we only accept POST and GET requests to be cached.
        // @see org.bgee.controller.servletUtils.BgeeWebCache#calculateKey(HttpServletRequest)
        if (!this.getHttpMethod().equalsIgnoreCase("get") && 
                !this.getHttpMethod().equalsIgnoreCase("post")) {
            return log.exit(false);
        }
        //do not cache POST request that are not AJAX requets: 
        //they should never send any response, and redirect the user to another page 
        //to avoid warning messages when pressing the back button.
        if(! this.isAnAjaxRequest() && this.getHttpMethod().equalsIgnoreCase("post")){
            return log.exit(false);
        }
        return log.exit(true);
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use, 
     * corresponding to the value of the provided parameter.
     * 
     * @param value     A {@code String} to be checked. 
     * @param parameter A {@code Parameter} which {@code stringToCheck} is 
     *                  the associated value, providing the security parameters 
     *                  (see {@link URLParameters.Parameter#getMaxSize()} and 
     *                  {@link URLParameters.Parameter#getFormat()})
     * @return          A secured and prepared {@code String}. 
     * @throws InvalidFormatException       if the format of {@code value} is invalid.
     * @throws ValueSizeExceededException   if {@code value} is too long.
     * @see #throwIfParamValueTooLong(URLParameters.Parameter, String)
     * @see #throwIfInvalidFormatParamValue(URLParameters.Parameter, String)
     */
    private String secureString(String value, URLParameters.Parameter<?> parameter) 
            throws InvalidFormatException, ValueSizeExceededException {
        log.entry(value, parameter);
        if (value == null) {
            return log.exit("");
        }
        this.throwIfParamValueTooLong(parameter, value);
        this.throwIfInvalidFormatParamValue(parameter, value);
        return log.exit(value.trim());
    }
    
    /**
     * Throws a {@code ValueSizeExceededException} if the length of {@code value} is greater 
     * than the max allowed length for {@code parameter} (see {@link URLParameters.Parameter#getMaxSize()}).
     * 
     * @param parameter An {@code URLParameters.Parameter} used to validate the length of {@code value}.
     * @param value     A {@code value} to be validated for maximum length.
     * @throws ValueSizeExceededException   if {@code value} is too long.
     */
    private void throwIfParamValueTooLong(URLParameters.Parameter<?> parameter, String value) 
            throws ValueSizeExceededException {
        log.entry(parameter, value);
        if (value == null) {
            log.exit(); return;
        }
        if (value.length() > parameter.getMaxSize()) {
            log.error("Value too long for parameter {}. Value length: {} - Max allowed length: {}", 
                    parameter, value.length(), parameter.getMaxSize());
            throw log.throwing(new ValueSizeExceededException(parameter));
        }
    }
    /**
     * Throws an {@code InvalidFormatException} if the format of {@code value} is invalid 
     * for {@code parameter} (see {@link URLParameters.Parameter#getFormat()}).
     * 
     * @param parameter An {@code URLParameters.Parameter} used to validate the format of {@code value}.
     * @param value     A {@code value} to be validated for correct format.
     * @throws InvalidFormatException   if the format of {@code value} is invalid.
     */
    private void throwIfInvalidFormatParamValue(URLParameters.Parameter<?> parameter, String value) 
            throws InvalidFormatException {
        log.entry(parameter, value);
        if (value == null) {
            log.exit(); return;
        }
        log.trace("Trying to validate {} against format {}", value, parameter.getFormat());
        if (parameter.getFormat() != null && !value.trim().matches(parameter.getFormat())) {
            log.error("The string {} does not match the format {}", value, parameter.getFormat());
            //do not provide the accepted format in the exception, we don't need to provide 
            //too much information to potential hackers :p
            throw log.throwing(new InvalidFormatException(parameter));
        }
    }

    /**
     * Transform {@code paramValue} into a {@code boolean}. This {@code String} should first 
     * have been secured (see {@link #secureString(String, int, String)}).
     * 
     * @param paramValue    A {@code String} corresponding to the value of a parameter 
     *                      in a request, to be converted into a {@code boolean}
     * @return  a {@code boolean} corresponding to {@code paramValue}. 
     *          Return {@code true} if {@code paramValue} is equal to "on", "true", or "1".
     */
    private boolean castToBoolean(String paramValue) {
        log.entry(paramValue);

        if (paramValue.equalsIgnoreCase("on") || 
                paramValue.equalsIgnoreCase("true") || 
                paramValue.equalsIgnoreCase("1")) {
            return log.exit(true);
        }
        return log.exit(false);
    }

    /**
     * @return  A {@code String} that is the character encoding used to encode/decode 
     *          query strings. 
     */
    public String getCharacterEncoding() {
        return this.charEncoding;
    }
    /**
     * Change the {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * @param encodeUrl A {@code boolean} defining whether parameters should be url encoded 
     *                  by the {@code encodeUrl} method.
     */
    public void setEncodeUrl(boolean encodeUrl) {
        this.encodeUrl = encodeUrl;
    }

    /**
     * Change the {@code String} defining the character(s) that are used as parameters 
     * separator in the URL   
     * @param parametersSeparator A {@code String} defining the character(s) that are used as 
     * parameters separator in the URL   
     */
    public void setParametersSeparator(String parametersSeparator) {
        this.parametersSeparator = parametersSeparator;
    }
}