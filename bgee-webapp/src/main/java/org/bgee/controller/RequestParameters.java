package org.bgee.controller;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.controller.URLParameters.Parameter;
import org.bgee.controller.exception.MultipleValuesNotAllowedException;
import org.bgee.controller.exception.RequestParametersNotFoundException;
import org.bgee.controller.exception.RequestParametersNotStorableException;
import org.bgee.controller.exception.RequestSizeExceededException;
import org.bgee.controller.exception.ValueSizeExceededException;
import org.bgee.controller.exception.InvalidFormatException;
import org.bgee.controller.servletutils.BgeeHttpServletRequest;
import org.bgee.model.expressiondata.baseelements.SummaryQuality;

/**
 * This class is intended to hold parameters of a query to the server, 
 * and also to generate URLs based on these parameters. 
 * <p>
 * This class can analyze a {@code HttpServletRequest} to extract 
 * and secure relevant parameters of a query to the server. 
 * It is also able to generate URLs based on these parameters, 
 * so that all links generated by the View are constructed by this class.
 * <p>
 * The parameters are represented by the class {@link URLParameters.Parameter}
 * and accessible through the class
 * {@link URLParameters} that provides individual access to each
 * {@code URLParameters.Parameter} or a
 * {@code List} that contains all existing {@code URLParameters.Parameter}.
 * These parameters are used by the present class as key to store their values in a 
 * {@code HashMap} 
 * <p>
 * When parameters are too long to be passed through URLs (because exceeding 
 * {@link BgeeProperties#getUrlMaxLength}, 
 * the query string is saved on disk for a later use. This mechanism is used,
 * rather than just putting parameters in session, so that parameters are 
 * indefinitely stored, and can be retrieved through an ID at any time.
 * <p>
 * The idea is: if, through a form, a user submit parameters that can be put in URL, 
 * then so be it. But if the user submit, for instance, a list of thousands of 
 * gene IDs, that cannot be passed through URLs because of URLs length
 * limitation, these parameters will be stored on disk: 
 * the query string will be stored in a file, 
 * an ID will be generated to be used as an index to retrieve the file, 
 * and this ID will be passed in URL, 
 * so that the parameters can be retrieved indefinitely. 
 * <p>
 * There are two "big" categories of parameters: "storable" parameters, 
 * that are potentially linked to large data submission, 
 * and "non-storable" parameters, that should never be responsible of large data 
 * submission, and that are meaningful in the URL.
 * Only storable parameters are used to generate IDs, to be stored, and to be 
 * retrieved using the ID provided in the URL. 
 * The properties {@link URLParameters.Parameter#isStorable} tells whether 
 * the parameter is storable or not.
 * 
 * This class has a js counterpart called {@code requestparameters.js} that should be kept 
 * consistent as much as possible if the class evolves.
 * 
 * @author  Mathieu Seppey
 * @author  Frederic Bastian
 * @author  Valentine Rech de Laval
 * @version Bgee 15.0, Jan. 2023
 * @since   Bgee 1
 */
public class RequestParameters {

    private final static Logger log = LogManager.getLogger(RequestParameters.class.getName());

    /**
     * {@code ConcurrentMap} used to manage concurrent access to 
     * the read/write locks that are used to manage concurrent reading and writing 
     * of the files storing query strings holding storable parameters. 
     * The generated key of the {@code RequestParameters} object to be 
     * loaded or stored is associated to the lock in this {@code Map}.
     * 
     * @see #store()
     * @see #loadStorableParametersFromKey(String)
     */
    private static final ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks = 
            new ConcurrentHashMap<>();
    
    /**
     * A {@code String} that is the default value of character encoding for encoding and 
     * decoding query strings.
     */
    public static final String CHAR_ENCODING = "UTF-8";
    /**
     * A {@code String} that is a magic value to select all possible values of a parameter 
     * accepting multiple values from an {@code Enum}.
     */
    public static final String ALL_VALUE = "all";
    
    /**
     * An {@code int} that is the maximum total length of the parameters, 
     * whether provided by POST or GET method, for security reasons.
     */
    // XXX: could be moved to URLParameters, in which case we should add a getter method to
    // URLParameters class to access this parameter
    private static final int SECURE_MAX_URL_LENGTH = 100000000;

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOWNLOAD = "download";

    /**
    * A {@code String} that is the value taken by the {@code page} parameter 
    * (see {@link URLParameters#getParamPage()}) when a resources page is requested.
    */
    public static final String PAGE_RESOURCES = "resources";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a download page is requested.
     */
    public static final String PAGE_DOCUMENTATION = "doc";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to SPARQL is requested.
     */
    public static final String PAGE_SPARQL = "sparql";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a about page is requested.
     */
    public static final String PAGE_ABOUT = "about";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a publication page is requested.
     */
    public static final String PAGE_PUBLICATION = "publication";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a species page is requested.
     */
    public static final String PAGE_SPECIES = "species";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to topAnat is requested.
     */
    public static final String PAGE_TOP_ANAT = "top_anat";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to
     * anatomical similarities is requested.
     */
    public static final String PAGE_ANAT_SIM = "anat_similarities";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to job management is requested.
     */
    public static final String PAGE_JOB = "job";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to DAO queries is requested.
     */
    public static final String PAGE_DAO = "dao";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to R package queries is requested.
     */
    public static final String PAGE_RPACKAGE = "r_package";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a query is made for usage statistics gathering.
     */
    public static final String PAGE_STATS = "stats";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to a gene is requested.
     */
    public static final String PAGE_GENE = "gene";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to expression comparison is requested.
     */
    public static final String PAGE_EXPR_COMPARISON = "expression_comparison";
    
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to a raw data is requested.
     */
    public static final String PAGE_DATA = "data";

    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to sources is requested.
     */
    public static final String PAGE_SOURCE = "source";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to search is requested.
     */
    public static final String PAGE_SEARCH = "search";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to privacy policy is requested.
     */
    public static final String PAGE_PRIVACY_POLICY = "privacy_policy";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter 
     * (see {@link URLParameters#getParamPage()}) when a page related to collaborations is requested.
     */
    public static final String PAGE_COLLABORATIONS = "collaborations";
    /**
     * A {@code String} that is the value taken by the {@code page} parameter
     * (see {@link URLParameters#getParamPage()}) when a page related to sending a feedback is requested.
     */
    public static final String PAGE_FEEDBACK = "feedback";
    /**
     * A {@code String} that encapsulates the value of the gene id parameter for the gene page.
     */
    public static final String GENE_ID = "gene_id";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_CALL_FILES = "expr_calls";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWLOAD_PROC_VALUE_FILES = "proc_values";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when download page about dumps
     * is requested. Value of the parameter page should be 
     * {@link #PAGE_DOWNLOAD}.
     */
    public static final String ACTION_DOWNLOAD_DUMPS = "dumps";
    
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing calls of expression is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_CALL_DOWLOAD_FILES = "call_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_PROC_EXPR_VALUE_DOWLOAD_FILES = "proc_value_files";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about download files 
     * providing processed expression values is requested. Value of the parameter page should be 
     * {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_TOP_ANAT = "top_anat";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when documentation about data sets  
     * is requested. Value of the parameter page should be {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_DATA_SETS = "data_sets";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when FAQ is requested.
     * Value of the parameter page should be {@link #PAGE_DOCUMENTATION}.
     */
    public static final String ACTION_DOC_FAQ = "faq";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a species data is requested.
     * Value of the parameter page should be {@link #PAGE_SPECIES}.
     */
    public static final String ACTION_SPECIES_UPLOAD = "species_upload";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a gene list validation is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_GENE_VALIDATION = "gene_validation";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a submission of a new job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_SUBMIT_JOB = "submit_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a tracking job is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_TRACKING_JOB = "tracking_job";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when a result is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_GET_RESULT = "get_results";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when the downloading of a result file is requested.
     * Value of the parameter page should be {@link #PAGE_TOP_ANAT}.
     */
    public static final String ACTION_TOP_ANAT_DOWNLOAD = "download";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when the canceling of a job is requested.
     * Value of the parameter page should be {@link #PAGE_JOB}.
     */
    public static final String ACTION_CANCEL_JOB = "cancel";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when auto-complete gene search is requested.
     * Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_AUTO_COMPLETE_GENE_SEARCH = "auto_complete_gene_search";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when expasy result is requested.
     * Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_EXPASY_RESULT = "expasy_result";

    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when search of anat. entities
     * result is requested.
     * Value of the parameter page should be {@link #PAGE_SEARCH}.
     */
    public static final String ACTION_SEARCH_ANAT_ENTITIES = "anat_entity";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when search of strains
     * result is requested.
     * Value of the parameter page should be {@link #PAGE_SEARCH}.
     */
    public static final String ACTION_SEARCH_STRAINS = "strain";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when search of cell types
     * result is requested.
     * Value of the parameter page should be {@link #PAGE_SEARCH}.
     */
    public static final String ACTION_SEARCH_CELL_TYPES = "cell_type";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when search of experiment and assay
     * result is requested.
     * Value of the parameter page should be {@link #PAGE_SEARCH}.
     */
    public static final String ACTION_SEARCH_EXPERIMENTS_ASSAYS = "experiment_assay";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when resources page about R packages
     * is requested. Value of the parameter page should be {@link #PAGE_RESOURCES}.
     */
    public static final String ACTION_RESOURCES_R_PACKAGES = "r_packages";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when resources page about annotations
     * is requested. Value of the parameter page should be {@link #PAGE_RESOURCES}.
     */
    public static final String ACTION_RESOURCES_ANNOTATIONS = "annotations";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when resources page about ontologies
     * is requested. Value of the parameter page should be {@link #PAGE_RESOURCES}.
     */
    public static final String ACTION_RESOURCES_ONTOLOGIES = "ontologies";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter 
     * (see {@link URLParameters#getParamAction()}) when resources page about source code
     * is requested. Value of the parameter page should be {@link #PAGE_RESOURCES}.
     */
    public static final String ACTION_RESOURCES_SOURCE_CODE = "source_code";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when all genes for a species
     * are requested. Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_SPECIES_GENE_LIST = "species_list";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when information about the name
     * of a species is requested. Value of the parameter page should be {@link #PAGE_SPECIES}.
     */
    public static final String ACTION_SPECIES_NAME = "name";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when general information about a gene
     * is requested. Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_GENE_GENERAL_INFO = "general_info";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when homologs of a gene
     * are requested. Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_GENE_HOMOLOGS = "homologs";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when XRefs information for a gene
     * is requested. Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_GENE_XREFS = "xrefs";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when expression results for a gene
     * are requested. Value of the parameter page should be {@link #PAGE_GENE}.
     */
    public static final String ACTION_GENE_EXPRESSION = "expression";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when experiment list
     * is requested. Value of the parameter page should be {@link #PAGE_DATA}.
     */
    public static final String ACTION_EXPERIMENTS = "experiments";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when raw data annotations
     * are requested. Value of the parameter page should be {@link #PAGE_DATA}.
     */
    public static final String ACTION_RAW_DATA_ANNOTS = "raw_data_annots";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when processed expression values
     * are requested. Value of the parameter page should be {@link #PAGE_DATA}.
     */
    public static final String ACTION_PROC_EXPR_VALUES = "proc_expr_values";
    /**
     * A {@code String} that is the value taken by the {@code action} parameter
     * (see {@link URLParameters#getParamAction()}) when present/absent expression calls
     * are requested. Value of the parameter page should be {@link #PAGE_DATA}.
     */
    public static final String ACTION_EXPR_CALLS = "expr_calls";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE = "single";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi-species part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI = "multi";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the OMA HOG part, in the documentation about gene expression calls.
     */
    public static final String HASH_DOC_CALL_OMA = "oma_hog";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR = "single_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_SIMPLE = "single_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species advanced expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_EXPR_ADVANCED = "single_expr_advanced";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR = "multi_expr";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_SIMPLE = "multi_expr_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete expression part, in the documentation 
     * about gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_EXPR_COMPLETE = "multi_expr_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF = "single_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_SIMPLE = "single_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the single species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_SINGLE_DIFF_COMPLETE = "single_diff_complete";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF = "multi_diff";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species simple diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_SIMPLE = "multi_diff_simple";
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the multi species complete diff. expression part, in the documentation about 
     * gene expression calls.
     */
    public static final String HASH_DOC_CALL_MULTI_DIFF_COMPLETE = "multi_diff_complete";
    
    /**
     * A {@code String} that is the anchor to use in the hash part of an URL 
     * to link to the stable URL part of the documentation of the SPARQL endpoint
     */
    public static final String HASH_SPARQL_STABLE = "sparql_stable_version";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a XML view.
     */
    public static final String DISPLAY_TYPE_XML = "xml";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a HTML view.
     */
    public static final String DISPLAY_TYPE_HTML = "html";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a CSV view.
     */
    public static final String DISPLAY_TYPE_CSV = "csv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a TSV view.
     */
    public static final String DISPLAY_TYPE_TSV = "tsv";
    /**
     * A {@code String} that is the value taken by the {@code displayType} parameter 
     * (see {@link URLParameters#getParamDisplayType()}) to obtain a JSON view.
     */
    public static final String DISPLAY_TYPE_JSON = "json";
    
    /**
     * A {@code String} that is the separator to use between the search part and hash part 
     * of URLs generated by the method {@link #getRequestURL(String, Collection, boolean, boolean)}. 
     * This is used only for pages where the hash is used to read/write parameters 
     * from URL in javascript.
     * <p>
     * This attribute is useful if you wanted, for instance, to have such pages 
     * indexed by google (it should then be changed to '#!').
     * <p>
     * Note that this attribute is not use as hash separator when the hash is actually used 
     * to link to an element with corresponding ID on the page (see {@link #setURLHash(String)}).
     */
    public static final String JS_HASH_SEPARATOR = "#";
    
    /**
     * A {@code BgeeProperties} instance to provide all the properties values
     */
    private final BgeeProperties prop ;

    /**
     * A {@code HashMap<URLParameters.Parameter<?>, List<Object>} that store the
     * values of parameters as an {@code Object} using a 
     * {URLParameters.Parameter<T>} instance as key
     */    
    private final HashMap<URLParameters.Parameter<?>, List<Object>> values = 
            new HashMap<>();
    
    /**
     * A {@code String} that is the 'hash' part of the URL to add 
     * when methods {@code getRequestURL} are called. This is used to actually link 
     * to an element with this ID (the 'classical' use of hash), this must not be used 
     * to store parameter values (the javascript use, allowing js to change an URL 
     * with no redirection). For this latter use, see {@link #getRequestURL(Collection, boolean)} 
     * and {@link #getRequestURL(String, Collection, boolean, boolean)}.
     * <p>
     * Of course, the hash is never retrieved from a {@code HttpServletRequest}, 
     * this is not meant to be used by the server. 
     */
    private String urlHash;

    /**
     * A {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * If {@code false}, then the {@code encodeUrl} method returns 
     * Strings with no modifications, otherwise, they are url encoded if needed.
     * 
     * @see #urlEncode(String)
     */
    private boolean encodeUrl;
    
    private final int secureMaxURLLength;
    
    /**
     * A {@code String} defining the character encoding for encoding and decoding query strings.
     */
    private final String charEncoding;

    /**
     * A {@code String} defining the character(s) that are used as parameters separator in the
     * URL 
     */
    private String parametersSeparator;

    /**
     * A {@code String} that contains the URL corresponding to the current state
     * of the request parameters
     */
    private String parametersQuery;

    /**
     * An instance of {@code URLParameters} that provides all the
     * {@code URLParameters.Parameter} that can be present in the request. This follows the pattern 
     * of dependency injection.
     * 
     * @see URLParameters
     */
    private final URLParameters urlParametersInstance;

    /**
     * Name of the HTTP method with which this request was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    private final String httpMethod;

    /**
     * 0-arg constructor defining default implementations and values to use to call 
     * {@link #RequestParameters(URLParameters, BgeeProperties, boolean, String)}. It uses 
     * the {@code BgeeProperties} returned by {@link BgeeProperties#getBgeeProperties()}, 
     * the default implementation of {@code URLParameters}, value {@code true} for 
     * {@code encodeUrl}, value "&" for {@code parametersSeparator}.
     */
    public RequestParameters() {
        this(BgeeProperties.getBgeeProperties());
    }
    /**
     * @param props The {@code BgeeProperties} used by this {@code RequestParameters}.
     */
    public RequestParameters(BgeeProperties props) {
        this(new URLParameters(), props, true, "&");
    }
    /**
     * @param urlParametersInstance     A instance of {@code URLParameters} that 
     *                                  is injected to provide the available parameters
     *                                  list. 
     *                                  
     * @param prop                      An instance of {@code BgeeProperties}  that is injected
     *                                  to provide the all the properties values
     *                                  
     * @param encodeUrl                 A {@code boolean} defining whether parameters should be
     *                                  url encoded.
     * 
     * @param parametersSeparator       A {@code String} defining the character(s) that are
     *                                  used as parameters separator in the URL 
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator)  {
        this(urlParametersInstance, prop, encodeUrl, parametersSeparator, CHAR_ENCODING, 
                SECURE_MAX_URL_LENGTH);
    }
    /**
     * @param urlParametersInstance A instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected
     *                              to provide the all the properties values.
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded. 
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL.
     * @param charEncoding          A {@code String} that is the character encoding used 
     *                              to encode/decode query strings.
     * @param urlMaxLength          An {@code int} that is the maximum total length of the parameters, 
     *                              whether provided by POST or GET method, for security reasons.  
     *                                  
     */
    public RequestParameters(URLParameters urlParametersInstance, BgeeProperties prop,
            boolean encodeUrl, String parametersSeparator, String charEncoding, int urlMaxLength)  {
        log.traceEntry("{}, {}, {}, {}, {}, {}", urlParametersInstance, prop, encodeUrl,
                parametersSeparator, charEncoding, urlMaxLength);

        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.secureMaxURLLength = urlMaxLength;
        this.charEncoding = charEncoding;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        //to avoid duplicating methods, 
        //here we simulate a HttpServletRequest with an empty query string, 
        //so that all parameters will be initialized empty
        HttpServletRequest request = new BgeeHttpServletRequest("", this.charEncoding);
        this.httpMethod = request.getMethod();
        try {
            this.constructor(request);
        } catch (RequestParametersNotFoundException | MultipleValuesNotAllowedException | 
                InvalidFormatException e) {
            //here we do nothing, 
            //because we provide a "blank" HttpServletRequest, so none of the declared exception
            //is expected
            throw log.throwing(new AssertionError("Unreachable code reached in default constructor", e));
        }

        log.traceExit();
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <p>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values.       
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL                              
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator)
                    throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, InvalidFormatException {
        this(request, urlParametersInstance, prop, encodeUrl, parametersSeparator, CHAR_ENCODING, 
                SECURE_MAX_URL_LENGTH);
    }

    /**
     * Constructor building a {@code RequestParameters} object from a 
     * {@code HttpServletRequest} object.
     * <p>
     * It means that the parameters are recovered from the query string or posted data.
     * 
     * @param request               The HttpServletRequest object corresponding to the current 
     *                              request to the server.
     * @param urlParametersInstance An instance of {@code URLParameters} that 
     *                              is injected to provide the available parameters
     *                              list. 
     * @param prop                  An instance of {@code BgeeProperties}  that is injected to 
     *                              provide the all the properties values 
     * @param encodeUrl             A {@code boolean} defining whether parameters should be
     *                              url encoded.
     * @param parametersSeparator   A {@code String} defining the character(s) that are
     *                              used as parameters separator in the URL.
     * @param charEncoding          A {@code String} that is the character encoding used 
     *                              to encode/decode query strings.  
     * @param urlMaxLength          An {@code int} that is the maximum total length of the parameters, 
     *                              whether provided by POST or GET method, for security reasons.                       
     * 
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public RequestParameters(HttpServletRequest request, URLParameters urlParametersInstance,
            BgeeProperties prop,  boolean encodeUrl, String parametersSeparator, String charEncoding, 
            int urlMaxLength) throws RequestParametersNotFoundException, 
                    MultipleValuesNotAllowedException, InvalidFormatException {
        log.traceEntry("{}, {}, {}, {}, {}, {}, {}", request, urlParametersInstance, prop,
                encodeUrl, parametersSeparator, charEncoding, urlMaxLength);
        
        // set the properties and then call the constructor method.
        this.prop = prop;
        this.encodeUrl = encodeUrl;
        this.secureMaxURLLength = urlMaxLength;
        this.charEncoding = charEncoding;
        this.urlParametersInstance = urlParametersInstance;
        this.parametersSeparator = parametersSeparator;
        this.httpMethod = request.getMethod();
        this.urlHash = null;
        this.constructor(request);

        log.traceExit();
    }

    /**
     * Method that is called by the constructors to allow different handling of exceptions but
     * avoid the duplication of the code within constructors.
     * 
     * @param request   The HttpServletRequest object corresponding to the current 
     *                  request to the server.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     *                                                  
     * @see #RequestParameters(URLParameters, BgeeProperties, boolean, String)
     * @see #RequestParameters(HttpServletRequest, URLParameters, BgeeProperties, boolean, String)
     */
    private void constructor(HttpServletRequest request) throws RequestParametersNotFoundException,
    MultipleValuesNotAllowedException, InvalidFormatException{
        log.traceEntry("{}", request);

        this.loadParameters(request.getParameterMap());

        log.traceExit();
    }

    /**
     * Load all the parameters related to the request, based on 
     * the {@code HttpServletRequest} object. 
     * It uses the parameters present in the request or load them from a file.
     * If the current request includes a key to retrieve a stored query string, 
     * the corresponding query string is retrieved from a file named as the key, 
     * If no key is provided, the storable parameters are simply retrieved from
     * the current request.
     * 
     * @param paramValues   A {@code Map} where keys are parameter names, and values are 
     *                      {@code Array}s of {@code String}s containing the associatd values, 
     *                      as returned by {@code ServletRequest.getParameterMap()}.
     *                  
     * @throws RequestParametersNotFoundException       if a key is set in the 
     *                                                  URL, meaning that a stored query string
     *                                                  should be retrieved using this key, to
     *                                                  populate the storable parameters of this 
     *                                                  {@code RequestParameters} object, but 
     *                                                  these parameters could not be found using
     *                                                  this key. See {@code 
     *                                                  loadStorableParametersFromKey(String)}
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParametersFromRequest
     * @see #loadStorableParametersFromKey
     */
    private void loadParameters(Map<String, String[]> paramValues) 
            throws RequestParametersNotFoundException, 
            MultipleValuesNotAllowedException, InvalidFormatException{
        log.traceEntry("{}", paramValues);

        //Get the key
        String key = Optional.ofNullable(
                paramValues.get(this.getUrlParametersInstance().getParamData().getName()))
                .map(arr -> arr.length > 0? arr[0]: null)
                .orElse(null);
        if (StringUtils.isNotBlank(key)) {
            //a key is set, get the storable parameters from a file
            log.trace("The key is set, load params from the file");
            try {
                this.loadStorableParametersFromKey(key);
            } catch (IOException e) {
                // Re throw a custom exception instead
                throw new RequestParametersNotFoundException(key);
            }
            // When a key is provided, we want parameters in the URL to override
            // the values provided by the hash for the same parameters
            this.loadParametersFromRequest(paramValues, true, true);
        } else {
            //Otherwise, just to be sure, we don't override anything
            this.loadParametersFromRequest(paramValues, true, false);
        }

        log.traceExit();
    }

    /**
     * Load the parameters from the {@code HttpServletRequest} object
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param request          the {@code HttpServletRequest} object representing 
     *                         the current request to the server.
     * 
     * @param loadStorable     a {@code boolean} that indicates whether the storable 
     *                         parameters have to be loaded from the request. 
     *                         For example, if the storable parameters were already
     *                         loaded from the key, this method will be called to load
     *                         the non-storable parameter only, i.e. with loadStorable 
     *                         set at {@code false}
     *                         
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadStorableParametersFromKey
     * @see #loadParameters
     */
    private void loadParametersFromRequest(Map<String, String[]> paramValues, boolean loadStorable,
            boolean overrideExistingValues) 
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.traceEntry("{}, {}, {}", paramValues, loadStorable, overrideExistingValues);

        // Browse all available parameters
        for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()) {
            log.trace("Trying to retrieve value for parameter {}", parameter.getName());
            // If it is a param that has the desired isStorable status, proceed...
            if (loadStorable || !parameter.isStorable()){
                // Fetch the string values from the URL
                String[] originalValuesFromUrl = paramValues.get(parameter.getName());
                // For backward compatibility with Bgee 13, for the parameter SUMMARY_QUALITY,
                // replace "low" with "silver" and "high" with "gold".
                String[] valuesFromUrl = originalValuesFromUrl;
                if (URLParameters.SUMMARY_QUALITY_PARAM_NAME.equals(parameter.getName()) &&
                        originalValuesFromUrl != null) {
                    valuesFromUrl = Arrays.stream(originalValuesFromUrl)
                            .map(v -> {
                                if ("low".equalsIgnoreCase(v)) {
                                    return SummaryQuality.SILVER.getStringRepresentation();
                                }
                                if ("high".equalsIgnoreCase(v)) {
                                    return SummaryQuality.GOLD.getStringRepresentation();
                                }
                                return v;
                            })
                            .toArray(String[]::new);
                }

                if (log.isTraceEnabled()) {
                    log.trace("Values retrieved: {}", Arrays.deepToString(
                            Optional.ofNullable(valuesFromUrl).orElse(new String[0])));
                }
                if (valuesFromUrl == null) {
                    continue;
                }
                
                //process the parameter and store it into this RequestParameters
                this.addAnyValues(parameter, Arrays.stream(valuesFromUrl)
                    //secure the String value
                    .map(value -> this.secureString(value, parameter))
                    //split into multiple values if the parameter is a separated-value parameter.
                    .flatMap(value -> {
                        List<String> values = new ArrayList<>();
                        if (!parameter.allowsSeparatedValues()) {
                            values.add(value);
                        } else {
                            String splitPattern = "";
                            for (String separator: parameter.getSeparators()) {
                                if (!splitPattern.equals("")) {
                                    splitPattern += "|";
                                }
                                splitPattern += Pattern.quote(separator);
                            }
                            values.addAll(Arrays.asList(value.split(splitPattern)));
                        }
                        return values.stream();
                    })
                    //filter
                    .filter(StringUtils::isNotBlank)
                    //cast to the parameter requested type
                    .map(value -> {
                        value = value.trim();
                        try {
                            if(parameter.getType().equals(String.class)){
                                return value;
                            } else if (parameter.getType().equals(Integer.class)){
                                return Integer.parseInt(value);
                            } else if (parameter.getType().equals(Long.class)){
                                return Long.parseLong(value);
                            } else if (parameter.getType().equals(Boolean.class)){
                                return castToBoolean(value);
                            } else if (parameter.getType().equals(Double.class)){
                                return Double.parseDouble(value);
                            } else {
                                throw log.throwing(new IllegalStateException(
                                        "Unsupported parameter type: " + parameter.getType()));
                            }
                        } catch (NumberFormatException e) {
                            throw log.throwing(new InvalidFormatException(parameter, e));
                        }
                    })
                    .collect(Collectors.toList()),
                    overrideExistingValues);
            }
        }

        log.traceExit();
    }

    /**
     * Load the storable parameters from the file corresponding to the provided key.
     * If a key is provided, but no stored query string is found corresponding to this key, 
     * a IOException is thrown.
     * 
     * @throws IOException                              thrown if a error occurs while trying 
     *                                                  to read the file associated to the key,
     *                                                  containing the query string to be used.
     *                                                  
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     * 
     * @see #loadParameters
     * @see #loadParametersFromRequest
     * 
     */
    private void loadStorableParametersFromKey(String key) throws IOException, 
    MultipleValuesNotAllowedException, InvalidFormatException {
        log.traceEntry("{}", key);

        ReentrantReadWriteLock lock = this.getReadWriteLock(key);
        try {
            lock.readLock().lock();

            while (readWriteLocks.get(key) == null ||  
                    !readWriteLocks.get(key).equals(lock)) {
                lock = this.getReadWriteLock(key);
                lock.readLock().lock();
            }
            try (BufferedReader br = new BufferedReader(new FileReader(
                    prop.getRequestParametersStorageDirectory() + key))) {
                String retrievedQueryString;
                //just one line in the file, a query string including storable parameters, 
                //that will be used to recover storable parameters
                if ((retrievedQueryString = br.readLine()) != null) {
                    //here we create a fake HttpServletRequest using the query 
                    // string we retrieved.
                    //this way we do not duplicate code to load parameters into 
                    // this RequestParameters object.
                    HttpServletRequest request = new BgeeHttpServletRequest(
                            retrievedQueryString, this.getCharacterEncoding());
                    this.loadParametersFromRequest(request.getParameterMap(), true, false);
                }
            }

        } finally {
            lock.readLock().unlock();
            this.removeLockIfPossible(key);
        }

        log.traceExit();

    }

    /**
     * Store the part of the query string holding storable parameters into a file: 
     * get the part of the query string containing "storable" parameters 
     * generate a key based on that string, and store the string in a file named as the key.
     * This allows to store parameters too lengthy to be put in URL, to replace these parameters 
     * by the key, which is stored in the {@code URLParameters.Parameter} DATA 
     * and to store these parameters to retrieve them at later pages 
     * using that key.
     * 
     * @throws RequestParametersNotStorableException    if an error occur while trying to use
     *                                                  the key or to write the query string in
     *                                                  a file
     * @see #generateParametersQuery(Set, boolean, boolean, String, Collection, boolean)
     * @see URLParameters#getParamData
     */
    private void store() throws RequestParametersNotStorableException {
        log.traceEntry();

        if (StringUtils.isBlank(this.getFirstValue(
                this.getKeyParam()))) {
            throw new RequestParametersNotStorableException(
                    "No key was generated before trying to store the associated parameters.");
        }
        //first check whether these parameters have already been serialized
        String fileLocation = prop.getRequestParametersStorageDirectory() 
                + this.getFirstValue(this.getKeyParam());
        File storageFile = new File(fileLocation);
        if (storageFile.exists()) {
            //file already exists, no need to continue
            return;
        }
        ReentrantReadWriteLock lock = this.getReadWriteLock(this.getFirstValue(
                this.getKeyParam()));
        String parametersQuery = null;
        try {
            lock.writeLock().lock();
            while (readWriteLocks.get(this.getDataKey()) == null ||  
                    !readWriteLocks.get(this.getDataKey()).equals(lock)) {
                lock = this.getReadWriteLock(this.getDataKey());
                lock.writeLock().lock();
            }
            //A bit hacky to know where the error occurred in this try block,
            //rather than having debug logs, we will distinguish between parametersQuery = null
            //and parametersQuery = ""
            parametersQuery = "";
            try (BufferedWriter bufferedWriter = new BufferedWriter(
                    new FileWriter(fileLocation))) {
                // we cannot store an URL-decoded query string, to store encoding-independent values, 
                // because of cases where, e.g., a parameter value include a character such as '&': 
                // we couldn't distinguish it anymore from real parameter separators.
                parametersQuery = generateParametersQuery(null, true, false, "&", null, false);
                bufferedWriter.write(parametersQuery);
            }
        } catch (IOException e) {
            log.catching(e);
            log.error("Error trying to write requestparameters file {}, parametersQuery: {}",
                    fileLocation, parametersQuery);
            //delete the file if something went wrong
            storageFile = new File(fileLocation);
            if (storageFile.exists()) {
                log.error("File was created, deleting it");
                if (!storageFile.delete()) {
                    log.error("The file was not deleted before before throwing the exception");
                }
            }
            throw new RequestParametersNotStorableException(
                    "An error occurred and it was not possible to store the parameters.");
        } finally {
            lock.writeLock().unlock();
            this.removeLockIfPossible(this.getFirstValue(
                    this.getKeyParam()));
        }

        log.traceExit();
    }

    /**
     * Try to remove the {@code ReentrantReadWriteLock} corresponding to 
     * the argument {@code key}, from the {@code ConcurrentHashMap} 
     * {@link #readWriteLocks}.
     * The lock will be removed from the map only if there are no read or write locks, 
     * and no ongoing request for a read or write lock.
     * <p>
     * Note: there might be here a race, where another thread acquired the lock and 
     * actually locked it, i) just after this method tests the presence of read or write locks 
     * and ongoing requests for a read or write lock, 
     * and ii) just before removing it from the map.
     * To solve this issue, methods acquiring a lock must check after locking it 
     * whether it is still in the readWriteLocks map, 
     * or whether the element present in the map for the key is equal to the acquired lock. 
     * If it is not, they must generate a new lock to be used.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}, to remove it. This key is generated by the method
     *              {@code generateKey}
     * @see         #generateKey(String)
     * @see         #readWriteLocks
     */
    private void removeLockIfPossible(String key) {
        log.traceEntry("{}", key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock lock = readWriteLocks.get(key);
        //there is a lock to remove
        if (lock != null) {
            //there is no thread with write lock, or read lock, or waiting to acquire a lock
            if (!lock.isWriteLocked() && lock.getReadLockCount() == 0 && !lock.hasQueuedThreads()) {
                readWriteLocks.remove(key);
            }
        }

        log.traceExit();
    }

    /**
     * Obtain a {@code ReentrantReadWriteLock}, for the param {@code key}.
     * 
     * This method tries to obtain {@code ReentrantReadWriteLock} corresponding to the key, 
     * from the {@code ConcurrentHashMap} {@code readWriteLocks}. 
     * If the lock is not already stored, 
     * create a new one, and put it in {@code readWriteLocks}, to be used by other threads.
     * 
     * @param key   a {@code String} corresponding to the key to retrieve the lock from 
     *              {@code readWriteLocks}. This key is generated by the method {@code generateKey}
     * @return  a {@code ReentrantReadWriteLock} corresponding to the key.
     * @see #generateKey(String)
     * @see #readWriteLocks
     */
    private ReentrantReadWriteLock getReadWriteLock(String key) {
        log.traceEntry("{}", key);

        //check if there is already a lock stored for this key
        ReentrantReadWriteLock readWritelock = readWriteLocks.get(key);

        //no lock already stored
        if (readWritelock == null) {
            ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(true);
            //try to put the new lock in the ConcurrentHashMap
            readWritelock = readWriteLocks.putIfAbsent(key, newReadWriteLock);
            //if readWritelock is null, the newLock has been successfully put in the map, and we use it.
            //otherwise, it means that another thread has inserted a new lock for this key in the mean time.
            //readWritelock then corresponds to this value, that we should use.
            if (readWritelock == null) {
                readWritelock = newReadWriteLock;
            }
        }

        return log.traceExit(readWritelock);
    }

    /**
     * When receiving request parameters, when the URL is too long it is replaced
     * with a data hash (see {@link #getDataKey()}), and the parameters are stored
     * in a file named as the data hash. But this file generation is triggered only when needed,
     * basically, when calling {@code #getRequestURL()} and if the URL is too long.
     * If you need to trigger generation of a hash, and store the parameters in a file,
     * without needing the URL, or independently of the URL length, you can call this method instead.
     */
    public void generateKeyAndStore() {
        log.traceEntry();
        // Always use & as separator to generate the key, so the key is the same for
        // the same parameters, no matter the separator provided.
        // Also, never use searchOrHashParams provided, so that all the parameters are always
        // in the search part of the URL to generate the key.
        String storableParametersUrlPartForKey = this.generateParametersQuery(
                null, true, false, "&", null, false);
        this.generateKey(storableParametersUrlPartForKey);
        this.store();
        log.traceExit();
    }
    /**
     * Generate the search and hash parts of URLs. This method takes care 
     * of checking whether the generated URL is too long, and if it is, 
     * of launching the generation of the key needed to store the storable parameters, 
     * the storage on server, and to re-generate the query URL accordingly.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL. 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     *                                              
     * @throws RequestParametersNotStorableException    if an error occur while trying to use the
     *                                                  key or to write the query string in a file
     */
    private void generateParametersQuery(String parametersSeparator,
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams) 
                    throws RequestParametersNotStorableException {
        log.traceEntry("{}, {}, {}", parametersSeparator, searchOrHashParams, areSearchParams);

        // If there is a key already present, continue to work with a key
        String previousKey = this.getDataKey();
        boolean toStore = false;
        // Always use & as separator to generate the key, so the key is the same for
        // the same parameters, no matter the separator provided.
        // Also, never use searchOrHashParams provided, so that all the parameters are always
        // in the search part of the URL to generate the key.
        String storableParametersUrlPartForKey = this.generateParametersQuery(
                null, true, false, "&", null, false);
        if (StringUtils.isNotBlank(this.getDataKey())) {
            // Regenerate the key in case a storable param has changed
            this.generateKey(storableParametersUrlPartForKey);
            // Regenerate the parameters query, with the non storable that include
            // the key parameter
            this.parametersQuery = generateParametersQuery(null, false, true, parametersSeparator,
                    searchOrHashParams, areSearchParams);
            //if the key has changed, we need to store again this RequestParameters
            if (StringUtils.isNotBlank(this.getDataKey()) && !this.getDataKey().equals(previousKey)) {
                toStore = true;
            }
        } else{
            // No key for the moment, generate the query and then evaluate if its
            // length is still under the threshold at which the key is used
            this.parametersQuery = generateParametersQuery(null, true, true, parametersSeparator,
                    searchOrHashParams, areSearchParams);
            if (storableParametersUrlPartForKey.length() > prop.getUrlMaxLength()) {
                // Generate the key, store the values and regenerate the query
                // Always use & as separator to generate the key, so the key is the same for 
                // the same parameters, no matter the separator provided. 
                // Also, never use searchOrHashParams provided, so that all the parameters 
                // are always in the search part of the URL to generate the key.
                this.generateKey(storableParametersUrlPartForKey);
                if(StringUtils.isNotBlank(this.getDataKey())){
                    toStore = true;
                }
            }    
        }
        if (toStore) {
            this.store();
            this.generateParametersQuery(parametersSeparator, 
                    searchOrHashParams, areSearchParams);
        }

        log.traceExit();
    }

    /**
     * Generate the query from the current state of the parameters, providing the separator 
     * to use between parameters, and {@code boolean}s defining whether storable and/or 
     * non-storable parameters should be included. This method does not take care 
     * of generating a key if the URL is too long, to store the parameters on server 
     * if needed, etc. This is responsibility of the method 
     * {@link #generateParametersQuery(String, Collection, boolean)}. This method simply generates 
     * the URL from the parameters. 
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * <p>
     * This method has a js counterpart in {@code requestparameters.js}, called getRequestURL(),
     * that should be kept consistent as much as possible if the method evolves.
     * 
     * @param targetedParams        A {@code Set} of {@code Parameter}s, allowing which parameters 
     *                              to use to produce the query string. If {@code null} or empty, 
     *                              then all parameters are used. 
     * @param parametersSeparator   A {@code String} that is used as parameters separator 
     *                              in the URL.
     * @param includeStorable       A {@code boolean} to indicate whether to include
     *                              the storable parameters.
     * @param includeNonStorable    A {@code boolean} to indicate whether to include
     *                              the non-storable parameters.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that is the generated query
     */
    private String generateParametersQuery(Set<URLParameters.Parameter<?>> targetedParams, 
            boolean includeStorable, boolean includeNonStorable, String parametersSeparator, 
            Collection<URLParameters.Parameter<?>> searchOrHashParams, boolean areSearchParams){

        log.traceEntry("{}, {}, {}, {}, {}, {}", targetedParams, includeStorable,
                includeNonStorable, parametersSeparator, searchOrHashParams, areSearchParams);

        String urlFragment = "";

        // Browse all available parameters. 
        // We will potentially do it twice, to store the parameters either in the search part, 
        //or the hash part of the URL, depending on searchOrHashParams and areSearchParams.
        boolean hashDone = false;
        boolean searchDone = false;
        while (!searchDone || !hashDone) {
            log.trace("Adding parameters for the part: search part ({})/hash part ({})", 
                    !searchDone, searchDone && !hashDone);
            if (searchOrHashParams == null) {
                //no need for a second pass if no param needed in hash
                log.trace("Storing all parameters in search part.");
                hashDone = true;
            }
            boolean paramAdded = false;
            boolean firstParam = true;
            for (URLParameters.Parameter<?> parameter : this.urlParametersInstance.getList()){
                if (targetedParams != null && !targetedParams.isEmpty() && !targetedParams.contains(parameter)) {
                    log.trace("Skipping parameter because not targeted: {}", parameter);
                    continue;
                }
                if (parameter.equals(this.urlParametersInstance.getParamPostFormSubmit())) {
                    log.trace("Skipping parameter because internal parameter not to be displayed: {}", parameter);
                    continue;
                }
                //if a split between parameters in search and hash parts has been requested 
                if (searchOrHashParams != null) {
                    //first pass, store parameters in the search part of the URL
                    if (!searchDone) {
                        if (areSearchParams && !searchOrHashParams.contains(parameter) || 
                            !areSearchParams && searchOrHashParams.contains(parameter)) {
                            //parameter requested in hash, skip
                            continue;
                        }
                        log.trace("Parameter added to search part: {}", parameter);
                    } else {
                        //second pass, store parameters in the hash part of the URL
                        assert searchDone && !hashDone;
                        if (areSearchParams && searchOrHashParams.contains(parameter) || 
                            !areSearchParams && !searchOrHashParams.contains(parameter)) {
                            //parameter requested in search part, skip
                            continue;
                        }
                        log.trace("Parameter added to hash part: {}", parameter);
                        //if this is the first parameter stored in the hash, 
                        // we add the hash separator.
                        if (firstParam) {
                            urlFragment += JS_HASH_SEPARATOR;
                        }
                        firstParam = false;
                    }
                }
                // If it is one of the param to include, proceed...
                if((includeStorable && parameter.isStorable()) || (includeNonStorable 
                        && !parameter.isStorable())){
                    // Fetch the values of this param and generate a query with all
                    // its values
                    String paramFragment = this.generateParameterQueryStringFragment(parameter, 
                            this.getValues(parameter), parametersSeparator);
                    if (StringUtils.isNotBlank(paramFragment)) {
                        urlFragment += paramFragment + parametersSeparator;
                        paramAdded = true;
                    }
                }
            }

            // Remove the extra separator at the end 
            if(paramAdded){
                int paramSeparatorLength = parametersSeparator.length();
                urlFragment = urlFragment.substring(0, urlFragment.length()-paramSeparatorLength);
            }
            
            //if searchDone is true, the first pass was already done, 
            //this was the end of the second pass.
            if (searchDone) {
                hashDone = true;
            }
            //will be set to true at the end of the first pass.
            searchDone = true;
            log.trace("URL fragment at the end of the pass: {}", urlFragment);
        }

        return log.traceExit(urlFragment);
    }
    
    /**
     * Generates the URL query string fragment related to {@code parameter}, using the values 
     * provided in {@code parameterValues}. Values are URL encoded (see {@link #urlEncode(String)}). 
     * 
     * @param parameter             A {@code URLParameters.Parameter} whose values should be 
     *                              written in an URL query string.
     * @param parameterValues       A {@code List} containing the values associated to 
     *                              {@code parameter}.
     * @param parameterSeparator    A {@code String} that is used as parameter separator 
     *                              in the URL.
     * @return                  A {@code String} that is the resulting URL query string fragment. 
     *                          Empty if no values were written. It does not finish with 
     *                          {@link #parametersSeparator}.
     * @throws IllegalArgumentException If the type of a value does not correspond to 
     *                                  type associated to {@code parameter} (see {@link 
     *                                  URLParameters.Parameter#getType()}).
     */
    private String generateParameterQueryStringFragment(URLParameters.Parameter<?> parameter, 
            List<?> parameterValues, String parameterSeparator) {
        log.traceEntry("{}, {}, {}", parameter, parameterValues, parameterSeparator);
        if (parameterValues == null || parameterValues.isEmpty()) {
            return log.traceExit("");
        }

        //If the parameter can hold several values provided as a single String 
        //(e.g., list of IDs separated by a line return in a textarea), 
        //we need to regenerate a single String from the multiple values
        List<?> valuesToUse = parameterValues;
        if (parameter.allowsSeparatedValues()) {
            String separatedValues = parameterValues.stream()
                    .filter(v -> v != null && StringUtils.isNotBlank(v.toString()))
                    .map(Object::toString)
                    .collect(Collectors.joining(parameter.getSeparators().get(0)));
            valuesToUse = Arrays.asList(separatedValues);
        } 
        
        return log.traceExit(valuesToUse.stream()
            .filter(value -> value != null && StringUtils.isNotBlank(value.toString()))
            .map(value -> {
                if (!parameter.getType().equals(value.getClass())) {
                    throw log.throwing(new IllegalArgumentException("The value type ("
                            + value.getClass().getSimpleName() 
                            + " does not correspond to the parameter type ("
                            + parameter.getType().getSimpleName()));
                }
                return parameter.getName() + "=" + this.urlEncode(value.toString());
            })
            .collect(Collectors.joining(parameterSeparator)));
    }

    /**
     * Generate a key to set the parameter {@code URLParameters.getParamData}, 
     * based on {@code urlFragment}, 
     * in order to keep the storable parameters of this  {@code RequestParameters} object
     * on the disk
     * 
     * This key is a hash of an URL fragment generated from the storable attributes
     * of this object, without any length restriction (all the storable attributes are then
     * represented). 
     * It will be used as an index to store and retrieve the storable part of this
     * {@code RequestParameters} object.
     * <p>
     * A new call to this method will then trigger the computation of a new key.
     * 
     * @param urlFragment   The fragment of URL based on the storable parameters
     *                                                  
     * @see #store()
     */
    private void generateKey(String urlFragment) {
        log.traceEntry("{}", urlFragment);

        log.info("Trying to generate a key based on urlFragment: {}", urlFragment);

        if (StringUtils.isNotBlank(urlFragment)) {
            // Reset the present key and add the new one
            this.resetValues(this.getKeyParam());
            try {
                this.addValue(this.getKeyParam(), 
                        DigestUtils.sha1Hex(urlFragment.toLowerCase(Locale.ENGLISH)));
            } catch (MultipleValuesNotAllowedException | InvalidFormatException e) {
                // In this particular case, should never be thrown.
                throw log.throwing(new AssertionError("Unreachable code reached in generateKey", e));
            }
        }

        log.info("Key generated: {}", this.getFirstValue(
                this.getKeyParam()));

        log.traceExit();
    }

    /**
     * Encode String to be used in URLs. 
     * This method is different from the {@code encodeURL} method 
     * of {@code HttpServletResponse}, as it does not include a logic 
     * for session tracking. It just converts special chars to be used in URL.
     * The encoding can be desactivated by setting the {@code encodeUrl} attribute to
     * {@code false}.
     *  
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param url   the {@code String} to be encoded.
     * @return  a {@code String} encoded, if needed (meaning, if including special chars), 
     *          and if the {@code encodeUrl} attribute is {@code true}
     * 
     * @see #encodeUrl
     */
    private String urlEncode(String url){
        log.traceEntry("{}", url);

        String encodeString = url;

        if (!this.encodeUrl) {
            return encodeString;
        }
        try {
            // "In Tomcat 8 starting with 8.0.0 (8.0.0-RC3, to be specific), the default value 
            // of URIEncoding attribute on the <Connector> element depends on 'strict servlet 
            // compliance' setting. The default value (strict compliance is off) of URIEncoding 
            // is now UTF-8. If 'strict servlet compliance' is enabled, the default value 
            // is ISO-8859-1. 
            // => So we should now be fine when using UTF-8 for character encoding.
            // See https://wiki.apache.org/tomcat/FAQ/CharacterEncoding#Q8
            encodeString = java.net.URLEncoder.encode(url, this.getCharacterEncoding());
        } catch (Exception e) {
            log.error("Error while URLencoding", e);
        }
        return log.traceExit(encodeString);
    }

    /**
     * @return The Parameter<String> that contains the key used to store the storable parameters
     */
    private Parameter<String> getKeyParam(){
        log.traceEntry();
        return log.traceExit(this.urlParametersInstance.getParamData());
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    public String getRequestURL() throws RequestParametersNotStorableException {
        log.traceEntry();
        return log.traceExit(this.getRequestURL(this.parametersSeparator));
    }

    /**
     * Return the stable URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     *
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     *
     */
    public String getStableRequestURL() throws RequestParametersNotStorableException {
        log.traceEntry();
        return log.traceExit(this.getRequestURL(parametersSeparator, null, false, true));
    }

    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator}.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * 
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * 
     */
    //TODO : are the three following methods still useful, since apparently we use setters to define these arguments ?
    public String getRequestURL(String parametersSeparator) 
            throws RequestParametersNotStorableException {
        log.traceEntry("{}", parametersSeparator);
        return log.traceExit(this.getRequestURL(parametersSeparator, null, false, false));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * the parameters separator provided to the constructor or set afterwards using 
     * {@link #setParametersSeparator}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified.
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    public String getRequestURL(Collection<URLParameters.Parameter<?>> searchOrHashParams, 
            boolean areSearchParams) throws RequestParametersNotStorableException, 
            IllegalStateException {
        log.traceEntry("{}, {}", searchOrHashParams, areSearchParams);
        return log.traceExit(this.getRequestURL(this.parametersSeparator, 
                searchOrHashParams, areSearchParams, false));
    }
    /**
     * Return the URL corresponding to this {@code RequestParameters} instance using 
     * a custom parameters separator instead of the one provided to the constructor or set 
     * afterwards using {@link #setParametersSeparator(String)}.
     * <p>
     * It is possible to distinguish parameters to be stored in the search part of the URL, 
     * or the hash part of the URL. This is useful for linking to pages reading/writing 
     * parameters in javascript from the hash. If {@code searchOrHashParams} is {@code null}, 
     * all parameters will be stored in the search part. Otherwise, if {@code areSearchParams} 
     * is {@code true}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the search part, all the others in the hash part; if {@code areSearchParams} 
     * is {@code false}, the {@code Parameter}s in {@code searchOrHashParams} will be stored 
     * in the hash part, all the others in the search part.
     * 
     * @param parametersSeparator    A {@code String} that is used as parameters separator 
     *                               in the URL.
     * @param searchOrHashParams    A {@code Collection} of {@code Parameter}s, allowing to define 
     *                              the parameters to store in the search part or the hash part 
     *                              of the URLs. 
     * @param areSearchParams       A {@code boolean} defining where to store 
     *                              the {@code Parameters} in {@code searchOrHashParams}: 
     *                              if {@code true}, they will be stored in the search part, 
     *                              all the others in the hash part. The opposite 
     *                              if {@code false}.
     * @param stableURL             A {@code boolean} defining whether a stable URL
     *                              should be returned or not.
     * @return  A {@code String} that contains the URL corresponding to the current state 
     *          of the request. It will change every time a parameter is modified
     * @throws RequestParametersNotStorableException    if an error occur while trying to store 
     *                                                  the parameters on server, 
     *                                                  when the generated URL is too long.
     * @throws IllegalStateException    If the hash part of the URL is tried to be used 
     *                                  for both storing data parameters for javascript, 
     *                                  and for linking to a specific anchor in a page 
     *                                  (by previously calling {@link #setURLHash(String)} 
     *                                  on this object, and providing a non-null 
     *                                  {@code searchOrHashParams}).
     * 
     */
    //XXX: This method has a js counterpart in {@code requestparameters.js} that should be kept 
    //consistent as much as possible if the method evolves.
    public String getRequestURL(String parametersSeparator, 
                                Collection<URLParameters.Parameter<?>> searchOrHashParams,
                                boolean areSearchParams, boolean stableURL) 
            throws RequestParametersNotStorableException, IllegalStateException {
        log.traceEntry("{}, {}, {}, {}", parametersSeparator, searchOrHashParams,
                areSearchParams, stableURL);
        this.generateParametersQuery(parametersSeparator, searchOrHashParams, areSearchParams);
        
        String url;
        if (stableURL) {
            url = this.prop.getBgeeStableRootDirectory();
        } else {
            url = this.prop.getBgeeRootDirectory();
        }
        if (StringUtils.isBlank(url)) {
            log.warn("No root folder for URL set, using '/'");
            url = "/";
        }
        
        if (StringUtils.isNotBlank(this.parametersQuery)) {
            //if the query stores the parameters only in the hash part of the URL, 
            //we do not prepend '?', it will start with the hash separator
            if (!this.parametersQuery.startsWith(JS_HASH_SEPARATOR)) {
                url += "?";
            }
            url += this.parametersQuery;
        }
        //if hash needs to be added (to really link to an element with corresponding ID 
        //on a page, not to provide parameters readable/writable with javascript),
        if (StringUtils.isNotBlank(this.getURLHash())) {
            //check whether the hash is already used to store data parameters. 
            //It is not possible to simply test whether searchOrHashParams is not null, 
            //because it is still possible to store all parameters in search part of URLs 
            //even if searchOrHashParams is not null. So we look for the hash separator 
            //when used for storing data parameters.
            if (this.parametersQuery.contains(JS_HASH_SEPARATOR)) {
                throw log.throwing(new IllegalStateException("It is not possible "
                        + "to store data parameters in the hash part of URLs "
                        + "while also trying to use a classical anchor (you previously called "
                        + "the method setURLHash on this object)."));
            }
            url += "#" + this.getURLHash();
        }
        return log.traceExit(url);
    }

    /**
     * Return all the values for the given {@code URLParameters.Parameter<T>} 
     * in a {@code List<T>} or null if it is empty.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} that corresponds 
     *                  to the values to be returned
     *                  
     * @return  an {@code List<T>} of values
     */
    public <T> List<T> getValues(URLParameters.Parameter<T> parameter){
        log.traceEntry("{}", parameter);
        // Because the data type of URLParameters.Parameter is always checked 
        // when the value is stored, it is safe to not check.
        @SuppressWarnings("unchecked")
        ArrayList<T> values = (ArrayList<T>) this.values.get(parameter);

        try{
            // Return a copy of the list and not the original list
            // As the values contained are only immutable object, such as String
            // Integer, Boolean, Long, there is no need to clone the content
            return log.traceExit(new ArrayList<T>(values));

        } catch(NullPointerException e){
            return log.traceExit((List<T>) null);
        }
    }

    /**
     * Return the first value of the given {@code URLParameters.Parameter<T>} 
     * or null if it is empty
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter the {@code URLParameters.Parameter<T>} 
     *                  that corresponds to the value to be returned
     *                  
     * @return  a {@code T}, the value
     */
    @SuppressWarnings("unchecked")    // Because the data type of URLParameters.Parameter
    // is always checked when the value is stored, it should be safe.
    public <T> T getFirstValue(URLParameters.Parameter<T> parameter){
        log.traceEntry("{}", parameter);
        try{

        	return log.traceExit(((List<T>) this.values.get(parameter)).get(0));

        } catch(IndexOutOfBoundsException | NullPointerException e){
            return log.traceExit((T) null);            
        }
    }

    /**
     * Add a value to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * 
     * @param value     A {@code T}, the value to set
     * 
     * 
     * @throws MultipleValuesNotAllowedException        if more than one value is present in the
     *                                                  {@code request}
     *                                                  for a {@link URLParameters.Parameter}
     *                                                  that does not allow multiple values.
     *                                                  
     * @throws InvalidFormatException                     The value in the {@code request} does not
     *                                                  fit the format requirement for related
     *                                                  {@link URLParameters.Parameter}
     */
    public <T> void addValue(URLParameters.Parameter<T> parameter, T value) 
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.traceEntry("{}, {}", parameter, value);

        if (value == null) {
            log.traceExit(); return;
        }
        this.addValues(parameter, Arrays.asList(value));
        
        log.traceExit();
    }
    /**
     * Add values to the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept
     * consistent as much as possible if the method evolves.
     * 
     * @param parameter The {@code URLParameters.Parameter<T>} to add the value to
     * @param values    A {@code List} of {@code T}s, the values to set
     * @throws MultipleValuesNotAllowedException    If more than one value is present in the
     *                                              {@code request} for a
     *                                              {@link URLParameters.Parameter} that
     *                                              does not allow multiple values.
     * @throws InvalidFormatException                 A value in the {@code request} does not
     *                                              fit the format requirement for related
     *                                              {@link URLParameters.Parameter}
     */
    public <T> void addValues(URLParameters.Parameter<T> parameter, List<T> values)
            throws MultipleValuesNotAllowedException, InvalidFormatException {
        log.traceEntry("{}, {}", parameter, values);
    
        this.addAnyValues(parameter, values, false);
    
        log.traceExit();
    }
    /**
     * Add values associated to the {@code URLParameters.Parameter}.
     *  
     * @param parameter The {@code URLParameters.Parameter} to add the value to.
     * @param values    A {@code List} of {@code Object}s to associate to {@code parameter}.
     * @param overrideExistingValues    A {@code boolean}, when {@code true}, specifying
     *                                  to override parameter values stored in this object
     *                                  for {@code parameter} using {@code values}. 
     * 
     * @throws IllegalArgumentException             If the type of any object in {@code value}s 
     *                                              is different from the type returned by 
     *                                              {@code URLParameters.Parameter.getType()}.
     * @throws InvalidFormatException               If the value in the {@code request} does not
     *                                              fit the format requirement for {parameter}.
     * @throws MultipleValuesNotAllowedException    If more than one value is present in the
     *                                              {@code request} for a {@link URLParameters.Parameter}
     *                                              that does not allow multiple values.
     * @throws RequestSizeExceededException         If the overall size of the request exceeds 
     *                                              the max allowed size, following the addition 
     *                                              of this parameter value.
     */
    private void addAnyValues(URLParameters.Parameter<?> parameter, List<?> values,
            boolean overrideExistingValues) 
            throws IllegalArgumentException, InvalidFormatException, MultipleValuesNotAllowedException, 
            RequestSizeExceededException {
        log.traceEntry("{}, {}, {}", parameter, values, overrideExistingValues);

        if (values == null || values.isEmpty()) {
            log.traceExit(); return;
        }
        if (values.stream().anyMatch(e -> !parameter.getType().equals(e.getClass()))) {
            throw log.throwing(new IllegalArgumentException("The class of one of the provided value ("
                    + values + ") is incompatible with "
                    + "the parameter (" + parameter.getType().getSimpleName()));
        }

        //map the values to add 
        List<Object> newVals = values.stream().map(e -> {
            if (parameter.getType().equals(String.class)) {
                return this.secureString(e.toString(), parameter);
            }
            return e;
        }).filter(e -> e != null && 
                (!parameter.getType().equals(String.class) || 
                 StringUtils.isNotBlank(e.toString())))
        .collect(Collectors.toList());
        
        if (newVals.isEmpty()) {
            log.traceExit(); return;
        }
        
        // fetch the existing values for the given parameter and try to add the value
        List<Object> parameterValues = this.values.get(parameter);
        if (overrideExistingValues || parameterValues == null) {
            parameterValues = newVals;
        } else {
            parameterValues.addAll(newVals);
        }
        // Throw an exception if the param does not allow 
        // multiple values and has already one, or contains several values
        if (!parameter.allowsMultipleValues() && !parameter.allowsSeparatedValues() && 
                parameterValues.size() > 1) {
            throw(new MultipleValuesNotAllowedException(parameter));
        }
        
        //OK, add value
        if (!parameterValues.isEmpty()) {
            this.values.put(parameter, parameterValues);
        }
        assert !parameterValues.isEmpty() || !this.values.containsKey(parameter);
        
        //Now, we check whether all parameters considered together exceed the global 
        //max request length defined, following the addition of this parameter. 
        int globalQueryLength = this.generateParametersQuery(null, true, true, "&", null, true)
                .length();
        if (globalQueryLength > this.secureMaxURLLength) {
            log.error("Max request size exceeded, current: {} - max allowed: {}", globalQueryLength, 
                    this.secureMaxURLLength);
            throw log.throwing(new RequestSizeExceededException());
        }
        
        //then, if this parameter is a separated-value parameter, then we need to check 
        //whether the overall length of the updated parameter value exceeds its max allowed length.
        if (parameter.allowsSeparatedValues()) {
            String urlFragment = this.generateParameterQueryStringFragment(parameter, parameterValues, "&");
            //remove the parameter name from the beginning of the URL fragment
            String fragmentStart = parameter.getName() + "=";
            if (!urlFragment.startsWith(fragmentStart)) {
                throw log.throwing(new IllegalStateException("The URL fragment produced "
                        + "does not have the expected prefix, expected " + fragmentStart 
                        + ". Actual fragment: " + fragmentStart));
            }
            this.throwIfParamValueTooLong(parameter, urlFragment.substring(fragmentStart.length()));
        }
        
        log.traceExit();
    }

    /**
     * Reset the value for the given {@code URLParameters.Parameter<T>}
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *  
     * @param parameter The {@code URLParameters.Parameter<T>} to reset
     */
    public <T>  void resetValues(URLParameters.Parameter<T> parameter) {
        log.traceEntry("{}", parameter);
        this.values.put(parameter, null);
        log.traceExit();
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * with all parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with all parameter copied.
     *             
     */
    public RequestParameters cloneWithAllParameters(){
        log.traceEntry();
        return log.traceExit(this.cloneRequestParameter(true));
    }

    /**
     * Clone this {@code RequestParameters} object and return a new one, 
     * but only with the "storable" parameters copied. 
     * 
     * @return     a new {@code RequestParameters} object, 
     *             with the same values for "storable" as this one, 
     *             but with "non-storable" parameters simply initialized.
     */
    public RequestParameters cloneWithStorableParameters(){
        log.traceEntry();
        return log.traceExit(this.cloneRequestParameter(false));
    }

    /**
     * Method that actually proceed to the cloning and is called by 
     * {@link #cloneWithAllParameters()} and {@link #cloneWithStorableParameters()}
     * @param includeNonStorable    A boolean to tell whether to keep the non storable parameters
     * @return     a new {@code RequestParameters} object, with or without the non storable 
     *             parameters depending on {@code includeNonStorable}
     */
    private RequestParameters cloneRequestParameter(boolean includeNonStorable){
        log.traceEntry("{}", includeNonStorable);
        //to avoid duplicating methods, 
        //we we simulate a HttpServletRequest with a query string 
        //we provide holding storable parameters of this object
        String queryString = this.generateParametersQuery(null, true, includeNonStorable, "&", 
                null, false);
        BgeeHttpServletRequest request = new BgeeHttpServletRequest(queryString, this.getCharacterEncoding());
        RequestParameters clonedRequestParameters = null;
        try {
            clonedRequestParameters = new RequestParameters(request, 
                    this.urlParametersInstance.getClass().getDeclaredConstructor().newInstance(),this.prop,
                    this.encodeUrl, this.parametersSeparator, this.charEncoding, this.secureMaxURLLength);
            if (!includeNonStorable){
                // Add the key which is not a storable parameters and was not included
                clonedRequestParameters.addValue(this.getKeyParam(), 
                        this.getFirstValue(this.getKeyParam()));
            }
            log.trace("Cloned RequestParameters generated: {}", clonedRequestParameters);
        } catch ( RequestParametersNotFoundException | MultipleValuesNotAllowedException |
                InvalidFormatException e) {
            // In this particular case, should never be thrown.
            throw log.throwing(new AssertionError("Code supposed to be unreachable", e));
        } catch (InstantiationException | IllegalAccessException |
                NoSuchMethodException | InvocationTargetException e) {
            throw log.throwing(new IllegalStateException(e));
        }
        return log.traceExit(clonedRequestParameters);
    }

    /**
     * @return  An instance of {@code URLParameters} that provides all the
     *          {@code URLParameters.Parameter} that can be present in the request
     */
    public URLParameters getUrlParametersInstance() {
        return urlParametersInstance;
    }

    /**
     * @return  A {@code String } that is the name of the HTTP method with which this request
     *          was made, for example, GET, POST, or PUT.
     * @see javax.servlet.http.HttpServletRequest#getMethod()
     */
    public String getHttpMethod() {
        return this.httpMethod;
    }

    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code page} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getPage() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPage());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamPage()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param page  A {@code String} that is the value of the {@code page} URL parameter to set.
     */
    public void setPage(String page) {
        this.resetValues(this.getUrlParametersInstance().getParamPage());
        this.addValue(this.getUrlParametersInstance().getParamPage(), page);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code action} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getAction() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamAction());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamAction()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param action    A {@code String} that is the value of the {@code action} URL parameter 
     *                  to set.
     */
    public void setAction(String action) {
        this.resetValues(this.getUrlParametersInstance().getParamAction());
        this.addValue(this.getUrlParametersInstance().getParamAction(), action);
    }

    /**
     * @return the post_form_submit parameter
     */
    public Boolean getPostFormSubmit() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPostFormSubmit());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamPostFormSubmit()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     *
     * @param isPostFormSubmit  A {@code String} that is the value of the {@code post_form_submit}
     *                          URL parameter to set.
     */
    public void setPostFormSubmit(Boolean isPostFormSubmit) {
        this.resetValues(this.getUrlParametersInstance().getParamPostFormSubmit());
        this.addValue(this.getUrlParametersInstance().getParamPostFormSubmit(), isPostFormSubmit);
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamData()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data} URL parameter. 
     *          Can be {@code null}. 
     */
    public String getDataKey() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamData());
    }
    
    /**
     * @return the gene_id parameter
     */
    public String getGeneId() {
    	return this.getFirstValue(this.getUrlParametersInstance().getParamGeneId());
    }
    /**
     * @return the gene_id parameter when storing multiple values
     */
    public List<String> getGeneIds() {
        return this.getValues(this.getUrlParametersInstance().getParamGeneId());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamGeneId()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param geneId    A {@code String} that is the value of the {@code gene_id} URL parameter 
     *                  to set.
     */
    public void setGeneId(String geneId) {
        this.resetValues(this.getUrlParametersInstance().getParamGeneId());
        this.addValue(this.getUrlParametersInstance().getParamGeneId(), geneId);
    }

    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamGeneList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code gene_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getGeneList() {
        return this.getValues(this.getUrlParametersInstance().getParamGeneList());
    }

    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamGeneList()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     *
     * @param geneList  A {@code List} of {@code String}s that is the value
     *                  of the {@code gene_id} URL parameter to set.
     */
    public void setGeneList(List<String> geneList){
        this.resetValues(this.getUrlParametersInstance().getParamGeneList());
        this.addValues(this.getUrlParametersInstance().getParamGeneList(), geneList);
    }
    
    /**
     * @return the species_id parameter
     */
    public Integer getSpeciesId() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamSpeciesId());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamSpeciesId()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param speciesId     An {@code Integer} that is the value of the {@code species_id}
     *                      URL parameter to set.
     */
    public void setSpeciesId(Integer speciesId) {
        this.resetValues(this.getUrlParametersInstance().getParamSpeciesId());
        this.addValue(this.getUrlParametersInstance().getParamSpeciesId(), speciesId);
    }

    /**
     * @return the query parameter for a search
     */
    public String getQuery() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamQuery());
    }
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamSpeciesId()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     *
     * @param queryTerm    A {@code String} that is the value of the {@code query}
     *                      URL parameter to set.
     */
    public void setQuery(String queryTerm) {
        this.resetValues(this.getUrlParametersInstance().getParamQuery());
        this.addValue(this.getUrlParametersInstance().getParamQuery(), queryTerm);
    }

    /**
     * @return A {@code String} that will be used as the hash part of URLs returned by 
     *         the  {@code getRequestURL} methods. See {@link #setURLHash(String)} 
     *         for more details.
     * @see #setURLHash(String)
     */
    public String getURLHash() {
        return urlHash;
    }
    /**
     * Set the 'hash' to be added at the end of the URLs generated by the {@code getRequestURL} 
     * methods. This method should be used only to actually link to an element 
     * with the corresponding ID in a page. It should not be used to use the hash 
     * to store data parameters (for instance, to link to pages where the hash part 
     * is used by javascript to read/write data parameters). For this latter use, 
     * see {@link #getRequestURL(Collection, boolean)} and 
     * {@link #getRequestURL(String, Collection, boolean, boolean)}.
     * <p>
     * Note that {@code urlHash} must not include the hash separator ('#').
     * 
     * @param urlHash   A {@code String} that will be used as the hash part of URLs returned by 
     *                  the  {@code getRequestURL} methods.
     */
    public void setURLHash(String urlHash) {
        this.urlHash = urlHash;
    }

    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamDisplayType()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param displayType   A {@code String} that is the value of the {@code display_type}
     *                      URL parameter to set.
     */
    public void setDisplayType(String displayType) {
        this.resetValues(this.getUrlParametersInstance().getParamDisplayType());
        this.addValue(this.getUrlParametersInstance().getParamDisplayType(), displayType);
    }
    
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamSpeciesList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code species_list} URL parameter. Can be {@code null}. 
     */
    public List<Integer> getSpeciesList(){
        return this.getValues(this.getUrlParametersInstance().getParamSpeciesList());
    }
    
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamSpeciesList()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param speciesList   A {@code List} of {@code Integer}s that is the value
     *                      of the {@code gene_id} URL parameter to set.
     */
    public void setSpeciesList(List<Integer> speciesList){
        this.resetValues(this.getUrlParametersInstance().getParamSpeciesList());
        this.addValues(this.getUrlParametersInstance().getParamSpeciesList(), speciesList);
    }
    
    public List<String> getForegroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamForegroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamForegroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code fg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getForegroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamForegroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code bg_list} URL parameter. Can be {@code null}. 
     */
    public List<String> getBackgroundList() {
        return this.getValues(this.getUrlParametersInstance().getParamBackgroundList());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamBackgroundFile()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code bg_file} URL parameter.
     *          Can be {@code null}. 
     */
    public String getBackgroundFile() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamBackgroundFile());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamExprType()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code expr_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getExprType() {
        return this.getValues(this.getUrlParametersInstance().getParamExprType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataQuality()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code data_qual} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDataQuality() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDataQuality());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDataType()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code data_type} URL parameter. Can be {@code null}. 
     */
    public List<String> getDataType() {
        return this.getValues(this.getUrlParametersInstance().getParamDataType());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamDevStage()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code stage_id} URL parameter. Can be {@code null}.
     */
    public List<String> getDevStage() {
        return this.getValues(this.getUrlParametersInstance().getParamDevStage());
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamStageDescendant()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamStageDescendant()},
     *          {@code false} otherwise.
     */
    public boolean isDevStageDescendant() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamStageDescendant())));
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamAnatEntity()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  The {@code List} of {@code String}s that are the values of 
     *          the {@code anat_entity_id} URL parameter. Can be {@code null}.
     */
    public List<String> getAnatEntity() {
        return this.getValues(this.getUrlParametersInstance().getParamAnatEntity());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by
     * {@link URLParameters#getParamDiscardAnatEntity()}. Equivalent to calling
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  The {@code List} of {@code String}s that are the values of
     *          the {@code discard_anat_entity_and_children_id} URL parameter. Can be {@code null}.
     */
    public List<String> getDiscardAnatEntity() {
        return this.getValues(this.getUrlParametersInstance().getParamDiscardAnatEntity());
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamAnatEntityDescendant()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamAnatEntityDescendant()},
     *          {@code false} otherwise.
     */
    public boolean isAnatEntityDescendant() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamAnatEntityDescendant())));
    }
    /**
     * Convenient method to retrieve values of the parameter returned by
     * {@link URLParameters#getParamCellType()}. Equivalent to calling
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  The {@code List} of {@code String}s that are the values of
     *          the {@code cell_type_id} URL parameter. Can be {@code null}.
     */
    public List<String> getCellType() {
        return this.getValues(this.getUrlParametersInstance().getParamCellType());
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamCellTypeDescendant()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamCellTypeDescendant()},
     *          {@code false} otherwise.
     */
    public boolean isCellTypeDescendant() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamCellTypeDescendant())));
    }
    /**
     * Convenient method to retrieve the value was sent for the URL parameter
     * {@link URLParameters#getParamObservedData()}.
     *
     * @return  {@code true}/{@code false} if it was requested for {@link URLParameters#getParamObservedData()},
     *          {@code null} otherwise.
     */
    public Boolean getObservedData() {
        log.traceEntry();
        Boolean paramObservedData = this.getFirstValue(
                this.getUrlParametersInstance().getParamObservedData());
        if (Boolean.TRUE.equals(paramObservedData)) {
            return log.traceExit(Boolean.TRUE);
        }
        if (Boolean.FALSE.equals(paramObservedData)) {
            return log.traceExit(Boolean.FALSE);
        }
        return log.traceExit((Boolean) null);
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamExcludeNonInformative()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamExcludeNonInformative()},
     *          {@code false} otherwise.
     */
    public boolean isExcludeNonInformative() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamExcludeNonInformative())));
    }
    /**
     * Convenient method to retrieve which value was sent for the URL parameter
     * {@link URLParameters#getOnlyPropagated()}.
     *
     * @return  {@code true}/{@code false} if it was requested for {@link URLParameters#getOnlyPropagated()},
     *          {@code null} otherwise.
     */
    public Boolean getOnlyPropagated() {
        log.traceEntry();
        Boolean onlyPropagated = this.getFirstValue(
                this.getUrlParametersInstance().getOnlyPropagated());
        if (Boolean.TRUE.equals(onlyPropagated)) {
            return log.traceExit(Boolean.TRUE);
        }
        if (Boolean.FALSE.equals(onlyPropagated)) {
            return log.traceExit(Boolean.FALSE);
        }
        return log.traceExit((Boolean) null);
    }
    /**
     * Convenient method to retrieve values of the parameter returned by
     * {@link URLParameters#getParamSex()}. Equivalent to calling
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of
     *          the {@code sex} URL parameter. Can be {@code null}.
     */
    public List<String> getSex() {
        return this.getValues(this.getUrlParametersInstance().getParamSex());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by
     * {@link URLParameters#getParamStrain()}. Equivalent to calling
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of
     *          the {@code strain} URL parameter. Can be {@code null}.
     */
    public List<String> getStrain() {
        return this.getValues(this.getUrlParametersInstance().getParamStrain());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by
     * {@link URLParameters#getParamExpAssayId()}. Equivalent to calling
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of
     *          the {@code exp_assay_id} URL parameter. Can be {@code null}.
     */
    public List<String> getExpAssayId() {
        return this.getValues(this.getUrlParametersInstance().getParamExpAssayId());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by
     * {@link URLParameters#getParamExperimentId()}. Equivalent to calling
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code String} that is the value of
     *          the {@code exp_id} URL parameter. Can be {@code null}.
     */
    public String getExperimentId() {
        log.traceEntry();
        return log.traceExit(this.getFirstValue(
                this.getUrlParametersInstance().getParamExperimentId()));
    }

    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamGetSpeciesList()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamGetSpeciesList()},
     *          {@code false} otherwise.
     */
    public boolean isGetSpeciesList() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamGetSpeciesList())));
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamGetResults()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamGetResults()},
     *          {@code false} otherwise.
     */
    public boolean isGetResults() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamGetResults())));
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamGetResultCount()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamGetResultCount()},
     *          {@code false} otherwise.
     */
    public boolean isGetResultCount() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamGetResultCount())));
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamGetColumnDefinition()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamGetColumnDefinition()},
     *          {@code false} otherwise.
     */
    public boolean isGetColumnDefinition() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamGetColumnDefinition())));
    }
    /**
     * Convenient method to identify whether a {@code TRUE} value was sent for the URL parameter
     * {@link URLParameters#getParamGetFilters()}.
     *
     * @return  {@code true} if it was requested for {@link URLParameters#getParamGetFilters()},
     *          {@code false} otherwise.
     */
    public boolean isGetFilters() {
        log.traceEntry();
        return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
                this.getUrlParametersInstance().getParamGetFilters())));
    }
    /**
     * Convenient method to retrieve the first value of the parameter returned by
     * {@link URLParameters#getParamOffset()}. Equivalent to calling
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code Long} that is the value for the
     *          {@code offset} URL parameter. Can be {@code null}.
     *          {@code Long} because sometimes the number of potential results
     *          can be very large.
     */
    public Long getOffset() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamOffset());
    }
    /**
     * Convenient method to retrieve the first value of the parameter returned by
     * {@link URLParameters#getParamLimit()}. Equivalent to calling
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     *
     * @return  An {@code Integer} that is the value for the
     *          {@code limit} URL parameter. Can be {@code null}.
     */
    public Integer getLimit() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamLimit());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamDecorrelationType()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code decorr_type} URL parameter.
     *          Can be {@code null}. 
     */
    public String getDecorrelationType() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamDecorrelationType());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNodeSize()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code node_size} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNodeSize() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNodeSize());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamNbNode()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code nb_node} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getNbNode() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamNbNode());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamFdrThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Double} that is the value of the {@code fdr_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Double getFdrThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamFdrThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamPValueThreshold()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Double} that is the value of the {@code p_value_thr} URL parameter.
     *          Can be {@code null}. 
     */
    public Double getPValueThreshold() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPValueThreshold());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamJobId()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  An {@code Integer} that is the value of the {@code job_id} URL parameter.
     *          Can be {@code null}. 
     */
    public Integer getJobId() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamJobId());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamGeneInfo()}. Equivalent to calling 
     * {@link #getFirstValue(URLParameters.Parameter)} for this parameter.
     * 
     * @return  A {@code Boolean} that is the value of the {@code gene_info} URL parameter.
     *          Can be {@code null}. 
     */
    public Boolean getGeneInfo() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamGeneInfo());
    }
    /**
     * Convenient method to retrieve value of the parameter returned by 
     * {@link URLParameters#getParamApiKey()}. Equivalent to calling 
     * {@link #getFirstValue(Parameter)} for this parameter.
     * 
     * @return  A {@code String} that is the value of the {@code api_key} URL parameter.
     *          Can be {@code null}. 
     */
    public String getApiKey() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamApiKey());
    }
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamAnatEntityList()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code ae_list} URL parameter. Can be {@code null}.
     */
    public List<String> getAnatEntityList() {
        return this.getValues(this.getUrlParametersInstance().getParamAnatEntityList());
    }
    
    /**
     * Convenient method to retrieve values of the parameter returned by 
     * {@link URLParameters#getParamPropagation()}. Equivalent to calling 
     * {@link #getValues(URLParameters.Parameter)} for this parameter.
     *
     * @return  A {@code List} of {@code String}s that are the values of 
     *          the {@code propagation} URL parameter. Can be {@code null}.
     */
    public String getPropagation() {
        return this.getFirstValue(this.getUrlParametersInstance().getParamPropagation());
    }
    
    /**
     * Convenient method to set value of the parameter returned by 
     * {@link URLParameters#getParamAnatEntityList()}. Equivalent to calling 
     * {@link #addValue(URLParameters.Parameter, Object)} for this parameter.
     * 
     * @param anatEntityList    A {@code List} of {@code String}s that is the value
     *                          of the {@code gene_id} URL parameter to set.
     */
    public void setAnatEntityList(List<String> anatEntityList){
        this.resetValues(this.getUrlParametersInstance().getParamAnatEntityList());
        this.addValues(this.getUrlParametersInstance().getParamAnatEntityList(), 
                anatEntityList);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Xml or not
     */
    public boolean isXmlDisplayType() {
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_XML)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    public boolean isHtmlDisplayType() {
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_HTML)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Csv or not
     */
    public boolean isCsvDisplayType() {
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_CSV)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is Tsv or not
     */
    public boolean isTsvDisplayType() {
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_TSV)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the display is JSON or not
     */
    public boolean isJsonDisplayType() {
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamDisplayType()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamDisplayType()).equals(
                        DISPLAY_TYPE_JSON)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * Allow to know if this request has been performed through AJAX. 
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if this request was performed through AJAX
     */
    public boolean isAnAjaxRequest() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamAjax()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamAjax())) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * Allow to know if this request has been performed through a POST form. 
     *
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return      {@code true} if this request was performed through a POST form.
     * @implNote    Note that this parameter is never present in the URL returned 
     *              by the {@code getRequestURL...} methods (see 
     *              {@link RequestParameters#generateParametersQuery(
     *              Set, boolean, boolean, String, Collection, boolean)}) 
     */
    public boolean isPostFormSubmit() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPostFormSubmit()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPostFormSubmit())) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the page corresponds to the homepage
     */
    public boolean isTheHomePage(){
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) == null){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request is related to species.
     */
    public boolean isASpeciesPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SPECIES)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          species list upload.
     */
    public boolean isASpeciesUpload() {
        log.traceEntry();
        if (isASpeciesPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_SPECIES_UPLOAD)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "about"
     */
    public boolean isAnAboutPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_ABOUT)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "privacy_policy"
     */
    public boolean isAPrivatePolicyPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_PRIVACY_POLICY)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "collaborations"
     */
    public boolean isAcollaborationsPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_COLLABORATIONS)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to job management.
     */
    public boolean isAJobPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_JOB)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to DAO queries.
     */
    public boolean isADAOPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DAO)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * @return  A {@code boolean} to tell whether the request is related to BgeeDB_R package queries.
     */
    public boolean isARPackagePageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_RPACKAGE)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "resources".
     */
    public boolean isAResourcesPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_RESOURCES)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "publication".
     */
    public boolean isAPublicationPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_PUBLICATION)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "sparql".
     */
    public boolean isASparqlPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SPARQL)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to queries for usage statistics 
     *          (meaning, queries made by clients solely for us to have usage statistics).
     */
    public boolean isAStatsPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_STATS)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether it is requested to cancel a job.
     */
    public boolean isACancelJob() {
        log.traceEntry();
        if (this.isAJobPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_CANCEL_JOB)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request is related to topAnat.
     */
    public boolean isATopAnatPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
            this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_TOP_ANAT)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "admin"
//     */
//    public boolean isAnAdminPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("admin")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "anatomy"
//     */
//    public boolean isAnAnatomyPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) == null || 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("anatomy")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          gene list upload in topAnat.
     */
    public boolean isATopAnatGeneUpload() {
        log.traceEntry();
        if (isATopAnatPageCategory() && 
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_GENE_VALIDATION)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a submission of a submission of a new job in topAnat.
     */
    public boolean isATopAnatSubmitJob() {
        log.traceEntry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_SUBMIT_JOB)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          a tracking job in topAnat.
     */
    public boolean isATopAnatTrackingJob() {
        log.traceEntry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_TRACKING_JOB)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} to tell whether the request is related to
     *          get a job in topAnat.
     */
    public boolean isATopAnatGetResult() {
        log.traceEntry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_GET_RESULT)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * @return  A {@code boolean} defining whether it is requested to send to client a result file 
     *          from TopAnat.
     */
    public boolean isATopAnatDownloadFile() {
        log.traceEntry();
        if (isATopAnatPageCategory() &&
                this.getAction() != null && this.getAction().equals(ACTION_TOP_ANAT_DOWNLOAD)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return  A {@code boolean} to tell whether the request is related to anat. similarity page.
     */
    public boolean isAAnatSimilarityPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_ANAT_SIM)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "documentation"
     */
    public boolean isADocumentationPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOCUMENTATION)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "download"
     */
    public boolean isADownloadPageCategory(){
        log.traceEntry();
        if(this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DOWNLOAD)){
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }    

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "expression"
//     */
//    public boolean isAnExpressionPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("expression")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "gene"
     */
    public boolean isAGenePageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_GENE)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    
    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "expression_comparison"
     */
    public boolean isAExprComparisonPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_EXPR_COMPARISON)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     *
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     *          category "raw_data"
     */
    public boolean isADataPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_DATA)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * 
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "source"
     */
    public boolean isASourcePageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SOURCE)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     *
     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
     * category "search"
     */
    public boolean isASearchPageCategory() {
        log.traceEntry();
        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_SEARCH)) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }
    /**
    *
    * @return  A {@code boolean} to tell whether the request corresponds to a page of the
    * category "feedback"
    */
   public boolean isAFeedbackPageCategory() {
       log.traceEntry();
       if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
               this.getFirstValue(this.urlParametersInstance.getParamPage()).equals(PAGE_FEEDBACK)) {
           return log.traceExit(true);
       }
       return log.traceExit(false);
   }
   /**
    * Determine whether the detailed information about the request parameters must be provided.
    * Corresponds to the URL parameter {@link URLParameters#getParamDetailedRequestParams()}.
    *
    * @return  {@code true} if detailed information must be provided, {@code false} otherwise.
    */
   public boolean isDetailedRequestParameters() {
       log.traceEntry();
       return log.traceExit(Boolean.TRUE.equals(this.getFirstValue(
               this.getUrlParametersInstance().getParamDetailedRequestParams())));
   }

    //    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "gene_family"
//     */
//    public boolean isAGeneFamilyPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("gene_family")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "log"
//     */
//    public boolean isALogPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("log")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "news"
//     */
//    public boolean isANewsPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("news")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "registration"
//     */
//    public boolean isARegistrationPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null &&
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("registration")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

//    /**
//     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
//     * consistent as much as possible if the method evolves.
//     * 
//     * @return  A {@code boolean} to tell whether the request corresponds to a page of the
//     * category "search"
//     */
//    public boolean isASearchPageCategory()
//    {
//        log.traceEntry();
//        if (this.getFirstValue(this.urlParametersInstance.getParamPage()) != null && 
//                this.getFirstValue(this.urlParametersInstance.getParamPage()).equals("search")) {
//            return log.traceExit(true);
//        }
//        return log.traceExit(false);
//    }

    /**
     * Determine whether the requested page contains sensitive information, 
     * such as passwords.
     * Such pages should then not be cached, or the URL be stored in the database, etc.
     * 
     * This method has a js counterpart in {@code requestparameters.js} that should be kept 
     * consistent as much as possible if the method evolves.
     * 
     * @return  {@code true} if the page contains sensitive information, {@code false} otherwise.
     */
    public boolean isASecuredPage() 
    {
        log.traceEntry();
        //TODO: implement when necessary (logging page, registration page, ...)
        return log.traceExit(false);
    }

    /**
     * Determine whether the output of the current request can be stored by the web-cache.
     * Some responses should never be cached, following, e.g., a user identification request, 
     * or a HEAD request (would lead to cache a blank page). 
     * At the opposite, we might be interested in caching only some pages 
     * (e.g., computation-intensive pages are always computed following an AJAX request, 
     * in order to display a waiting message; we could then only cache AJAX requests).
     * <p>
     * Also, some cookies should never be put in cache, because specific to a user.
     * so that a cache will never send cookies. ( TODO : Probably no cookies in the future, but
     * developers have to be aware of the problem. Now your are ! )
     * 
     * @return  {@code true} if the response following the current request should be cached
     */
    public boolean isACacheableRequest()
    {
        log.traceEntry();
        // Do not cache pages containing sensitive information
        if (this.isASecuredPage()) {
            return log.traceExit(false);
        }
        // Do not cache responses to HEAD requests, would lead to cache blank page
        // for security, we only accept POST and GET requests to be cached.
        // @see org.bgee.controller.servletUtils.BgeeWebCache#calculateKey(HttpServletRequest)
        if (!this.getHttpMethod().equalsIgnoreCase("get") && 
                !this.getHttpMethod().equalsIgnoreCase("post")) {
            return log.traceExit(false);
        }
        //do not cache POST request that are not AJAX requets: 
        //they should never send any response, and redirect the user to another page 
        //to avoid warning messages when pressing the back button.
        if(! this.isAnAjaxRequest() && this.getHttpMethod().equalsIgnoreCase("post")){
            return log.traceExit(false);
        }
        return log.traceExit(true);
    }

    /**
     * Perform security controls and prepare the submitted {@code String} for use, 
     * corresponding to the value of the provided parameter.
     * 
     * @param value     A {@code String} to be checked. 
     * @param parameter A {@code Parameter} which {@code stringToCheck} is 
     *                  the associated value, providing the security parameters 
     *                  (see {@link URLParameters.Parameter#getMaxSize()} and 
     *                  {@link URLParameters.Parameter#getFormat()})
     * @return          A secured and prepared {@code String}. 
     * @throws InvalidFormatException       if the format of {@code value} is invalid.
     * @throws ValueSizeExceededException   if {@code value} is too long.
     * @see #throwIfParamValueTooLong(URLParameters.Parameter, String)
     * @see #throwIfInvalidFormatParamValue(URLParameters.Parameter, String)
     */
    private String secureString(String value, URLParameters.Parameter<?> parameter) 
            throws InvalidFormatException, ValueSizeExceededException {
        log.traceEntry("{}, {}", value, parameter);
        if (value == null) {
            return log.traceExit("");
        }
        this.throwIfParamValueTooLong(parameter, value);
        this.throwIfInvalidFormatParamValue(parameter, value);
        return log.traceExit(value.trim());
    }
    
    /**
     * Throws a {@code ValueSizeExceededException} if the length of {@code value} is greater 
     * than the max allowed length for {@code parameter} (see {@link URLParameters.Parameter#getMaxSize()}).
     * 
     * @param parameter An {@code URLParameters.Parameter} used to validate the length of {@code value}.
     * @param value     A {@code value} to be validated for maximum length.
     * @throws ValueSizeExceededException   if {@code value} is too long.
     */
    private void throwIfParamValueTooLong(URLParameters.Parameter<?> parameter, String value) 
            throws ValueSizeExceededException {
        log.traceEntry("{}, {}", parameter, value);
        if (value == null) {
            log.traceExit(); return;
        }
        if (value.length() > parameter.getMaxSize()) {
            log.error("Value too long for parameter {}. Value length: {} - Max allowed length: {}", 
                    parameter, value.length(), parameter.getMaxSize());
            throw log.throwing(new ValueSizeExceededException(parameter));
        }
    }
    /**
     * Throws an {@code InvalidFormatException} if the format of {@code value} is invalid 
     * for {@code parameter} (see {@link URLParameters.Parameter#getFormat()}).
     * 
     * @param parameter An {@code URLParameters.Parameter} used to validate the format of {@code value}.
     * @param value     A {@code value} to be validated for correct format.
     * @throws InvalidFormatException   if the format of {@code value} is invalid.
     */
    private void throwIfInvalidFormatParamValue(URLParameters.Parameter<?> parameter, String value) 
            throws InvalidFormatException {
        log.traceEntry("{}, {}", parameter, value);
        if (value == null) {
            log.traceExit(); return;
        }
        log.trace("Trying to validate {} against format {}", value, parameter.getFormat());
        if (parameter.getFormat() != null && !value.trim().matches(parameter.getFormat())) {
            log.error("The string {} does not match the format {}", value, parameter.getFormat());
            //do not provide the accepted format in the exception, we don't need to provide 
            //too much information to potential hackers :p
            throw log.throwing(new InvalidFormatException(parameter));
        }
    }

    /**
     * Transform {@code paramValue} into a {@code boolean}. This {@code String} should first 
     * have been secured (see {@link #secureString(String, Parameter)}).
     * 
     * @param paramValue    A {@code String} corresponding to the value of a parameter 
     *                      in a request, to be converted into a {@code boolean}
     * @return  a {@code boolean} corresponding to {@code paramValue}. 
     *          Return {@code true} if {@code paramValue} is equal to "on", "true", or "1".
     */
    private boolean castToBoolean(String paramValue) {
        log.traceEntry("{}", paramValue);

        if (paramValue.equalsIgnoreCase("on") || 
                paramValue.equalsIgnoreCase("true") || 
                paramValue.equalsIgnoreCase("1")) {
            return log.traceExit(true);
        }
        return log.traceExit(false);
    }

    /**
     * @return  A {@code String} that is the character encoding used to encode/decode 
     *          query strings. 
     */
    public String getCharacterEncoding() {
        return this.charEncoding;
    }
    /**
     * Change the {@code boolean} defining whether parameters should be url encoded 
     * by the {@code encodeUrl} method.
     * @param encodeUrl A {@code boolean} defining whether parameters should be url encoded 
     *                  by the {@code encodeUrl} method.
     */
    public void setEncodeUrl(boolean encodeUrl) {
        this.encodeUrl = encodeUrl;
    }

    /**
     * Change the {@code String} defining the character(s) that are used as parameters 
     * separator in the URL   
     * @param parametersSeparator A {@code String} defining the character(s) that are used as 
     * parameters separator in the URL   
     */
    public void setParametersSeparator(String parametersSeparator) {
        this.parametersSeparator = parametersSeparator;
    }

    public String getParameterQuery() {
        return this.parametersQuery;
    }
}