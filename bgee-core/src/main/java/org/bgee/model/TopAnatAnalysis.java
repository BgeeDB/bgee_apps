package org.bgee.model;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bgee.model.expressiondata.querytool.CallService;
import org.bgee.model.species.Species;

import rcaller.RCaller;
import rcaller.RCode;

public class TopAnatAnalysis extends QueryTool {

    /**
     * 
     */
    private final static Logger log = LogManager
            .getLogger(TopAnatAnalysis.class.getName());

    /**
     * 
     */
    private final TopAnatParams params;

    /**
     * 
     */
    private final CallService callService;

    /**
     * 
     */
    private final BgeeProperties prop = BgeeProperties.getBgeeProperties();

    /**
     * 
     */
    private final Species species = null;

    /**
     * {@code ConcurrentMap} used to manage concurrent access to the
     * read/write locks that are used to manage concurrent reading and writing
     * of the files that can be simultaneously accessed by different threads. In
     * this {@code Map}, {@code keys} are file names, and
     * {@code values} are {@link ReentrantReadWriteLock}}.
     */
    private static ConcurrentMap<String, ReentrantReadWriteLock> readWriteLocks =
            new ConcurrentHashMap<String, ReentrantReadWriteLock>();

    /**
     * A {@code String} representing the tsv file which contains the
     * results in TSV format. This file consists of 7 columns: Organ ID, Organ
     * Name, Number of annotated genes, number of significant genes, expected
     * value , P value and FDR.
     */
    private String resultTSVFileName;

    /**
     * A {@code String} representing the pdf file which contains the graph
     * result generated by topAnat. The graph contains information about the most
     * significantly expressed nodes.
     */
    private String resultGraphPDFFileName;

    /**
     * A {@code String} representing the path to the "organ relationships"
     * file. This file stores the is_a and part_of relationships between
     * anatomical structures, from the anatomical ontology being used. These
     * relations are actually always the same for a given ontology, so this file
     * is generated only once for a given ontology, if it does not already
     * exist.
     * 
     * @see #generateOrganRelationshipsFile()
     * @see #beginTopAnatAnalysis(String)
     */
    private String organRelationshipsFileName;

    /**
     * A {@code String} representing the path to "organ names" file. This
     * file stores the relations between IDs and names of anatomical structures
     * of the anatomical ontology being used. These names are actually always
     * the same for a given ontology, so this file is generated only once for a
     * given ontology, if it does not already exist.
     * 
     * @see #generateOrganNamesFile()
     * @see #beginTopAnatAnalysis(String)
     */
    private String organNamesFileName;

    /**
     * A {@code String} representing the path to the "gene to organ"
     * association file. This file stores the associations from background
     * genes, to anatomical structures, based on expression data.
     * 
     * @see #generateGenesToOrgansAssociationFile()
     * @see #beginTopAnatAnalysis(String)
     */
    private String geneToOrganFileName ;

    @Override
    protected Logger getLogger() {
        return log;
    }

    /**
     * 
     * @param params
     */
    public TopAnatAnalysis(TopAnatParams params) {
        this(new CallService(),params);
    }

    /**
     * 
     * @param params
     */
    public TopAnatAnalysis(CallService callService,TopAnatParams params) {
        log.entry(callService,params);
        this.callService = callService;
        this.params = params;
        log.exit();
    }

    /**
     * 
     * @throws IOException
     */
    public void beginTopAnatAnalysis() throws IOException{
        log.entry();

        this.resultTSVFileName = "topAnatResult_" + this.getTaskName()
        + ".tsv";
        log.info("Result File: {}", this.resultTSVFileName);
        File topAnatResult = new File(
                this.prop.getTopAnatResultsWritingDirectory(),
                this.resultTSVFileName);
        this.resultGraphPDFFileName = "topAnatResultPDF_"
                + this.getTaskName() + ".pdf";
        log.info(this.resultGraphPDFFileName);
        File topAnatResultPDF = new File(
                this.prop.getTopAnatResultsWritingDirectory(),
                this.resultGraphPDFFileName);

        //we will write results into tmp files, moved at the end if everything 
        //went fine.
        String tmpResultFileName = topAnatResult.getPath() + ".tmp";

        String tmpPDFFileName = topAnatResultPDF.getPath() + ".tmp";

        // TODO
        // Check whether the foreground is included in the background
        // Detect species        
        // Get anat data
        // Get call data
        // Write R input file
        // perform R function and write output
        
        try{
            // check le lock
            // perform the R anaysis
            this.performRCallerFunctions(tmpResultFileName, tmpPDFFileName);
        }
        finally{
            // delete tmp files
            // unlock lock
        }
        log.exit();
    }

    private void performRCallerFunctions(String resultFileName, String resultPDFFileName) 
            throws IOException {
        log.entry();
        RCaller caller = new RCaller();
        RCode code = new RCode();
        caller.setRscriptExecutable(prop.getTopAnatRScriptExecutable());
        if (log.isDebugEnabled()) {
            caller.redirectROutputToFile(resultFileName + ".R_console", true);
        }
        code.clear();
        code.addRCode("packageExistRgraphviz<-require(Rgraphviz)");
        code.addRCode("if(!packageExistRgraphviz){");
        code.addRCode("source('http://bioconductor.org/biocLite.R')");
        code.addRCode("biocLite('Rgraphviz')}");

        code.addRCode("packageExistRUniversal<-require(Runiversal)");
        code.addRCode("if(!packageExistRUniversal){");
        code.addRCode("source('http://bioconductor.org/biocLite.R')");
        code.addRCode("biocLite('Runiversal')}");

        code.addRCode("packageExistTopGO<-require(topGO)");
        code.addRCode("if(!packageExistTopGO){");
        code.addRCode("source('http://bioconductor.org/biocLite.R')");
        code.addRCode("biocLite('topGO')}");

        code.addRCode("packageExistRJava<-require(rJava)");
        code.addRCode("if(!packageExistRJava){");
        code.addRCode("source('http://bioconductor.org/biocLite.R')");
        code.addRCode("biocLite('rJava')}");

        code.addRCode("library(topGO)");
        code.addRCode("setwd('" + prop.getTopAnatRWorkingDirectory()
        + "')");
        code.R_source(prop.getTopAnatFunctionFile());

        code.addRCode("resultExist <- FALSE");

        String[] topOBOResultFile = { resultFileName };
        code.addStringArray("topOBOResultFile", topOBOResultFile);

        String[] topOBOResultPDFFile = { resultPDFFileName };
        code.addStringArray("resultPDF", topOBOResultPDFFile);

        // Organ Relationships File
        String[] organRelationships = { this.organRelationshipsFileName };
        code.addStringArray("organRelationshipsFileName", organRelationships);
        code.addRCode("tab <- read.table(organRelationshipsFileName,header=FALSE, sep='\t')");
        code.addRCode("relations <- tapply(as.character(tab[,2]), as.character(tab[,1]), unique)");
        code.addRCode("print('Relations:')");
        code.addRCode("head(relations)");

        // Gene to Organ Relationship File
        String[] geneToOrgan = { this.geneToOrganFileName };
        code.addStringArray("geneToOrganFileName", geneToOrgan);
        //maybe the background is empty because of too stringent parameters.
        //Check whether file is empty, otherwise an error would be generated
        code.addRCode("if (file.info(geneToOrganFileName)$size != 0) {");
        code.addRCode("  tab <- read.table(geneToOrganFileName,header=FALSE, sep='\t')");
        code.addRCode("  gene2anatomy <- tapply(as.character(tab[,2]), as.character(tab[,1]), unique)");
        code.addRCode("  print('GeneToAnaTomy:')");
        code.addRCode("  head(gene2anatomy)");

        // Organ Names File
        String[] organNames = { this.organNamesFileName };
        code.addStringArray("organNamesFileName", organNames);
        code.addRCode("  organNames <- read.table(organNamesFileName, header = FALSE, sep='\t',row.names=1)");
        code.addRCode("  names(organNames) <- organNames");
        code.addRCode("  print('OrganNames:')");
        code.addRCode("  head(organNames)");

        code.addStringArray("StringIDs",
                params.getSubmittedIds().toArray(new String[0]));

        code.addRCode("  geneList <- factor(as.integer(names(gene2anatomy) %in% StringIDs))");
        code.addRCode("  names(geneList) <- names(gene2anatomy)");
        code.addRCode("  print('GeneList:')");
        code.addRCode("  head(geneList)");
        //maybe all submitted genes are part of the background, or none of them, 
        //in that case we cannot proceed to the tests
        code.addRCode("  if (length(geneList) > 0 & length(levels(geneList)) == 2) {");

        code.addRCode("    myData <- maketopGOdataObject(parentMapping = relations,allGenes = geneList,nodeSize = "+ params.getNodeSize() + ",gene2Nodes = gene2anatomy)");
        //maybe make maketopGOdataObject to return an error code rather than using 'stop'?
        //then: code.addRCode("if (is.character(myData)) {...}");

        code.addRCode("    resFis <- runTest(myData, algorithm = '"
                + this.params.getDecorelationType().getCode() +"', statistic = '"
                + this.params.getStatisticTest().getCode() +"')");
        //under-representation disabled
        //code.addRCode("test.stat <- new('elimCount', testStatistic = GOFisherTestUnder, name ='Elim / Fisher test / underrepresentation')");
        //code.addRCode("resFis.under <- getSigGroups(myData, test.stat)");

        code.addRCode("    tableOver <- makeTable(myData,score(resFis), 1 , organNames)");
        code.addRCode("    tableOver <- data.frame(lapply(tableOver,as.character), stringsAsFactors=FALSE)");

        code.addRCode("    print(nrow(tableOver))");
        code.addRCode("    print(ncol(tableOver))");

        //if we get results, save the results and generate a graph visualization
        code.addRCode("    if(nrow(tableOver)!=0  & ncol(tableOver)==8){");
        code.addRCode("      print('RESULTS!')");
        code.addRCode("      write.table(tableOver, file=topOBOResultFile, sep='\t', row.names=F, col.names=T, quote=F)");
        code.addRCode("      resultExist <- TRUE");

        code.addRCode("      pValFis <- score(resFis)");
        code.addRCode("      pVal<-pValFis");
        code.addRCode("      pVal[pValFis==0]<- 100");

        code.addRCode("      organNames <- read.table(organNamesFileName, header = FALSE, sep='\t')");
        code.addRCode("      rownames(organNames)<-organNames[,1]");

        //get the number of terms with p-value below 0.01
        code.addRCode("      resultCount <- sum(as.numeric(tableOver[, 7]) <= "+ params.getPvalueThreashold() +")");
        //set the number of terms to be displayed (terms below p-value, but max 10)
        code.addRCode("      resultCount <- min(c(resultCount , "+ params.getNumberOfSignificantNodes() +"))");
        code.addRCode("      cat(paste('Number of nodes to display: ', resultCount, '\n'))");
        //generate the graph only if we have significant nodes
        code.addRCode("      if (resultCount != 0) {");
        code.addRCode("        printTopOBOGraph(myData, pVal, firstSigNodes = resultCount, fileName = resultPDF , useInfo = 'all',pdfSW = TRUE, organNames=organNames)");
        code.addRCode("      }");

        code.addRCode("    }");
        code.addRCode("  }");
        code.addRCode("}");

        //if there is no result, but no error occurred, we create an empty result file
        code.addRCode("if (!resultExist) {");
        code.addRCode("  cat('No result, creating an empty result file: ', topOBOResultFile, '\n')");
        code.addRCode("  file.create(topOBOResultFile)");
        //we need a tableOver object for RCaller to perform the commands
        code.addRCode("    tableOver <- data.frame(1, 8)");
        code.addRCode("}");

        //create File to use its path as lock name (because the same name 
        //is used in other methods)
        File geneToOrganAssociationFile = new File(
                prop.getTopAnatResultsWritingDirectory(),
                this.geneToOrganFileName);
        String geneToOrganAssociationFilePath = geneToOrganAssociationFile
                .getPath();
        File namesFile = new File(
                prop.getTopAnatResultsWritingDirectory(),
                this.organNamesFileName);
        String namesFileName = namesFile.getPath();
        File relsFile = new File(
                prop.getTopAnatResultsWritingDirectory(),
                this.organRelationshipsFileName);
        String relsFileName = relsFile.getPath();

        try {
            this.acquireReadLock(namesFileName);
            this.acquireReadLock(relsFileName);
            this.acquireReadLock(geneToOrganAssociationFilePath);

            log.info("Running statistical tests in R...");
            caller.setRCode(code);
            caller.runAndReturnResult("tableOver");

        } finally {
            this.releaseReadLock(namesFileName);
            this.releaseReadLock(relsFileName);
            this.releaseReadLock(geneToOrganAssociationFilePath);
        }

        log.exit();

    }

    /**
     * Generates the Organ ID to Organ Name association file, and organ relationship file, 
     * only if they do not already exist.
     * <p>
     * If only one species was submitted (see {@link #getDetectedSpecies()}, 
     * the method will write into a file named 
     * {@link #organNamesFileName}, the association between the organ IDs of this species 
     * and their name (see {@link #writeOrganNamesToFile(String, String)}), and into 
     * a file named {@link #organRelationshipsFileName}, the relations between the organs 
     * of this species (see {@link #writeOrganRelationsToFile(String, String)}).
     * <p>
     * √èf several species were submitted, the method will write in the file {@code 
     * #organNamesFileName} the association between HOG IDs and HOG names 
     * (see {@link #writeHogNamesToFile(String)}), and in the file {@code 
     * #organRelationshipsFileName}, the relations between HOGs (see {@link 
     * #writeHogRelationsToFile(String)}.
     * 
     * @throws IOException
     *             if the files cannot be opened or written to.
     * 
     * @see #organNamesFileName
     * @see #organRelationshipsFileName
     */
    private void generateOrganFiles() throws IOException {
        log.entry();

        log.info("Generating Organ files...");

        this.organNamesFileName = "OrganNames_" + this.species.getId() + ".tsv";
        this.organRelationshipsFileName = "OrganRelationships_" + this.species.getId() 
        + ".tsv";

        File namesFile = new File(
                this.prop.getTopAnatResultsWritingDirectory(),
                this.organNamesFileName);
        String namesFileName = namesFile.getPath();

        File relsFile = new File(
                this.prop.getTopAnatResultsWritingDirectory(),
                this.organRelationshipsFileName);
        String relsFileName = relsFile.getPath();

        //we will write results into a tmp file, moved at the end if everything 
        //went fine.
        String namesTmpFileName = namesFileName + ".tmp";
        Path namesTmpFile = Paths.get(namesTmpFileName);
        Path finalNamesFile = Paths.get(namesFileName);
        String relsTmpFileName = relsFileName + ".tmp";
        Path relsTmpFile = Paths.get(relsTmpFileName);
        Path finalRelsFile = Paths.get(relsFileName);

        try {
            this.acquireWriteLock(namesTmpFileName);
            this.acquireWriteLock(namesFileName);
            this.acquireWriteLock(relsTmpFileName);
            this.acquireWriteLock(relsFileName);

            //check, AFTER having acquired the locks, that the final files do not 
            //already exist (maybe another thread generated the files before this one 
            //acquires the lock)
            if (Files.exists(finalNamesFile) && Files.exists(finalRelsFile)) {
                log.info("Organ files already generated.");
                log.exit(); return;
            }

            this.writeOrganNamesToFile(namesTmpFileName, this.species.getId());
            this.writeOrganRelationsToFile(relsTmpFileName, this.species.getId());

            //move tmp files if successful
            //We check that there were no database error that could have corrupted the results
            //            if (Database.getDatabase().isError()) {
            //                throw log.throwing(new IllegalStateException("A database error occurred, " +
            //                        "analysis canceled"));
            //            }
            Files.move(namesTmpFile, finalNamesFile, StandardCopyOption.REPLACE_EXISTING);
            Files.move(relsTmpFile, finalRelsFile, StandardCopyOption.REPLACE_EXISTING);

        } finally {
            Files.deleteIfExists(namesTmpFile);
            Files.deleteIfExists(relsTmpFile);
            this.releaseWriteLock(namesTmpFileName);
            this.releaseWriteLock(namesFileName);
            this.releaseWriteLock(relsTmpFileName);
            this.releaseWriteLock(relsFileName);
        }

        log.info("organNamesFileName: {} - relationshipsFileName: {}", 
                this.organNamesFileName, this.organRelationshipsFileName);
        log.exit();
    }

    /**
     * Write into the file {@code organNameFile}, the association between names 
     * and IDs of organs, for the species with the ID {@code speciesId}. It will be 
     * a TSV file with no header, with each organ corresponding to a line, with the ID 
     * in the first column, and the name in the second column.
     * <p>
     * Note that it is not the responsibility of this method to acquire a write lock 
     * on the file, it is the responsibility of the caller.
     * 
     * @param organNameFile    A {@code String} that is the path to file where organ names 
     *                         will be written.
     * @param speciesId        A {@code String} that is the ID of the species for which 
     *                         we want organ names.
     * @throws IOException     If an error occurred while writing in the file.
     */
    private void writeOrganNamesToFile(String organNameFile, String speciesId) throws IOException {
        log.entry(organNameFile);

        //        try (PrintWriter out = new PrintWriter(new BufferedWriter(
        //                new FileWriter(organNameFile)))) {
        //
        //            OrganLoader organLoader = new OrganLoader();
        //            Collection<Organ> allOrgans = organLoader
        //                    .getOrgansBySpeciesId(speciesId);
        //            for (Organ organ : allOrgans)
        //                out.println(organ.getId() + "\t"
        //                        + organ.getName().replaceAll("'", ""));
        //        }

        log.exit();
    }

    /**
     * Write into the file {@code organRelFile}, the direct relations between organs, 
     * for the species with the ID {@code speciesId}. It will be a TSV file with no header, 
     * with each line corresponding to a relation, with the ID of the descent organ 
     * in the first column, and the ID of the parent organ in the second column. 
     * Only part_of and is_a relations should be considered.
     * <p>
     * Note that it is not the responsibility of this method to acquire a write lock 
     * on the file, it is the responsibility of the caller.
     * 
     * @param organRelFile     A {@code String} that is the path to file where organ relations 
     *                         will be written.
     * @param speciesId        A {@code String} that is the ID of the species for which 
     *                         we want organ names.
     * @throws IOException     If an error occurred while writing in the file.
     */
    private void writeOrganRelationsToFile(String organRelFile, String speciesId) 
            throws IOException {
        log.entry(organRelFile);

        //        try (PrintWriter out = new PrintWriter(new BufferedWriter(
        //                new FileWriter(organRelFile)))) {
        //
        //            OrganDAO organDAO = DAOFactory.getDAOFactory().getOrganDAO();
        //            Map<String, Set<String>> organRelationships = organDAO
        //                    .getDirectOrganRelationshipsBySpeciesId(speciesId);
        //            for (Map.Entry<String, Set<String>> entry : organRelationships
        //                    .entrySet())
        //                for (String descentId : entry.getValue())
        //                    out.println(descentId + '\t' + entry.getKey());
        //
        //        }

        log.exit();
    }

    /**
     * Generates the {@code {@link #geneToOrganFileName}} for the current
     * query required by the topOBO package.
     * <p>
     * This method generates the Gene to Organ association file required. It
     * uses a {@link #loadBackgroundGenesByIteration(int)} method to get a
     * specific number of genes at a time {@link #resultsCountByIteration} The
     * {@link #loadBackgroundGenesByIteration(int)} further analyzes whether a
     * list of background IDs has been submitted. It yes, it calls the
     * {@link #getBackgroundGenesFromUserByIteration(int)} to retrieve gene IDs
     * else, it calls the
     * {@link #getBackgroundGenesFromExpressionDataByIteration(int)} to retrieve
     * expression data from the BGEE database, And writes all the data to the
     * {@link #geneToOrganFileName}. 
     * <p>
     * Note that this method is not responsible for acquiring a write lock on 
     * {@code geneToOrganFile}, it is the responsibility of the caller to do it.
     * 
     * @param geneToOrganFile
     *            the path of the file in which the Gene to Organ data is to be
     *            written
     * @throws IOException
     *             if the {@code geneToOrganFileName} cannot be opened or
     *             written to.
     * @see #loadBackgroundGenesByIteration(int)
     * @see #getBackgroundGenesFromExpressionDataByIteration(int)
     * @see #getBackgroundGenesFromUserByIteration(int)
     * @see #geneToOrganFileName
     * @see #generateGenesToOrgansAssociationFile(String)
     */
    @SuppressWarnings("boxing")
    private void writeToGeneToOrganFile(String geneToOrganFile)
            throws IOException {
        log.entry(geneToOrganFile);

        //IMPORTANT: As of Bgee 12.1, only metastage IDs are permitted.
        //we retrieve the species-specific stage IDs belonging to this metastages
        //        StageLoader stageLoader = new StageLoader();
        //        String speciesId = this.getDetectedSpecies().iterator().next().getId();
        //        for (String metaStageId: this.getMetaStageIds()) {
        //            for (Stage stage: stageLoader.getAllStagesByMetaStageIdSpeciesId(
        //                    metaStageId, speciesId)) {
        //                this.inferredStageIds.add(stage.getId());
        //            }
        //        }
        //        log.debug("Species-specific stages retrived from metaStageIds {}: {}", 
        //                this.getMetaStageIds(), this.inferredStageIds);


        try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(
                geneToOrganFile)))) {

            int iterationCount = 1;
            // get the first set of genes by a first iteration
            //            Collection<Gene> genes = this
            //                    .loadBackgroundGenesByIteration(iterationCount);

            // iterate as many times as necessary to retrieve all genes
            // when we will have iterated every genes, the collection will be empty

            long finalRetreivalTime = 0;
            long finalWritingTime = 0;
            long finalNumberOfOrgans = 0;

//            while (!genes.isEmpty()) {
//
//                //                if (log.isDebugEnabled()) {
//                //                    log.debug("{} genes , {}th iteration", genes.size(),
//                //                            iterationCount);
//                //                }
//                long startOrganRetrieval = 0;
//                long stopOrganRetrieval = 0;
//                long organRetrievalTime = 0;
//                long startWritingInFile = 0;
//                long stopWritingInFile = 0;
//                long writingTime = 0;
//                int noOfOrgans = 0;
//
//                for (Gene gene : genes) {
//                    // load the anatomical structure where this gene is expressed,
//                    // corresponding to the submitted parameters
//                    // single species requested, we load species-specific
//                    // anatomical structures for this gene
//                    if (log.isDebugEnabled()) {
//                        startOrganRetrieval = new GregorianCalendar()
//                                .getTimeInMillis();
//                    }
//                    //NOTE: as of Bgee 12.1, all stages and sub-stages belonging 
//                    //to a metastage are retrieved, so we disable includeChildrenStages
//                    gene.loadRealOrgansFromStageIdsListAndExpression(
//                            this.getExpressionParameters(), this.inferredStageIds,
//                            //this.isIncludeChildrenStages());
//                            false);
//                    if (log.isDebugEnabled()) {
//                        stopOrganRetrieval = new GregorianCalendar()
//                                .getTimeInMillis();
//                        organRetrievalTime = organRetrievalTime
//                                + (stopOrganRetrieval - startOrganRetrieval);
//
//                    }
//
//                    if (log.isDebugEnabled()) {
//                        noOfOrgans = noOfOrgans
//                                + gene.getAnatomicalStructureIdsWithExpression()
//                                .size();
//                        startWritingInFile = new GregorianCalendar()
//                                .getTimeInMillis();
//                    }
//
//                    for (String organId : gene
//                            .getAnatomicalStructureIdsWithExpression())
//                        out.println(gene.getId() + '\t' + organId);
//
//                    if (log.isDebugEnabled()) {
//                        stopWritingInFile = new GregorianCalendar()
//                                .getTimeInMillis();
//                        writingTime = writingTime
//                                + (stopWritingInFile - startWritingInFile);
//                    }
//
//                    //reset the expression information to free mmemory
//                    gene.resetRealExpressionStructuresAndStages();
//                }
//                // trigger the next iteration to retrieve the next set of genes
//                if (log.isDebugEnabled()) {
//                    log.debug("Number of Organs for above {} GeneIDs: {}",
//                            this.getResultsCountByIteration(), noOfOrgans);
//                    log.debug("Time taken for organ retrieval for above {} GeneIDs: {}",
//                            this.getResultsCountByIteration(), organRetrievalTime);
//                    log.debug("Time taken to write to file for above {} GeneIDs: {}",
//                            this.getResultsCountByIteration(), writingTime);
//
//                    finalRetreivalTime = finalRetreivalTime + organRetrievalTime;
//                    finalWritingTime = finalWritingTime + writingTime;
//                    finalNumberOfOrgans = finalNumberOfOrgans + noOfOrgans;
//                }
//                iterationCount++;
//                long startGeneRetrieve = 0;
//                long stopGeneRetrieve = 0;
//                if (log.isDebugEnabled()) {
//                    startGeneRetrieve = new GregorianCalendar().getTimeInMillis();
//                }
//                genes = this.loadBackgroundGenesByIteration(iterationCount);
//                if (log.isDebugEnabled()) {
//                    stopGeneRetrieve = new GregorianCalendar().getTimeInMillis();
//
//                    log.debug(
//                            "Time taken to retrieve genes in  one iteration: {}",
//                            (stopGeneRetrieve - startGeneRetrieve));
//                }
//            }

            if (log.isDebugEnabled()) {
                log.debug("TOTAL NUMBER OF ORGANS RETRIEVED FOR aLL GENES: {}",
                        finalNumberOfOrgans);
                log.debug("TOTAL ORGAN RETREIVAL TIME: {}", finalRetreivalTime);
                log.debug("TOTAL WRITING TIME: : {}", finalWritingTime);
            }
        }
        log.exit();
    }    

    /**
     * Writes association between genes and the anatomical entities where they are 
     * expressed in a TSV file, named according to the value returned by 
     * {@link #getGeneToOrganFileName()}.
     * 
     * @throws IOException
     *             if the {@code geneToOrganFileName} cannot be opened or
     *             written to.
     * 
     * @see #geneToOrganFileName
     * @see #writeToGeneToOrganFile(String)
     */
    private void generateGenesToOrgansAssociationFile() throws IOException {
        log.entry();
        log.info("Generating Gene to Organ Association file...");

        File geneToOrganAssociationFile = new File(
                this.prop.getTopAnatResultsWritingDirectory(),
                this.geneToOrganFileName);
        String geneToOrganAssociationFilePath = geneToOrganAssociationFile
                .getPath();

        //we will write results into a tmp file, moved at the end if everything 
        //went fine.
        String tmpFileName = geneToOrganAssociationFilePath + ".tmp";
        Path tmpFile = Paths.get(tmpFileName);
        Path finalGeneToOrganFile = Paths.get(geneToOrganAssociationFilePath);

        try {
            this.acquireWriteLock(geneToOrganAssociationFilePath);
            this.acquireWriteLock(tmpFileName);

            //check, AFTER having acquired the locks, that the final file does not 
            //already exist (maybe another thread generated the files before this one 
            //acquired the lock)
            if (Files.exists(finalGeneToOrganFile)) {
                log.info("Gene to organ association file already generated.");
                log.exit(); return;
            }

            this.writeToGeneToOrganFile(tmpFileName);
            //move tmp file if successful
            //We check that there were no database error that could have corrupted the results
//            if (Database.getDatabase().isError()) {
//                throw log.throwing(new IllegalStateException("A database error occurred, " +
//                        "analysis canceled"));
//            }
            Files.move(tmpFile, finalGeneToOrganFile, StandardCopyOption.REPLACE_EXISTING);

        } finally {
            Files.deleteIfExists(tmpFile);
            this.releaseWriteLock(geneToOrganAssociationFilePath);
            this.releaseWriteLock(tmpFileName);
        }

        log.info("GeneToOrganAssociationFile: {}", this.geneToOrganFileName);
        log.exit();
    }    

    // *************************************************
    // FILE LOCKING
    // *************************************************
    /**
     * Acquires a write lock corresponding to the {@code fileName} by
     * calling the {@link #acquireLock(String, boolean)} method
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to acquire
     *            the read lock.
     * @see #acquireLock(String, boolean)
     */
    private void acquireReadLock(String fileName) {
        this.acquireLock(fileName, true);
    }

    /**
     * Acquires a write lock corresponding to the {@code fileName} by
     * calling the {@link #acquireLock(String, boolean)} method
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to acquire
     *            the write lock.
     * @see #acquireLock(String, boolean)
     */
    private void acquireWriteLock(String fileName) {
        this.acquireLock(fileName, false);
    }

    /**
     * Releases the write lock corresponding to the {@code fileName} by
     * calling the {@link #releaseLock(String, boolean)} method
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to release
     *            the write lock
     * @see #releaseLock(String, boolean)
     */
    private void releaseWriteLock(String fileName) {
        this.releaseLock(fileName, false);
    }

    /**
     * Method to acquire a lock on a file, corresponding to the param
     * {@code fileName}
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to
     *            retrieve the lock from {@code readWriteLocks}
     * @param readLock
     *            {@code true} if a read lock should be acquired.
     *            {@code false} if it should be a read lock
     * @see #readWriteLocks
     */
    private void acquireLock(String fileName, boolean readLock) {
        ReentrantReadWriteLock lock = this.getReadWriteLock(fileName);

        if (readLock) {
            lock.readLock().lock();
        } else {
            lock.writeLock().lock();
        }
        // {@code removeLockIfPossible(String)} determines whether the lock
        // could be removed
        // from the {@code ConcurrentHashMap} {@code readWriteLocks}.
        // The problem is that {@code removeLockIfPossible(String)} could
        // remove the lock from the map,
        // AFTER this method acquire a lock and put it in the map
        // (this.getReadWriteLock(this.getGeneratedKey())),
        // but BEFORE actually locking it (lock.readLock().lock()).
        // To solve this issue, this method will test after locking the lock
        // whether it is still in the map,
        // or whether the element present in the map is equal to the "locked"
        // lock.
        // If it is not, it will call again
        // {@code getReadWriteLock(String)}
        // to generate a new lock to be put in the map, or to obtain the lock
        // generated by another thread.
        while (readWriteLocks.get(fileName) == null
                || !readWriteLocks.get(fileName).equals(lock)) {

            lock = this.getReadWriteLock(fileName);
            if (readLock) {
                lock.readLock().lock();
            } else {
                lock.writeLock().lock();
            }
        }
    }

    /**
     * Releases the read lock corresponding to the {@code fileName} by
     * calling the {@link #releaseLock(String, boolean)} method
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to release
     *            the read lock
     * @see #releaseLock(String, boolean)
     */
    private void releaseReadLock(String fileName) {
        this.releaseLock(fileName, true);
    }

    /**
     * Method to release a lock on a file, corresponding to the param
     * {@code fileName}
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to release
     *            the lock from {@code readWriteLocks}
     * @param readLock
     *            {@code true} if a read lock should be acquired.
     *            {@code false} if it should be a read lock
     * @see #readWriteLocks
     */
    private void releaseLock(String fileName, boolean readLock) {
        ReentrantReadWriteLock lock = this.getReadWriteLock(fileName);
        if (readLock) {
            lock.readLock().unlock();
        } else {
            lock.writeLock().unlock();
        }
        this.removeLockIfPossible(fileName);
    }

    /**
     * Try to remove the {@code ReentrantReadWriteLock} corresponding to
     * the param {@code fileName}, from the {@code ConcurrentHashMap}
     * {@code readWriteLocks}. The lock will be removed from the map only
     * if there are no read or write locks, and no ongoing request for a read or
     * write lock.
     * <p>
     * Note: there might be here a race, where another thread acquired the lock
     * and actually locked it, i) just after this method tests the presence of
     * read or write locks and ongoing requests for a read or write lock, and
     * ii) just before removing it from the map. To solve this issue, methods
     * acquiring a lock must check after locking it whether it is still in the
     * readWriteLocks map, or whether the element present in the map for the key
     * is equal to the acquired lock. If it is not, they must generate a new
     * lock to be used.
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to
     *            retrieve the lock from {@code readWriteLocks}, to remove
     *            it.
     * @see #readWriteLocks
     */
    private void removeLockIfPossible(String fileName) {
        // check if there is already a lock stored for this key
        ReentrantReadWriteLock lock = readWriteLocks.get(fileName);

        // there is a lock to remove
        if (lock != null) {
            // there is no thread with write lock, or read lock, or waiting to
            // acquire a lock
            if (!lock.isWriteLocked() && lock.getReadLockCount() == 0
                    && !lock.hasQueuedThreads()) {
                // there might be here a race, where another thread acquired the
                // lock and
                // actually locked it, just after the precedent condition test,
                // and just before the following remove statement.
                // to solve this issue, methods acquiring a lock must check
                // after locking it
                // whether it is still in the readWriteLocks map.
                // if it is not, they must generate a new lock to be used.
                readWriteLocks.remove(fileName);
            }
        }
    }

    /**
     * Obtain a {@code ReentrantReadWriteLock}, for the param
     * {@code fileName}.
     * 
     * This method tries to obtain {@code ReentrantReadWriteLock}
     * corresponding to the fileName, from the {@code ConcurrentHashMap}
     * {@code readWriteLocks}. If the lock is not already stored, create a
     * new one, and put it in {@code readWriteLocks}, to be used by other
     * threads.
     * 
     * @param fileName
     *            a {@code String} corresponding to the fileName to
     *            retrieve the lock from {@code readWriteLocks}.
     * 
     * @return a {@code ReentrantReadWriteLock} corresponding to the
     *         fileName.
     * 
     * @see #readWriteLocks
     */
    private ReentrantReadWriteLock getReadWriteLock(String fileName) {
        // check if there is already a lock stored for this key
        ReentrantReadWriteLock readWritelock = readWriteLocks.get(fileName);

        // no lock already stored
        if (readWritelock == null) {
            ReentrantReadWriteLock newReadWriteLock = new ReentrantReadWriteLock(
                    true);
            // try to put the new lock in the ConcurrentHashMap
            readWritelock = readWriteLocks.putIfAbsent(fileName,
                    newReadWriteLock);
            // if readWritelock is null, the newLock has been successfully put
            // in the map, and we use it.
            // otherwise, it means that another thread has inserted a new lock
            // for this key in the mean time.
            // readWritelock then corresponds to this value, that we should use.
            if (readWritelock == null) {
                readWritelock = newReadWriteLock;
            }
        }
        return readWritelock;
    }

    // *******************
    // SETTER AN GETTER
    // *******************

//    /**
//     * @return the resultTSVFileName
//     */
//    private String getResultTSVFileName() {
//        return resultTSVFileName;
//    }
//
//    /**
//     * @param resultTSVFileName the resultTSVFileName to set
//     */
//    private void setResultTSVFileName(String resultTSVFileName) {
//        this.resultTSVFileName = resultTSVFileName;
//    }
//
//    /**
//     * @return the resultGraphPDFFileName
//     */
//    private String getResultGraphPDFFileName() {
//        return resultGraphPDFFileName;
//    }
//
//    /**
//     * @param resultGraphPDFFileName the resultGraphPDFFileName to set
//     */
//    private void setResultGraphPDFFileName(String resultGraphPDFFileName) {
//        this.resultGraphPDFFileName = resultGraphPDFFileName;
//    }

}
