package org.bgee.model.dao.api.expressiondata;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * This class allows to provide the parameters to filter the calls used, when 
 * retrieving information related to expression/no-expression/differential expression 
 * calls generated in the Bgee database.
 * 
 * @author Frederic Bastian
 * @version Bgee 13
 * @since Bgee 13
 */
public abstract class CallParams {
    /**
     * A {@code boolean} defining whether, when there are conditions on the data types
     * that should have contributed to the generation of the calls to be used, 
     * the calls used should satisfy all of these conditions, or at least one  
     * of these conditions. If {@code false}, they would satisfy at least one of them.
     * This is the recommended value.
     * <p>
     * For instance, if the minimum requested contributions to the calls to be 
     * used, of Affymetrix and RNA-Seq data, are {@code LOWQUALITY}: 
     * if {@code allDataTypes} is {@code false}, then expression data will be retrieved 
     * from calls generated by Affymetrix or Rna-Seq data indifferently; if {@code true}, 
     * data will be retrieved from calls generated by <strong>both</code> Affymetrix 
     * and RNA-Seq data.
     */
    private boolean allDataTypes;

    //****************************************
    // ANATOMICAL ENTITY FILTERING
    //****************************************
    /**
     * A {@code Set} of {@code String}s that are the IDs of anatomical entities 
     * allowing to filter the calls to use. Only calls with an anatomical entity ID 
     * equals to one of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #useAnatDescendants} is {@code true}, then calls with 
     * an anatomical entity ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the anatomical entities 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from substructures, 
     * see its documentation for more details.
     * 
     * @see #useAnatDescendants
     */
    private final Set<String> anatEntityIds;
    /**
     * A {@code boolean} defining whether calls for descendants of 
     * {@link #anatEntityIds} should also be used. It is used when {@link 
     * #anatEntityIds} is not empty, to define whether calls, with 
     * an anatomical entity ID equals to the ID of one of their descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubstructures()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from substructures 
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the anatomical ontology. Most of the time, users will not need to apply 
     * such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @see #anatEntityIds
     */
    private boolean useAnatDescendants;

    //****************************************
    // DEVELOPMENTAL STAGE FILTERING
    //****************************************
    /**
     * A {@code Set} of {@code String}s that are the IDs of developmental stages  
     * allowing to filter the calls to use. Only calls 
     * with a developmental stage ID equals to one of the ID in this {@code Set} 
     * will be used. 
     * <p>
     * If {@link #useDevDescendants} is {@code true}, then calls with 
     * a developmental stage ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the developmental stages  
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from sub-stages, 
     * see its documentation for more details.
     * 
     * @see #useDevDescendants
     */
    private final Set<String> devStageIds;
    /**
     * A {@code boolean} defining whether calls for descendants of 
     * {@link #devStageIds} should also be used. It is used when {@link 
     * #devStageIds} is not empty, to define whether calls, with 
     * a developmental stage ID equals to the ID of one of their descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubStages()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from sub-stages  
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the developmental ontology. Most of the time, users will not need to apply 
     * such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @see #devStageIds
     */
    private boolean useDevDescendants;
    
    //****************************************
    // GENE FILTERING
    //****************************************
    /**
     * A {@code Set} of {@code String}s that are the IDs of genes allowing to filter 
     * the calls to use. Only calls with a gene ID equals to one of the ID in 
     * this {@code Set} will be used. 
     */
    private final Set<String> geneIds;

    
    /**
     * Default constructor.
     */
    protected CallParams() {
        this.setAllDataTypes(false);
        
        this.anatEntityIds = new HashSet<String>();
        this.setUseAnatDescendants(false);
        
        this.devStageIds  = new HashSet<String>();
        this.setUseDevDescendants(false);
        
        this.geneIds      = new HashSet<String>();
    }

    /**
     * Returns the {@code boolean} defining whether, when there are conditions on 
     * the data types that should have contributed to the generation of the calls 
     * to be used, the calls used should satisfy all of these conditions, 
     * or at least one  of these conditions. If {@code false}, they would satisfy 
     * at least one of them. This is the recommended value.
     * <p>
     * For instance, if the minimum requested contributions to the calls to be 
     * used, of Affymetrix and RNA-Seq data, are {@code LOWQUALITY}: 
     * if {@code allDataTypes} is {@code false}, then expression data will be retrieved 
     * from calls generated by Affymetrix or Rna-Seq data indifferently; if {@code true}, 
     * data will be retrieved from calls generated by <strong>both</code> Affymetrix 
     * and RNA-Seq data.
     * 
     * @return  if {@code true}, the calls used will satisfy all conditions 
     *          on data types. If {@code false}, they will satisfy at least one of them.
     */
    public boolean isAllDataTypes() {
        return allDataTypes;
    }
    /**
     * Sets the {@code boolean} defining whether, when there are conditions on 
     * the data types that should have contributed to the generation of the calls 
     * to be used, the calls used should satisfy all of these conditions, 
     * or at least one  of these conditions. If {@code false}, they would satisfy 
     * at least one of them. This is the recommended value.
     * <p>
     * For instance, if the minimum requested contributions to the calls to be 
     * used, of Affymetrix and RNA-Seq data, are {@code LOWQUALITY}: 
     * if {@code allDataTypes} is {@code false}, then expression data will be retrieved 
     * from calls generated by Affymetrix or Rna-Seq data indifferently; if {@code true}, 
     * data will be retrieved from calls generated by <strong>both</code> Affymetrix 
     * and RNA-Seq data.
     * 
     * @param allDataTypes  if {@code true}, the calls used will satisfy 
     *                      all conditions on data types. If {@code false}, they 
     *                      will satisfy at least one of them. {@code false} is 
     *                      the recommended value.
     */
    public void setAllDataTypes(boolean allDataTypes) {
        this.allDataTypes = allDataTypes;
    }
    

    //****************************************
    // ANATOMICAL ENTITY FILTERING
    //****************************************
    /**
     * Add {@code id} to the {@code Set} of {@code String}s that are the IDs 
     * of anatomical entities allowing to filter the calls to use. 
     * Only calls with an anatomical entity ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseAnatDescendants()} is {@code true}, then calls with 
     * an anatomical entity ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the anatomical entities 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from substructures, 
     * see its documentation for more details.
     * 
     * @param id    A {@code String} to be added to the IDs of anatomical entities 
     *              used to filter the calls to use.
     * @see #setUseAnatDescendants(boolean)
     */
    public void addAnatEntityId(String id) {
        this.anatEntityIds.add(id);
    }
    /**
     * Add {@code ids} to the {@code Set} of {@code String}s that are the IDs 
     * of anatomical entities allowing to filter the calls to use. 
     * Only calls with an anatomical entity ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseAnatDescendants()} is {@code true}, then calls with 
     * an anatomical entity ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the anatomical entities 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from substructures, 
     * see its documentation for more details.
     * 
     * @param ids   A {@code Collection} of {@code String}s to be added to the IDs 
     *              of anatomical entities used to filter the calls to use.
     * @see #setUseAnatDescendants(boolean)
     */
    public void addAllAnatEntityIds(Collection<String> ids) {
        this.anatEntityIds.addAll(ids);
    }
    /**
     * Returns the {@code Set} of {@code String}s that are the IDs 
     * of anatomical entities allowing to filter the calls to use. 
     * Only calls with an anatomical entity ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseAnatDescendants()} is {@code true}, then calls with 
     * an anatomical entity ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the anatomical entities 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from substructures, 
     * see its documentation for more details.
     * 
     * @return      A {@code Collection} of {@code String}s that are the IDs 
     *              of anatomical entities used to filter the calls to use.
     * @see #isUseAnatDescendants()
     */
    public Set<String> getAnatEntityIds() {
        return this.anatEntityIds;
    }
    /**
     * Returns the {@code boolean} defining whether calls for descendants of 
     * the anatomical entities defined by {@link #getAnatEntityIds()} should also 
     * be used. It is used when {@link #getAnatEntityIds()} is not empty, 
     * to define whether calls, with an anatomical entity ID 
     * equals to the ID of one of their descendants, by <em>is_a</em> or <em>part_of</em> 
     * relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubstructures()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from substructures 
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the anatomical ontology. Most of the time, users will not need to apply 
     * such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @return  a {@code boolean} defining whether calls generated in the descendants 
     *          of the anatomical entities provided should also be used.
     * @see #getAnatEntityIds()
     */
    public boolean isUseAnatDescendants() {
        return this.useAnatDescendants;
    }
    /**
     * Sets the {@code boolean} defining whether calls for descendants of 
     * the anatomical entities defined by {@link #getAnatEntityIds()} should also 
     * be used. It is used when {@link #getAnatEntityIds()} is not empty, 
     * to define whether calls, with an anatomical entity ID 
     * equals to the ID of one of their descendants, by <em>is_a</em> or <em>part_of</em> 
     * relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubstructures()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from substructures 
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the anatomical ontology. Most of the time, users will not need to apply 
     * such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @param use       a {@code boolean} defining whether calls generated 
     *                  in the descendants of the anatomical entities 
     *                  provided should also be used.
     * @see #getAnatEntityIds()
     */
    public void setUseAnatDescendants(boolean use) {
        this.useAnatDescendants = use;
    }

    //****************************************
    // DEVELOPMENTAL STAGE FILTERING
    //****************************************
    /**
     * Add {@code id} to the {@code Set} of {@code String}s that are the IDs 
     * of developmental stages allowing to filter the calls to use. 
     * Only calls with a developmental stage ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseDevDescendants()} is {@code true}, then calls with 
     * a developmental stage ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the developmental stages 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from sub-stages, 
     * see its documentation for more details.
     * 
     * @param id    A {@code String} to be added to the IDs of developmental stages 
     *              used to filter the calls to use
     * @see #setUseDevDescendants(boolean)
     */
    public void addDevStageId(String id) {
        this.devStageIds.add(id);
    }
    /**
     * Add {@code ids} to the {@code Set} of {@code String}s that are the IDs 
     * of developmental stages allowing to filter the calls to use. 
     * Only calls with a developmental stage ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseDevDescendants()} is {@code true}, then calls with 
     * a developmental stage ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the developmental stages 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from sub-stages, 
     * see its documentation for more details.
     * 
     * @param ids   A {@code Collection} of {@code String}s that are the IDs 
     *              of developmental stages used to filter the calls to use.
     * @see #setUseDevDescendants(boolean)
     */
    public void addAllDevStageIds(Collection<String> ids) {
        this.devStageIds.addAll(ids);
    }
    /**
     * Returns the {@code Set} of {@code String}s that are the IDs 
     * of developmental stages allowing to filter the calls to use. 
     * Only calls with a developmental stage ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * <p>
     * If {@link #isUseDevDescendants()} is {@code true}, then calls with 
     * a developmental stage ID equals to the ID of one of the descendants, 
     * by <em>is_a</em> or <em>part_of</em> relations, of the developmental stages 
     * with their ID in this {@code Set}, will also be used. Note that this 
     * latter parameter has nothing to do with data propagation from sub-stages, 
     * see its documentation for more details.
     * 
     * @return      A {@code Collection} of {@code String}s that are the IDs 
     *              of developmental stages used to filter the calls to use.
     * @see #isUseDevDescendants()
     */
    public Set<String> getDevStageIds() {
        return this.devStageIds;
    }
    /**
     * Returns the {@code boolean} defining whether calls for descendants of 
     * the developmental stages defined by {@link #getDevStageIds()} should also 
     * be used. It is used when {@link #getDevStageIds()} is not empty, 
     * to define whether calls, with a developmental stage ID
     * equals to the ID of one of their descendants, by <em>is_a</em> or <em>part_of</em> 
     * relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubStages()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from sub-stages  
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the developmental stage ontology. Most of the time, users will not need 
     * to apply such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @return  a {@code boolean} defining whether calls generated in the descendants 
     *          of the developmental stages provided should also be used.
     * @see #getDevStageIds()
     */
    public boolean isUseDevDescendants() {
        return this.useDevDescendants;
    }
    /**
     * Sets the {@code boolean} defining whether calls for descendants of 
     * the developmental stages defined by {@link #getDevStageIds()} should also 
     * be used. It is used when {@link #getDevStageIds()} is not empty, 
     * to define whether calls, with a developmental stage ID
     * equals to the ID of one of their descendants, by <em>is_a</em> or <em>part_of</em> 
     * relations, should also be used.
     * <p>
     * Note that this parameter has nothing to do with the propagation of expression data 
     * (see {@link ExpressionCallTO#isIncludeSubStages()} for an example). 
     * It is only an advanced way of filtering the calls used, 
     * whether they were generated using data propagation or not. You will still 
     * be able to use calls based on data propagation from sub-stages  
     * when this parameter is {@code false}.
     * <p>
     * It is a way of asking to use calls generated in particular subgraphs 
     * of the developmental stage ontology. Most of the time, users will not need 
     * to apply such a filtering on entire subgraphs.
     * <p>
     * Default value is {@code false}.
     * 
     * @param use       a {@code boolean} defining whether calls generated 
     *                  in the descendants of the developmental stages 
     *                  provided should also be used.
     * @see #getDevStageIds()
     */
    public void setUseDevDescendants(boolean use) {
        this.useDevDescendants = use;
    }

    //****************************************
    // GENE FILTERING
    //****************************************
    /**
     * Add {@code id} to the {@code Set} of {@code String}s that are the IDs 
     * of genes allowing to filter the calls to use. 
     * Only calls with a gene ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * 
     * @param id    A {@code String} to be added to the IDs of genes 
     *              used to filter the calls to use.
     */
    public void addGeneId(String id) {
        this.geneIds.add(id);
    }
    /**
     * Add {@code ids} to the {@code Set} of {@code String}s that are the IDs 
     * of genes allowing to filter the calls to use. 
     * Only calls with a gene ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * 
     * @param ids   A {@code Collection} of {@code String}s that are the IDs 
     *              of genes used to filter the calls to use.
     */
    public void addAllGeneIds(Collection<String> ids) {
        this.geneIds.addAll(ids);
    }
    /**
     * Returns the {@code Set} of {@code String}s that are the IDs 
     * of genes allowing to filter the calls to use. 
     * Only calls with a gene ID equals to one 
     * of the ID in this {@code Set} will be used. 
     * 
     * @return      A {@code Collection} of {@code String}s that are the IDs 
     *              of genes used to filter the calls to use.
     */
    public Set<String> getGeneIds() {
        return this.geneIds;
    }
}
